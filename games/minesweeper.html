<!DOCTYPE html><head>
<title>LittleJS AI Starter Project</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="../dist/littlejs.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false; // Hide debug watermark in corner
showEngineVersion = false; // Hide engine version console display
paused = false; // Start unpaused

// engine settings, customize if necessary
gravity = vec2(0, 0); // No gravity by default
cameraPos = vec2(0, 0); // Camera centered at origin
cameraScale = 32; // Camera zoom, larger is more zoomed in

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Minesweeper

// NOTE: Some LittleJS builds don't expose a global `time` value.
// Use our own monotonic timer (seconds) so the game always runs.
const nowTime = ()=> performance.now() * 0.001;

// board config
const boardW = 16;
const boardH = 16;
const mineCount = 40;

// cell size in world units
const cellSize = 1;

// game state
let mines, nums, revealed, flagged;
let firstClick = true;
let gameOver = false;
let gameWon = false;
let revealAll = false;
let revealedCount = 0;
let startTime = 0;
let endTime = 0;

// sounds
let sReveal, sFlag, sUnflag, sBoom, sWin;

// helpers
const inBounds = (x,y)=> x>=0 && y>=0 && x<boardW && y<boardH;
const idx = (x,y)=> x + y*boardW;
const boardSize = vec2(boardW*cellSize, boardH*cellSize);
const boardOrigin = vec2(-boardSize.x/2, -boardSize.y/2);
const cellCenter = (x,y)=> boardOrigin.add(vec2((x+.5)*cellSize, (y+.5)*cellSize));

function resetGame()
{
    mines    = new Uint8Array(boardW*boardH);
    nums     = new Uint8Array(boardW*boardH);
    revealed = new Uint8Array(boardW*boardH);
    flagged  = new Uint8Array(boardW*boardH);

    firstClick = true;
    gameOver = false;
    gameWon = false;
    revealAll = false;
    revealedCount = 0;
    startTime = nowTime();
    endTime = startTime;
}

function placeMines(safeX, safeY)
{
    // exclude first click cell and its neighbors
    const banned = new Uint8Array(boardW*boardH);
    for (let oy=-1; oy<=1; oy++)
    for (let ox=-1; ox<=1; ox++)
    {
        const x = safeX+ox, y = safeY+oy;
        if (inBounds(x,y)) banned[idx(x,y)] = 1;
    }

    let placed = 0;
    while (placed < mineCount)
    {
        const x = randInt(boardW);
        const y = randInt(boardH);
        const i = idx(x,y);
        if (mines[i] || banned[i]) continue;
        mines[i] = 1;
        placed++;
    }

    // compute neighbor numbers
    for (let y=0; y<boardH; y++)
    for (let x=0; x<boardW; x++)
    {
        const i = idx(x,y);
        if (mines[i]) { nums[i] = 0; continue; }
        let n = 0;
        for (let oy=-1; oy<=1; oy++)
        for (let ox=-1; ox<=1; ox++)
        {
            if (!ox && !oy) continue;
            const nx = x+ox, ny = y+oy;
            if (inBounds(nx,ny) && mines[idx(nx,ny)]) n++;
        }
        nums[i] = n;
    }
}

function revealCell(x,y)
{
    if (!inBounds(x,y)) return;
    const i = idx(x,y);
    if (revealed[i] || flagged[i]) return;

    revealed[i] = 1;
    revealedCount++;

    if (mines[i])
    {
        gameOver = true;
        revealAll = true;
        endTime = nowTime();
        sBoom && sBoom.play();
        return;
    }

    sReveal && sReveal.play();

    // flood fill zeros
    if (nums[i] === 0)
    {
        const stack = [x,y];
        while (stack.length)
        {
            const cy = stack.pop();
            const cx = stack.pop();
            for (let oy=-1; oy<=1; oy++)
            for (let ox=-1; ox<=1; ox++)
            {
                const nx = cx+ox, ny = cy+oy;
                if (!inBounds(nx,ny)) continue;
                const ni = idx(nx,ny);
                if (revealed[ni] || flagged[ni]) continue;
                revealed[ni] = 1;
                revealedCount++;
                if (!mines[ni] && nums[ni] === 0)
                {
                    stack.push(nx, ny);
                }
            }
        }
    }

    checkWin();
}

function checkWin()
{
    if (gameOver || gameWon) return;
    if (revealedCount >= boardW*boardH - mineCount)
    {
        gameWon = true;
        endTime = nowTime();
        sWin && sWin.play();
        // auto-flag all mines
        for (let i=0; i<mines.length; i++)
            if (mines[i]) flagged[i] = 1;
    }
}

function tryChord(x,y)
{
    // if revealed number cell, and flags match number, reveal neighbors
    if (!inBounds(x,y)) return;
    const i = idx(x,y);
    if (!revealed[i] || mines[i] || nums[i] === 0) return;

    let f = 0;
    for (let oy=-1; oy<=1; oy++)
    for (let ox=-1; ox<=1; ox++)
    {
        if (!ox && !oy) continue;
        const nx = x+ox, ny = y+oy;
        if (inBounds(nx,ny) && flagged[idx(nx,ny)]) f++;
    }

    if (f !== nums[i]) return;

    for (let oy=-1; oy<=1; oy++)
    for (let ox=-1; ox<=1; ox++)
    {
        if (!ox && !oy) continue;
        revealCell(x+ox, y+oy);
    }
}

function toggleFlag(x,y)
{
    if (!inBounds(x,y) || gameOver || gameWon) return;
    const i = idx(x,y);
    if (revealed[i]) return;
    flagged[i] = flagged[i] ? 0 : 1;
    const snd = flagged[i] ? sFlag : sUnflag;
    snd && snd.play();
}

function pickCellFromMouse()
{
    // convert mouse world pos to cell indices
    const p = mousePos.subtract(boardOrigin);
    const x = (p.x / cellSize) | 0;
    const y = (p.y / cellSize) | 0;
    if (!inBounds(x,y)) return null;
    return {x,y};
}

///////////////////////////////////////////////////////////////////////////////
// Lightweight self-tests (logs only; wonâ€™t affect gameplay)
function assert(cond, msg)
{
    if (!cond)
        console.error('TEST FAIL:', msg);
}

function computeNumsForTest(w,h,minesBits)
{
    const out = new Array(w*h).fill(0);
    const inB = (x,y)=> x>=0 && y>=0 && x<w && y<h;
    const id = (x,y)=> x+y*w;
    for (let y=0;y<h;y++)
    for (let x=0;x<w;x++)
    {
        if (minesBits[id(x,y)]) continue;
        let n=0;
        for (let oy=-1;oy<=1;oy++)
        for (let ox=-1;ox<=1;ox++)
        {
            if (!ox && !oy) continue;
            const nx=x+ox, ny=y+oy;
            if (inB(nx,ny) && minesBits[id(nx,ny)]) n++;
        }
        out[id(x,y)] = n;
    }
    return out;
}

function runSelfTests()
{
    // 3x3 with one mine in center -> corners should be 1, edges should be 1
    const w=3,h=3;
    const minesBits = new Array(w*h).fill(0);
    minesBits[1+1*w] = 1;
    const n = computeNumsForTest(w,h,minesBits);
    assert(n[0]===1 && n[2]===1 && n[6]===1 && n[8]===1, 'Corners should be 1 with center mine');
    assert(n[1]===1 && n[3]===1 && n[5]===1 && n[7]===1, 'Edges should be 1 with center mine');
    assert(n[4]===0, 'Mine cell number unused (0 expected)');
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    // prevent browser right click menu
    document.addEventListener('contextmenu', e=>e.preventDefault());

    // a comfy fixed canvas for a board game
    setCanvasFixedSize(vec2(960, 720));

    // sound palette
    sReveal = new SoundGenerator({frequency:420, release:.05, volume:.7});
    sFlag   = new SoundGenerator({frequency:280, release:.08, shapeCurve:0, volume:.7});
    sUnflag = new SoundGenerator({frequency:220, release:.06, shapeCurve:2, volume:.6});
    sBoom   = new SoundGenerator({frequency:90,  release:.35, noise:.35, slide:-.8, volume:1});
    sWin    = new SoundGenerator({frequency:520, release:.25, slide:.6, volume:.9});

    runSelfTests();
    resetGame();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    // restart
    if (keyWasPressed('KeyR'))
        resetGame();

    const c = pickCellFromMouse();
    if (!c) return;

    // input: left click reveal, right click flag
    if (mouseWasPressed(2))
        toggleFlag(c.x, c.y);

    if (mouseWasPressed(0))
    {
        if (gameOver || gameWon)
            return;

        // shift+left = flag (nice on trackpads)
        if (keyIsDown('ShiftLeft') || keyIsDown('ShiftRight'))
        {
            toggleFlag(c.x, c.y);
            return;
        }

        // chord: click a revealed number to auto-open neighbors
        if (revealed[idx(c.x,c.y)])
        {
            tryChord(c.x, c.y);
            return;
        }

        if (firstClick)
        {
            placeMines(c.x, c.y);
            firstClick = false;
            startTime = nowTime();
        }

        revealCell(c.x, c.y);
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // fit board nicely in view
    cameraPos = vec2(0, 0);
    const margin = 120;
    const scaleX = (mainCanvasSize.x - margin) / boardSize.x;
    const scaleY = (mainCanvasSize.y - margin) / boardSize.y;
    cameraScale = max(16, min(scaleX, scaleY));
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // background (avoid drawRectGradient for compatibility)
    drawRect(cameraPos, getCameraSize(), hsl(0,0,.12));

    // board border
    drawRect(vec2(0,0), boardSize.add(vec2(.2)), hsl(0,0,.2));

    // hover highlight
    const c = pickCellFromMouse();
    if (c && !gameOver && !gameWon)
        drawRect(cellCenter(c.x,c.y), vec2(cellSize).scale(.98), hsl(.12,.2,.35,.35));

    // draw cells
    for (let y=0; y<boardH; y++)
    for (let x=0; x<boardW; x++)
    {
        const i = idx(x,y);
        const pos = cellCenter(x,y);
        const s = vec2(cellSize).scale(.95);

        const isRevealed = !!revealed[i];
        const isMine = !!mines[i];
        const isFlag = !!flagged[i];

        if (!isRevealed)
        {
            // hidden
            drawRect(pos, s, hsl(0,0,.28));
            drawRect(pos.add(vec2(.02,-.02)), s.scale(.92), hsl(0,0,.34));

            if (isFlag)
            {
                // simple flag: triangle + pole
                drawLine(pos.add(vec2(-.2,-.25)), pos.add(vec2(-.2,.25)), .08, hsl(.08,.7,.55));
                // drawPoly API can vary; draw a triangle using drawLine instead
                const p0 = pos.add(vec2(-.2,.15));
                const p1 = pos.add(vec2(.25,0));
                const p2 = pos.add(vec2(-.2,-.2));
                drawLine(p0, p1, .08, hsl(0,.75,.55));
                drawLine(p1, p2, .08, hsl(0,.75,.55));
                drawLine(p2, p0, .08, hsl(0,.75,.55));
            }
        }
        else
        {
            // revealed
            drawRect(pos, s, hsl(0,0,.18));

            if ((revealAll || gameOver) && isMine)
            {
                drawCircle(pos, .55, hsl(0,.7,.5));
                drawCircle(pos, .25, hsl(0,.7,.2));
            }
            else if (!isMine)
            {
                const n = nums[i];
                if (n)
                {
                    // number (no custom colors per number to keep it simple)
                    drawText(''+n, pos.add(vec2(0,-.18)), .75, hsl(.58,.5,.75), 0.25, hsl(0,0,0,.6));
                }
            }
        }

        // grid line feel
        drawRect(pos, vec2(cellSize), hsl(0,0,0,.12), 0, false);
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    const flagsUsed = flagged.reduce((a,b)=>a+b,0);
    const minesLeft = max(0, mineCount - flagsUsed);
    const now = nowTime();
    const t = (gameOver || gameWon) ? (endTime - startTime) : (now - startTime);

    const top = 36;

    drawTextScreen(`Mines: ${minesLeft}   Time: ${t|0}s   (Left: reveal, Right/Shift+Left: flag, R: restart)`,
        vec2(mainCanvasSize.x/2, top), 28,
        hsl(0,0,1), 4, hsl(0,0,0));

    if (firstClick)
        drawTextScreen('Click a cell to start (first click is always safe).', vec2(mainCanvasSize.x/2, top+38), 30,
            hsl(.15,.4,.8), 4, hsl(0,0,0));

    if (gameOver)
        drawTextScreen('BOOM! Press R to try again.', vec2(mainCanvasSize.x/2, mainCanvasSize.y-60), 52,
            hsl(0,.75,.65), 6, hsl(0,0,0));

    if (gameWon)
        drawTextScreen('You win! Press R to play again.', vec2(mainCanvasSize.x/2, mainCanvasSize.y-60), 52,
            hsl(.33,.6,.65), 6, hsl(0,0,0));
}

///////////////////////////////////////////////////////////////////////////////
// Startup LittleJS Engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
