<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>LittleJS Pong</title>
  <style>
    html, body { margin:0; padding:0; background:#000; overflow:hidden; }
  </style>
</head>
<body>
  <script src="../dist/littlejs.js?1.18.0"></script>
  <script>
  'use strict';

  // AI can use this class to generate sounds (from the LittleJS starter template)
  class SoundGenerator extends Sound
  {
      constructor(params = {})
      {
          const {
              volume = 1,        // Volume scale (percent)
              randomness = .05,  // How much to randomize frequency (percent Hz)
              frequency = 220,   // Frequency of sound (Hz)
              attack = 0,        // Attack time, how fast sound starts (seconds)
              release = .1,      // Release time, how fast sound fades out (seconds)
              shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
              slide = 0,         // How much to slide frequency (kHz/s)
              pitchJump = 0,     // Frequency of pitch jump (Hz)
              pitchJumpTime = 0, // Time of pitch jump (seconds)
              repeatTime = 0,    // Resets some parameters periodically (seconds)
              noise = 0,         // How much random noise to add (percent)
              bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
              delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
          } = params;

          super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
      }
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////
  // Pong State

  const fieldSize = vec2(40, 22);          // world units
  const halfField = fieldSize.scale(.5);

  const paddleSize = vec2(1.1, 5.2);
  const ballSize   = vec2(1.0, 1.0);

  const paddleSpeed = 18;
  const aiSpeed     = 15;

  const maxBallSpeed = 30;

  let left = { pos: vec2(-halfField.x + 2.2, 0) };
  let right = { pos: vec2( halfField.x - 2.2, 0) };

  let ball = { pos: vec2(0,0), vel: vec2(0,0) };

  let scoreL = 0;
  let scoreR = 0;

  let waitingForServe = true;
  let gameOver = false;
  let aiRight = true; // press T to toggle

  // AI configuration
  const aiReactionDelay = 0.15;   // seconds before AI reacts to ball direction change
  const aiErrorMargin = 1.5;      // random offset to make AI imperfect
  const aiPredictionNoise = 0.12; // noise in ball trajectory prediction
  let aiTargetY = 0;              // where AI wants to move
  let aiLastUpdate = 0;           // time of last prediction update
  let aiPredictedY = 0;           // predicted ball Y at paddle

  // Sounds
  let sfxPaddle, sfxWall, sfxScore, sfxServe;

  ///////////////////////////////////////////////////////////////////////////////////////////////
  // Helpers

  function aabbOverlap(posA, sizeA, posB, sizeB)
  {
      return Math.abs(posA.x - posB.x) < (sizeA.x + sizeB.x) * .5 &&
             Math.abs(posA.y - posB.y) < (sizeA.y + sizeB.y) * .5;
  }

  function clampPaddleY(p)
  {
      const limit = halfField.y - paddleSize.y/2;
      p.pos.y = clamp(p.pos.y, -limit, limit);
  }

  // Predict where ball will be when it reaches a given x position
  function predictBallY(targetX)
  {
      if (ball.vel.x === 0) return 0;
      
      let simPos = ball.pos.copy();
      let simVel = ball.vel.copy();
      const yLimit = halfField.y - ballSize.y/2;
      const maxSteps = 500;
      
      for (let i = 0; i < maxSteps; i++)
      {
          // Step simulation
          const dt = 0.016; // ~60fps step
          simPos = simPos.add(simVel.scale(dt));
          
          // Wall bounces
          if (simPos.y > yLimit) { simPos.y = yLimit; simVel.y = -Math.abs(simVel.y); }
          if (simPos.y < -yLimit) { simPos.y = -yLimit; simVel.y = Math.abs(simVel.y); }
          
          // Check if reached target x
          if ((simVel.x > 0 && simPos.x >= targetX) || (simVel.x < 0 && simPos.x <= targetX))
              return simPos.y;
      }
      return 0;
  }

  function resetRound(servingToRight)
  {
      ball.pos = vec2(0, 0);
      ball.vel = vec2(0, 0);
      waitingForServe = true;
      gameOver = false;

      // tiny nudge so it doesn't always serve dead-center
      left.pos.y = 0;
      right.pos.y = 0;

      // store who serves next on the ball object
      ball._serveDir = servingToRight ? 1 : -1;
  }

  function serve()
  {
      if (!waitingForServe || gameOver)
          return;

      // Serve direction: +x goes right, -x goes left
      const dirX = ball._serveDir ?? (randBool() ? 1 : -1);
      const angle = rand(-.25, .25); // slight vertical variance
      const speed = 14;
      ball.vel = vec2(dirX, angle).normalize(speed);
      waitingForServe = false;
      sfxServe?.play(ball.pos);
  }

  function addScore(leftScored)
  {
      if (leftScored) scoreL++;
      else scoreR++;

      sfxScore?.play();

      // win at 10
      if (scoreL >= 10 || scoreR >= 10)
      {
          gameOver = true;
          ball.vel = vec2(0,0);
          waitingForServe = true;
          return;
      }

      // Next serve goes toward the player who just conceded
      resetRound(leftScored ? false : true);
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////
  // LittleJS Callbacks

  function gameInit()
  {
      // fixed canvas for consistent feel
      setCanvasFixedSize(vec2(1280, 720));

      // camera centered; choose scale so field fits nicely
      setCameraPos(vec2(0, 0));
      cameraScale = 32;

      // Sounds (simple, punchy)
      sfxPaddle = new SoundGenerator({ volume:.7, frequency:520, release:.07, shapeCurve:1.8, randomness:.08 });
      sfxWall   = new SoundGenerator({ volume:.55, frequency:880, release:.06, shapeCurve:1.2, randomness:.04 });
      sfxServe  = new SoundGenerator({ volume:.55, frequency:320, release:.12, slide:.35, shapeCurve:1.6, randomness:.06 });
      sfxScore  = new SoundGenerator({ volume:1,  frequency:220, attack:0, release:.35, slide:-1.1, pitchJump:660, pitchJumpTime:.08, shapeCurve:1.3, randomness:.02 });

      resetRound(true);
  }

  function gameUpdate()
  {
      if (keyWasPressed('KeyR'))
      {
          scoreL = scoreR = 0;
          resetRound(true);
      }

      if (keyWasPressed('KeyT'))
          aiRight = !aiRight;

      if (keyWasPressed('Space'))
      {
          if (gameOver)
          {
              scoreL = scoreR = 0;
              resetRound(true);
          }
          serve();
      }

      // Paddle input
      left.pos.y += keyDirection().y * paddleSpeed * timeDelta;
      clampPaddleY(left);

      if (!aiRight)
      {
          right.pos.y += keyDirection().y * paddleSpeed * timeDelta;
      }
      else
      {
          // AI with prediction and imperfection
          if (waitingForServe || gameOver)
          {
              // Drift to center when waiting
              aiTargetY = 0;
          }
          else if (ball.vel.x > 0)
          {
              // Ball coming toward AI - predict intercept
              const now = time;
              if (now - aiLastUpdate > aiReactionDelay)
              {
                  aiLastUpdate = now;
                  aiPredictedY = predictBallY(right.pos.x);
                  // Add some error to make AI beatable
                  aiPredictedY += rand(-aiErrorMargin, aiErrorMargin);
                  aiPredictedY += ball.vel.y * aiPredictionNoise;
              }
              aiTargetY = aiPredictedY;
          }
          else
          {
              // Ball going away - return toward center
              aiTargetY = ball.pos.y * 0.3;
          }
          
          // Move toward target
          const diff = aiTargetY - right.pos.y;
          const dir = Math.sign(diff);
          const move = Math.min(Math.abs(diff), aiSpeed * timeDelta);
          right.pos.y += dir * move;
      }
      clampPaddleY(right);

      // Ball update
      if (waitingForServe || gameOver)
          return;

      ball.pos = ball.pos.add(ball.vel.scale(timeDelta));

      // Wall bounce
      const yLimit = halfField.y - ballSize.y/2;
      if (ball.pos.y > yLimit)
      {
          ball.pos.y = yLimit;
          ball.vel.y = -Math.abs(ball.vel.y);
          sfxWall?.play(ball.pos);
      }
      else if (ball.pos.y < -yLimit)
      {
          ball.pos.y = -yLimit;
          ball.vel.y = Math.abs(ball.vel.y);
          sfxWall?.play(ball.pos);
      }

      // Left paddle
      if (ball.vel.x < 0 && aabbOverlap(ball.pos, ballSize, left.pos, paddleSize))
      {
          ball.pos.x = left.pos.x + (paddleSize.x + ballSize.x) * .5;
          ball.vel.x = Math.abs(ball.vel.x);

          const offset = clamp((ball.pos.y - left.pos.y) / (paddleSize.y * .5), -1, 1);
          ball.vel.y += offset * 8;

          const speed = clamp(ball.vel.length() * 1.04, 14, maxBallSpeed);
          ball.vel = ball.vel.normalize(speed);
          sfxPaddle?.play(ball.pos);
      }

      // Right paddle
      if (ball.vel.x > 0 && aabbOverlap(ball.pos, ballSize, right.pos, paddleSize))
      {
          ball.pos.x = right.pos.x - (paddleSize.x + ballSize.x) * .5;
          ball.vel.x = -Math.abs(ball.vel.x);

          const offset = clamp((ball.pos.y - right.pos.y) / (paddleSize.y * .5), -1, 1);
          ball.vel.y += offset * 8;

          const speed = clamp(ball.vel.length() * 1.04, 14, maxBallSpeed);
          ball.vel = ball.vel.normalize(speed);
          sfxPaddle?.play(ball.pos);
      }

      // Scoring
      if (ball.pos.x < -halfField.x - 2)
          addScore(false);
      else if (ball.pos.x > halfField.x + 2)
          addScore(true);
  }

  function gameUpdatePost()
  {
      // keep camera stable
      setCameraPos(vec2(0,0));
  }

  function gameRender()
  {
      // background
      drawRect(cameraPos, vec2(200), rgb(.08,.08,.08));

      // playfield
      drawRect(cameraPos, fieldSize, rgb(.12,.12,.12));

      // center dashed line
      const dashCount = 18;
      for (let i=0; i<dashCount; i++)
      {
          const t = (i/(dashCount-1))*2 - 1;
          const y = t * (halfField.y - 1);
          drawRect(vec2(0, y), vec2(.35, .7), rgb(.85,.85,.85));
      }

      // paddles
      drawRect(left.pos, paddleSize, rgb(.95,.95,.95));
      drawRect(right.pos, paddleSize, rgb(.95,.95,.95));

      // ball
      drawRect(ball.pos, ballSize, rgb(1,1,1));

      // top/bottom border lines (subtle)
      drawRect(vec2(0, halfField.y + .15), vec2(fieldSize.x, .15), rgb(.2,.2,.2));
      drawRect(vec2(0,-halfField.y - .15), vec2(fieldSize.x, .15), rgb(.2,.2,.2));
  }

  function gameRenderPost()
  {
      // score
      const scoreText = `${scoreL}    ${scoreR}`;
      drawTextScreen(scoreText, vec2(mainCanvasSize.x/2, 60), 80, hsl(0,0,1), 6, hsl(0,0,0));

      // hints
      const lines = [];
      lines.push('Left: W/S');
      lines.push(aiRight ? 'Right: AI (press T to toggle)' : 'Right: ↑/↓ (press T for AI)');
      lines.push('Space: Serve / Start (enables sound)');
      lines.push('R: Reset');

      // status message
      if (gameOver)
      {
          const winner = scoreL > scoreR ? 'Left Wins!' : 'Right Wins!';
          lines.unshift(winner);
          lines.unshift('');
          lines.unshift('Game Over');
      }
      else if (waitingForServe)
      {
          lines.unshift('');
          lines.unshift('Press Space to Serve');
      }

      const x = mainCanvasSize.x/2;
      let y = mainCanvasSize.y - 120;
      for (const s of lines)
      {
          drawTextScreen(s, vec2(x, y), 26, hsl(0,0,1), 4, hsl(0,0,0));
          y += 28;
      }
  }

  // Startup LittleJS Engine
  engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);
  </script>
</body>
</html>
