<!DOCTYPE html><head>
<title>LittleJS Sokoban</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="../dist/littlejs.js?1.18.0"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;
setDebugKey('Backquote');

gravity = vec2(0, 0);
cameraPos = vec2(0, 0);
cameraScale = 32;

// AI can use this class to make sound effects
class SoundGenerator extends Sound
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;

        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0,
            pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// SOKOBAN GAME

// Tile types
const EMPTY = 0;
const WALL = 1;
const FLOOR = 2;
const TARGET = 3;
const BOX = 4;
const BOX_ON_TARGET = 5;
const PLAYER = 6;
const PLAYER_ON_TARGET = 7;

// Colors
const COLOR_WALL = rgb(.25, .2, .18);
const COLOR_FLOOR = rgb(.55, .48, .42);
const COLOR_TARGET = hsl(.0, .7, .5);
const COLOR_BOX = hsl(.08, .75, .5);
const COLOR_BOX_ON_TARGET = hsl(.33, .8, .45);
const COLOR_PLAYER = hsl(.58, .85, .55);
const COLOR_PLAYER_DARK = hsl(.58, .75, .35);

// Game state
let currentLevel = 0;
let moves = 0;
let pushes = 0;
let playerPos = vec2(0, 0);
let grid = [];
let gridWidth = 0;
let gridHeight = 0;
let undoStack = [];
let levelComplete = false;
let showingMessage = false;
let messageTimer = 0;

// Input timing
let moveTimer = 0;
const MOVE_DELAY = 0.12;

// Sounds
let sfxMove, sfxPush, sfxComplete, sfxUndo, sfxRestart;

// Debug solver state
let solverResults = null;  // Array of {level, solvable, moves, time} or null
let solverRunning = false;
let solverProgress = 0;

// Level definitions (standard Sokoban format)
// # = wall, . = target, $ = box, @ = player, * = box on target, + = player on target, space = floor
const LEVELS = [
    // Level 1 - Simple intro
    [
        "  #####",
        "###   #",
        "#.@$  #",
        "### $.#",
        "#.##$ #",
        "# # . ##",
        "#$ *$$.#",
        "#   .  #",
        "########"
    ],
    // Level 2
    [
        "######",
        "#    #",
        "# #@ #",
        "# $* #",
        "# .* #",
        "#    #",
        "######"
    ],
    // Level 3
    [
        "  ####",
        "###  ####",
        "#     $ #",
        "# #  #$ #",
        "# . .#@ #",
        "#########"
    ],
    // Level 4
    [
        "########",
        "#      #",
        "# .**$ #",
        "# .#   #",
        "# $  @##",
        "#  ####",
        "####"
    ],
    // Level 5
    [
        "  ######",
        "  #    #",
        "  # ##.#",
        "### # .#",
        "#  $  .#",
        "#   $# #",
        "## $   #",
        " #@  ###",
        " #####"
    ],
    // Level 6
    [
        "#######",
        "#     #",
        "# .$. #",
        "# $.$ #",
        "# .$. #",
        "# $.$ #",
        "#  @  #",
        "#######"
    ],
    // Level 7
    [
        "    #####",
        "    #   #",
        "    #$  #",
        "  ###  $##",
        "  #  $ $ #",
        "### # ## #   ######",
        "#   # ## #####  ..#",
        "# $  $          ..#",
        "##### ### #@##  ..#",
        "    #     #########",
        "    #######"
    ],
    // Level 8
    [
        "  ######",
        "  #    ##",
        " ## ##  #",
        " #  # $ #",
        "##$.#.$ #",
        "#  .@.  #",
        "# $#.#$##",
        "#  # #",
        "##   #",
        " #####"
    ],
    // Level 9
    [
        "  #####",
        " ##   ##",
        "##  $  ##",
        "# $$@$$ #",
        "# . # . #",
        "## ... ##",
        " ##   ##",
        "  #####"
    ],
    // Level 10
    [
        "###########",
        "#    #    #",
        "# $  #  $ #",
        "#   $#$   #",
        "###.....###",
        "  #  @  #",
        "###$#$#$###",
        "#    #    #",
        "# $  #  $ #",
        "#    #    #",
        "###########"
    ]
];

///////////////////////////////////////////////////////////////////////////////
// LEVEL SOLVER (Async BFS with chunking)
// Verifies that levels are solvable and finds minimum moves
// Processes in batches to avoid freezing the browser

let currentSolver = null;  // Active solver state

function createSolverState(levelData)
{
    // Parse level into initial state
    let width = 0;
    const height = levelData.length;
    for (const row of levelData)
        width = Math.max(width, row.length);
    
    // Build initial state
    let startPlayer = null;
    const startBoxes = new Set();
    const targets = new Set();
    const walls = new Set();
    
    for (let y = 0; y < height; y++)
    {
        const row = levelData[y];
        for (let x = 0; x < width; x++)
        {
            const char = x < row.length ? row[x] : ' ';
            const key = x + ',' + y;
            
            switch(char)
            {
                case '#': walls.add(key); break;
                case '.': targets.add(key); break;
                case '$': startBoxes.add(key); break;
                case '*': startBoxes.add(key); targets.add(key); break;
                case '@': startPlayer = {x, y}; break;
                case '+': startPlayer = {x, y}; targets.add(key); break;
            }
        }
    }
    
    if (!startPlayer || startBoxes.size === 0 || targets.size === 0)
        return { done: true, result: { solvable: false, moves: 0, reason: 'Invalid level', statesChecked: 0 } };
    
    if (startBoxes.size !== targets.size)
        return { done: true, result: { solvable: false, moves: 0, reason: 'Box/target mismatch', statesChecked: 0 } };
    
    // Simple state encoding: player position + sorted box positions
    function encodeState(px, py, boxes)
    {
        const sortedBoxes = Array.from(boxes).sort();
        return px + ',' + py + '|' + sortedBoxes.join(';');
    }
    
    const visited = new Set();
    const queue = [{px: startPlayer.x, py: startPlayer.y, boxes: startBoxes, moves: 0}];
    visited.add(encodeState(startPlayer.x, startPlayer.y, startBoxes));
    
    return {
        done: false,
        result: null,
        queue,
        visited,
        walls,
        targets,
        statesChecked: 0,
        maxStates: 1000000,
        encodeState,
        dirs: [[0, -1], [0, 1], [-1, 0], [1, 0]]
    };
}

// Process a batch of states, returns true if done
function solverProcessBatch(solver, batchSize = 5000)
{
    if (solver.done) return true;
    
    const { queue, visited, walls, targets, dirs, encodeState } = solver;
    
    // Check win condition
    function isWin(boxes)
    {
        for (const t of targets)
            if (!boxes.has(t)) return false;
        return true;
    }
    
    // Deadlock detection: box in corner not on target
    function isDeadlock(bx, by, boxes)
    {
        const key = bx + ',' + by;
        if (targets.has(key)) return false;
        
        const left = walls.has((bx-1) + ',' + by);
        const right = walls.has((bx+1) + ',' + by);
        const up = walls.has(bx + ',' + (by-1));
        const down = walls.has(bx + ',' + (by+1));
        
        if ((left || right) && (up || down))
            return true;
        
        return false;
    }
    
    let processed = 0;
    
    while (queue.length > 0 && processed < batchSize && solver.statesChecked < solver.maxStates)
    {
        const state = queue.shift();
        solver.statesChecked++;
        processed++;
        
        // Check win
        if (isWin(state.boxes))
        {
            solver.done = true;
            solver.result = { solvable: true, moves: state.moves, statesChecked: solver.statesChecked };
            return true;
        }
        
        // Try each direction
        for (const [dx, dy] of dirs)
        {
            const nx = state.px + dx;
            const ny = state.py + dy;
            const nkey = nx + ',' + ny;
            
            if (walls.has(nkey)) continue;
            
            let newBoxes = state.boxes;
            
            if (state.boxes.has(nkey))
            {
                const bx = nx + dx;
                const by = ny + dy;
                const bkey = bx + ',' + by;
                
                if (walls.has(bkey) || state.boxes.has(bkey)) continue;
                
                newBoxes = new Set(state.boxes);
                newBoxes.delete(nkey);
                newBoxes.add(bkey);
                
                if (isDeadlock(bx, by, newBoxes)) continue;
            }
            
            const encoded = encodeState(nx, ny, newBoxes);
            if (visited.has(encoded)) continue;
            visited.add(encoded);
            
            queue.push({px: nx, py: ny, boxes: newBoxes, moves: state.moves + 1});
        }
    }
    
    // Check if we're done
    if (queue.length === 0 || solver.statesChecked >= solver.maxStates)
    {
        solver.done = true;
        const reason = solver.statesChecked >= solver.maxStates ? 'Max states exceeded' : 'No solution';
        solver.result = { solvable: false, moves: 0, statesChecked: solver.statesChecked, reason };
        return true;
    }
    
    return false;
}

// State for async verification
let verifyLevelIndex = 0;
let verifyStartTime = 0;

function verifyAllLevels()
{
    solverResults = [];
    solverRunning = true;
    solverProgress = 0;
    verifyLevelIndex = 0;
    currentSolver = null;
    
    console.log('=== SOKOBAN LEVEL VERIFICATION ===' );
    console.log('Verifying ' + LEVELS.length + ' levels...');
}

// Called each frame to process solver work
function updateSolver()
{
    if (!solverRunning) return;
    
    // Start solving next level if needed
    if (!currentSolver)
    {
        if (verifyLevelIndex >= LEVELS.length)
        {
            // All done!
            solverRunning = false;
            console.log('=== VERIFICATION COMPLETE ===' );
            
            let allSolvable = true;
            for (const r of solverResults)
                if (!r.solvable) allSolvable = false;
            
            console.log(allSolvable ? 'All levels are SOLVABLE!' : 'Some levels may have issues.');
            return;
        }
        
        solverProgress = verifyLevelIndex;
        verifyStartTime = performance.now();
        currentSolver = createSolverState(LEVELS[verifyLevelIndex]);
    }
    
    // Process a batch
    const done = solverProcessBatch(currentSolver, 3000);
    
    if (done)
    {
        const elapsed = performance.now() - verifyStartTime;
        const result = currentSolver.result;
        
        solverResults.push({
            level: verifyLevelIndex + 1,
            solvable: result.solvable,
            moves: result.moves,
            time: elapsed.toFixed(1),
            states: result.statesChecked || 0,
            reason: result.reason || ''
        });
        
        const status = result.solvable 
            ? `SOLVABLE (${result.moves} moves, ${result.statesChecked} states, ${elapsed.toFixed(1)}ms)`
            : `UNSOLVABLE - ${result.reason} (${result.statesChecked} states, ${elapsed.toFixed(1)}ms)`;
        console.log(`Level ${verifyLevelIndex + 1}: ${status}`);
        
        // Stop immediately if level is not solvable
        if (!result.solvable)
        {
            solverRunning = false;
            currentSolver = null;
            console.log('=== VERIFICATION STOPPED - UNSOLVABLE LEVEL FOUND ===');
            return;
        }
        
        verifyLevelIndex++;
        currentSolver = null;
    }
}

///////////////////////////////////////////////////////////////////////////////
// Parse a level string into grid
function parseLevel(levelData)
{
    grid = [];
    gridWidth = 0;
    gridHeight = levelData.length;
    
    // Find max width
    for (const row of levelData)
        gridWidth = max(gridWidth, row.length);
    
    // Parse grid
    for (let y = 0; y < gridHeight; y++)
    {
        const row = levelData[gridHeight - 1 - y]; // Flip Y for LittleJS coords
        const gridRow = [];
        
        for (let x = 0; x < gridWidth; x++)
        {
            const char = x < row.length ? row[x] : ' ';
            let tile = EMPTY;
            
            switch(char)
            {
                case '#': tile = WALL; break;
                case ' ': tile = FLOOR; break;
                case '.': tile = TARGET; break;
                case '$': tile = BOX; break;
                case '*': tile = BOX_ON_TARGET; break;
                case '@': 
                    tile = FLOOR; 
                    playerPos = vec2(x, y);
                    break;
                case '+':
                    tile = TARGET;
                    playerPos = vec2(x, y);
                    break;
            }
            
            gridRow.push(tile);
        }
        grid.push(gridRow);
    }
}

function loadLevel(levelIndex)
{
    currentLevel = levelIndex % LEVELS.length;
    parseLevel(LEVELS[currentLevel]);
    moves = 0;
    pushes = 0;
    undoStack = [];
    levelComplete = false;
    showingMessage = false;
    
    // Center camera on level
    cameraPos = vec2(gridWidth / 2 - 0.5, gridHeight / 2 - 0.5);
}

function getTile(x, y)
{
    if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight)
        return WALL;
    return grid[y][x];
}

function setTile(x, y, tile)
{
    if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight)
        grid[y][x] = tile;
}

function isWalkable(tile)
{
    return tile === FLOOR || tile === TARGET;
}

function hasBox(tile)
{
    return tile === BOX || tile === BOX_ON_TARGET;
}

function saveState()
{
    const state = {
        playerPos: playerPos.copy(),
        grid: grid.map(row => row.slice()),
        moves: moves,
        pushes: pushes
    };
    undoStack.push(state);
    
    // Limit undo stack size
    if (undoStack.length > 1000)
        undoStack.shift();
}

function undo()
{
    if (undoStack.length === 0 || levelComplete)
        return false;
    
    const state = undoStack.pop();
    playerPos = state.playerPos;
    grid = state.grid;
    moves = state.moves;
    pushes = state.pushes;
    
    sfxUndo && sfxUndo.play();
    return true;
}

function tryMove(dx, dy)
{
    if (levelComplete)
        return false;
    
    const newX = playerPos.x + dx;
    const newY = playerPos.y + dy;
    const tile = getTile(newX, newY);
    
    // Can't walk into walls
    if (tile === WALL || tile === EMPTY)
        return false;
    
    // Check if there's a box to push
    if (hasBox(tile))
    {
        const pushX = newX + dx;
        const pushY = newY + dy;
        const pushTile = getTile(pushX, pushY);
        
        // Can only push into empty floor or target
        if (!isWalkable(pushTile))
            return false;
        
        // Save state for undo
        saveState();
        
        // Move the box
        const wasOnTarget = tile === BOX_ON_TARGET;
        const pushingOntoTarget = pushTile === TARGET;
        
        // Clear old box position
        setTile(newX, newY, wasOnTarget ? TARGET : FLOOR);
        
        // Place box in new position
        setTile(pushX, pushY, pushingOntoTarget ? BOX_ON_TARGET : BOX);
        
        // Move player
        playerPos = vec2(newX, newY);
        moves++;
        pushes++;
        
        sfxPush && sfxPush.play();
        
        // Check win condition
        checkWin();
        return true;
    }
    
    // Walking onto empty floor or target
    if (isWalkable(tile))
    {
        saveState();
        playerPos = vec2(newX, newY);
        moves++;
        sfxMove && sfxMove.play();
        return true;
    }
    
    return false;
}

function checkWin()
{
    // Check if all boxes are on targets
    for (let y = 0; y < gridHeight; y++)
    {
        for (let x = 0; x < gridWidth; x++)
        {
            if (grid[y][x] === BOX)
                return; // Found a box not on target
        }
    }
    
    // All boxes are on targets!
    levelComplete = true;
    showingMessage = true;
    messageTimer = 0;
    sfxComplete && sfxComplete.play();
}

function nextLevel()
{
    loadLevel(currentLevel + 1);
}

function drawTile3D(pos, size, baseColor, isRaised = false)
{
    const hi = baseColor.lerp(rgb(1,1,1), .2);
    const sh = baseColor.lerp(rgb(0,0,0), .25);
    
    if (isRaised)
    {
        // Draw shadow
        drawRect(pos.add(vec2(.08, -.08)), vec2(size), rgb(0,0,0,.3));
        
        // Draw raised block
        const depth = .15;
        drawRect(pos.add(vec2(0, -depth/2)), vec2(size, size - depth), sh);
        drawRect(pos.add(vec2(0, depth)), vec2(size), baseColor);
        
        // Highlight on top
        drawRect(pos.add(vec2(0, depth + size/4)), vec2(size * .9, size * .3), hi);
    }
    else
    {
        drawRect(pos, vec2(size), baseColor);
    }
}

function drawBox(pos, onTarget)
{
    const color = onTarget ? COLOR_BOX_ON_TARGET : COLOR_BOX;
    const size = .85;
    
    // Shadow
    drawRect(pos.add(vec2(.1, -.1)), vec2(size), rgb(0,0,0,.35));
    
    // Main box body
    drawRect(pos, vec2(size), color);
    
    // 3D effect - lighter top edge
    drawRect(pos.add(vec2(0, size/3)), vec2(size * .85, size * .2), color.lerp(rgb(1,1,1), .25));
    
    // Darker bottom edge
    drawRect(pos.add(vec2(0, -size/3)), vec2(size * .85, size * .15), color.lerp(rgb(0,0,0), .2));
    
    // Inner cross pattern
    const lineColor = color.lerp(rgb(0,0,0), .15);
    drawRect(pos, vec2(size * .6, size * .12), lineColor);
    drawRect(pos, vec2(size * .12, size * .6), lineColor);
    
    // Checkmark if on target
    if (onTarget)
    {
        drawRect(pos, vec2(size * .3), rgb(1,1,1,.5));
    }
}

function drawPlayer(pos)
{
    const size = .75;
    const bobOffset = Math.sin(time * 4) * .03;
    const drawPos = pos.add(vec2(0, bobOffset));
    
    // Shadow
    drawCircle(pos.add(vec2(.05, -.12)), size * .85, rgb(0,0,0,.3));
    
    // Body
    drawCircle(drawPos, size, COLOR_PLAYER);
    
    // Inner highlight
    drawCircle(drawPos.add(vec2(-.1, .15)), size * .4, COLOR_PLAYER.lerp(rgb(1,1,1), .35));
    
    // Face - eyes
    const eyeOffset = .15;
    const eyeSize = .12;
    drawCircle(drawPos.add(vec2(-eyeOffset, .1)), eyeSize, rgb(1,1,1));
    drawCircle(drawPos.add(vec2(eyeOffset, .1)), eyeSize, rgb(1,1,1));
    drawCircle(drawPos.add(vec2(-eyeOffset, .08)), eyeSize * .5, rgb(.1,.1,.2));
    drawCircle(drawPos.add(vec2(eyeOffset, .08)), eyeSize * .5, rgb(.1,.1,.2));
    
    // Smile
    drawRect(drawPos.add(vec2(0, -.12)), vec2(.22, .06), rgb(.1,.1,.2));
}

function drawTarget(pos)
{
    // Glowing target indicator
    const pulse = .5 + Math.sin(time * 3) * .15;
    
    // Outer glow
    drawCircle(pos, .5, COLOR_TARGET.lerp(rgb(1,1,1), .2).scale(1, pulse * .4));
    
    // Inner circle
    drawCircle(pos, .35, COLOR_TARGET.scale(1, pulse * .6));
    
    // Center dot
    drawCircle(pos, .15, COLOR_TARGET);
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    setCanvasFixedSize(vec2(960, 720));
    
    // Initialize sounds
    sfxMove = new SoundGenerator({ frequency: 280, release: .04, volume: .3 });
    sfxPush = new SoundGenerator({ frequency: 180, release: .08, volume: .5, noise: .05 });
    sfxComplete = new SoundGenerator({ frequency: 520, release: .3, slide: .5, pitchJump: 200, pitchJumpTime: .1, volume: .6 });
    sfxUndo = new SoundGenerator({ frequency: 350, release: .06, slide: -.5, volume: .3 });
    sfxRestart = new SoundGenerator({ frequency: 200, release: .1, volume: .4 });
    
    loadLevel(0);
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    // Update async solver (processes in chunks to avoid freezing)
    updateSolver();
    
    // Handle level complete state
    if (levelComplete)
    {
        messageTimer += timeDelta;
        
        if (messageTimer > 1.0 && (mouseWasPressed(0) || keyWasPressed('Space') || keyWasPressed('Enter')))
        {
            nextLevel();
        }
        return;
    }
    
    // Restart level
    if (keyWasPressed('KeyR'))
    {
        loadLevel(currentLevel);
        sfxRestart && sfxRestart.play();
    }
    
    // Undo
    if (keyWasPressed('KeyZ') || keyWasPressed('KeyU') || keyWasPressed('Backspace'))
    {
        undo();
    }
    
    // Level skip (for testing)
    if (keyWasPressed('KeyN'))
        nextLevel();
    if (keyWasPressed('KeyP'))
        loadLevel(max(0, currentLevel - 1));
    
    // Debug: Verify all levels (V key)
    if (keyWasPressed('KeyV') && !solverRunning)
    {
        verifyAllLevels();
    }
    
    // Clear solver results (C key)
    if (keyWasPressed('KeyC') && solverResults && !solverRunning)
    {
        solverResults = null;
    }
    
    // Movement with timing
    moveTimer -= timeDelta;
    
    let dx = 0, dy = 0;
    
    if (keyWasPressed('ArrowUp') || keyWasPressed('KeyW'))
        dy = 1;
    else if (keyWasPressed('ArrowDown') || keyWasPressed('KeyS'))
        dy = -1;
    else if (keyWasPressed('ArrowLeft') || keyWasPressed('KeyA'))
        dx = -1;
    else if (keyWasPressed('ArrowRight') || keyWasPressed('KeyD'))
        dx = 1;
    
    // Also allow held keys with delay
    if (dx === 0 && dy === 0 && moveTimer <= 0)
    {
        if (keyIsDown('ArrowUp') || keyIsDown('KeyW'))
            dy = 1;
        else if (keyIsDown('ArrowDown') || keyIsDown('KeyS'))
            dy = -1;
        else if (keyIsDown('ArrowLeft') || keyIsDown('KeyA'))
            dx = -1;
        else if (keyIsDown('ArrowRight') || keyIsDown('KeyD'))
            dx = 1;
    }
    
    if (dx !== 0 || dy !== 0)
    {
        if (tryMove(dx, dy))
            moveTimer = MOVE_DELAY;
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // Adjust camera scale based on level size
    const padding = 3;
    const scaleX = mainCanvasSize.x / (gridWidth + padding);
    const scaleY = mainCanvasSize.y / (gridHeight + padding + 2);
    cameraScale = min(scaleX, scaleY);
    cameraScale = clamp(cameraScale, 24, 48);
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // Background
    drawRect(cameraPos, vec2(50), rgb(.12, .1, .08));
    
    // Draw grid
    for (let y = 0; y < gridHeight; y++)
    {
        for (let x = 0; x < gridWidth; x++)
        {
            const pos = vec2(x, y);
            const tile = grid[y][x];
            
            // Draw floor for all non-empty tiles
            if (tile !== EMPTY && tile !== WALL)
            {
                drawRect(pos, vec2(.98), COLOR_FLOOR);
                
                // Floor texture
                drawRect(pos.add(vec2(-.3, -.3)), vec2(.08), COLOR_FLOOR.lerp(rgb(0,0,0), .1));
                drawRect(pos.add(vec2(.25, .2)), vec2(.06), COLOR_FLOOR.lerp(rgb(0,0,0), .1));
            }
            
            // Draw walls
            if (tile === WALL)
            {
                // Shadow
                drawRect(pos.add(vec2(.08, -.08)), vec2(.98), rgb(0,0,0,.4));
                
                // Wall block
                drawRect(pos, vec2(.98), COLOR_WALL);
                
                // Brick pattern
                const brickHi = COLOR_WALL.lerp(rgb(1,1,1), .1);
                const brickSh = COLOR_WALL.lerp(rgb(0,0,0), .15);
                
                // Top edge highlight
                drawRect(pos.add(vec2(0, .4)), vec2(.9, .1), brickHi);
                
                // Bottom edge shadow
                drawRect(pos.add(vec2(0, -.4)), vec2(.9, .1), brickSh);
                
                // Horizontal mortar lines
                drawRect(pos.add(vec2(0, .15)), vec2(.95, .03), brickSh);
                drawRect(pos.add(vec2(0, -.2)), vec2(.95, .03), brickSh);
            }
            
            // Draw targets
            if (tile === TARGET)
            {
                drawTarget(pos);
            }
            
            // Draw boxes
            if (tile === BOX)
            {
                drawBox(pos, false);
            }
            else if (tile === BOX_ON_TARGET)
            {
                drawTarget(pos); // Show target underneath
                drawBox(pos, true);
            }
        }
    }
    
    // Draw player
    drawPlayer(playerPos);
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    // UI - Level info
    const levelText = `Level ${currentLevel + 1}/${LEVELS.length}`;
    drawTextScreen(levelText, vec2(20, 24), 28, rgb(1,1,1), 4, rgb(0,0,0), 'left');
    
    // Moves and pushes
    const statsText = `Moves: ${moves}  Pushes: ${pushes}`;
    drawTextScreen(statsText, vec2(mainCanvasSize.x - 20, 24), 22, rgb(.9,.9,.9), 3, rgb(0,0,0), 'right');
    
    // Controls hint
    const controlsText = 'Arrows/WASD: Move | Z/U: Undo | R: Restart | N/P: Skip | V: Verify All';
    drawTextScreen(controlsText, vec2(mainCanvasSize.x / 2, mainCanvasSize.y - 20), 18, rgb(.7,.7,.7), 2, rgb(0,0,0));
    
    // Solver results overlay
    if (solverRunning)
    {
        drawRect(cameraPos, vec2(100), rgb(0,0,0,.7));
        drawTextScreen('VERIFYING LEVELS...', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 - 50), 36, hsl(.14, .8, .6), 4, rgb(0,0,0));
        drawTextScreen(`Level ${solverProgress + 1} / ${LEVELS.length}`, vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2), 28, rgb(1,1,1), 3, rgb(0,0,0));
        
        // Show current solver progress
        if (currentSolver && !currentSolver.done)
        {
            const stateInfo = `States checked: ${currentSolver.statesChecked.toLocaleString()}`;
            drawTextScreen(stateInfo, vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 40), 22, rgb(.8,.8,.8), 2, rgb(0,0,0));
        }
    }
    else if (solverResults)
    {
        // Draw results panel
        drawRect(cameraPos, vec2(100), rgb(0,0,0,.85));
        
        drawTextScreen('LEVEL VERIFICATION RESULTS', vec2(mainCanvasSize.x / 2, 40), 32, hsl(.58, .8, .6), 4, rgb(0,0,0));
        drawTextScreen('Press C to close', vec2(mainCanvasSize.x / 2, 70), 18, rgb(.7,.7,.7), 2, rgb(0,0,0));
        
        let allSolvable = true;
        let yPos = 110;
        
        for (const r of solverResults)
        {
            if (!r.solvable) allSolvable = false;
            
            const color = r.solvable ? hsl(.33, .7, .55) : hsl(0, .8, .55);
            const status = r.solvable 
                ? `Level ${r.level}: SOLVABLE - ${r.moves} moves (${r.states} states, ${r.time}ms)`
                : `Level ${r.level}: FAILED - ${r.reason} (${r.states} states)`;
            
            drawTextScreen(status, vec2(mainCanvasSize.x / 2, yPos), 22, color, 2, rgb(0,0,0));
            yPos += 28;
        }
        
        const summaryColor = allSolvable ? hsl(.33, .9, .6) : hsl(0, .9, .6);
        const summaryText = allSolvable ? 'ALL LEVELS VERIFIED SOLVABLE!' : 'SOME LEVELS HAVE ISSUES';
        drawTextScreen(summaryText, vec2(mainCanvasSize.x / 2, yPos + 20), 28, summaryColor, 4, rgb(0,0,0));
    }
    
    // Level complete message
    if (levelComplete)
    {
        // Darken background
        drawRect(cameraPos, vec2(100), rgb(0,0,0,.5));
        
        // Victory message
        const isLastLevel = currentLevel >= LEVELS.length - 1;
        
        if (isLastLevel)
        {
            drawTextScreen('CONGRATULATIONS!', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 - 40), 52, hsl(.14, .9, .6), 6, rgb(0,0,0));
            drawTextScreen('You completed all levels!', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 20), 32, rgb(1,1,1), 4, rgb(0,0,0));
        }
        else
        {
            drawTextScreen('LEVEL COMPLETE!', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 - 30), 48, hsl(.33, .8, .55), 6, rgb(0,0,0));
            drawTextScreen(`Moves: ${moves}  Pushes: ${pushes}`, vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 20), 28, rgb(1,1,1), 4, rgb(0,0,0));
        }
        
        if (messageTimer > 1.0)
        {
            const blink = Math.sin(time * 5) > 0;
            if (blink)
            {
                const nextText = isLastLevel ? 'Click or Space to play again' : 'Click or Space for next level';
                drawTextScreen(nextText, vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 70), 24, rgb(.9,.9,.6), 3, rgb(0,0,0));
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body></html>
