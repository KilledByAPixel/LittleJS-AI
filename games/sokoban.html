<!DOCTYPE html><head>
<title>LittleJS Sokoban</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/littlejs.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;
setDebugKey('Backquote');

gravity = vec2(0, 0);
cameraPos = vec2(0, 0);
cameraScale = 32;

// AI can use this class to make sound effects
class SoundGenerator extends Sound
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;

        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0,
            pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// SOKOBAN GAME

// Tile types
const EMPTY = 0;
const WALL = 1;
const FLOOR = 2;
const TARGET = 3;
const BOX = 4;
const BOX_ON_TARGET = 5;
const PLAYER = 6;
const PLAYER_ON_TARGET = 7;

// Colors
const COLOR_WALL = rgb(.25, .2, .18);
const COLOR_FLOOR = rgb(.55, .48, .42);
const COLOR_TARGET = hsl(.0, .7, .5);
const COLOR_BOX = hsl(.08, .75, .5);
const COLOR_BOX_ON_TARGET = hsl(.33, .8, .45);
const COLOR_PLAYER = hsl(.58, .85, .55);
const COLOR_PLAYER_DARK = hsl(.58, .75, .35);

// Game state
let currentLevel = 0;
let moves = 0;
let pushes = 0;
let playerPos = vec2(0, 0);
let grid = [];
let gridWidth = 0;
let gridHeight = 0;
let undoStack = [];
let levelComplete = false;
let showingMessage = false;
let messageTimer = 0;

// Input timing
let moveTimer = 0;
const MOVE_DELAY = 0.12;

// Sounds
let sfxMove, sfxPush, sfxComplete, sfxUndo, sfxRestart;

// Level definitions (standard Sokoban format)
// # = wall, . = target, $ = box, @ = player, * = box on target, + = player on target, space = floor
const LEVELS = [
    // Level 1 - Simple intro
    [
        "  #####",
        "###   #",
        "#.@$  #",
        "### $.#",
        "#.##$ #",
        "# # . ##",
        "#$ *$$.#",
        "#   .  #",
        "########"
    ],
    // Level 2
    [
        "######",
        "#    #",
        "# #@ #",
        "# $* #",
        "# .* #",
        "#    #",
        "######"
    ],
    // Level 3
    [
        "  ####",
        "###  ####",
        "#     $ #",
        "# #  #$ #",
        "# . .#@ #",
        "#########"
    ],
    // Level 4
    [
        "########",
        "#      #",
        "# .**$ #",
        "# .#   #",
        "# $  @##",
        "#  ####",
        "####"
    ],
    // Level 5
    [
        "  ######",
        "  #    #",
        "  # ##.#",
        "### # .#",
        "#  $  .#",
        "#   $# #",
        "## $   #",
        " #@  ###",
        " #####"
    ],
    // Level 6
    [
        "#######",
        "#     #",
        "# .$. #",
        "# $.$ #",
        "# .$. #",
        "# $.$ #",
        "#  @  #",
        "#######"
    ],
    // Level 7
    [
        "    #####",
        "    #   #",
        "    #$  #",
        "  ###  $##",
        "  #  $ $ #",
        "### # ## #   ######",
        "#   # ## #####  ..#",
        "# $  $          ..#",
        "##### ### #@##  ..#",
        "    #     #########",
        "    #######"
    ],
    // Level 8
    [
        "  ######",
        "  #    ##",
        " ## ##  #",
        " #  # $ #",
        "##$.#.$ #",
        "#  .@.  #",
        "# $#.#$##",
        "#  # #",
        "##   #",
        " #####"
    ],
    // Level 9
    [
        "  #####",
        " ##   ##",
        "##  $  ##",
        "# $$@$$ #",
        "# . # . #",
        "## ... ##",
        " ##   ##",
        "  #####"
    ],
    // Level 10
    [
        "###########",
        "#    #    #",
        "# $  #  $ #",
        "#   $#$   #",
        "###.....###",
        "  #  @  #",
        "###$#$#$###",
        "#    #    #",
        "# $  #  $ #",
        "#    #    #",
        "###########"
    ]
];

// Parse a level string into grid
function parseLevel(levelData)
{
    grid = [];
    gridWidth = 0;
    gridHeight = levelData.length;
    
    // Find max width
    for (const row of levelData)
        gridWidth = max(gridWidth, row.length);
    
    // Parse grid
    for (let y = 0; y < gridHeight; y++)
    {
        const row = levelData[gridHeight - 1 - y]; // Flip Y for LittleJS coords
        const gridRow = [];
        
        for (let x = 0; x < gridWidth; x++)
        {
            const char = x < row.length ? row[x] : ' ';
            let tile = EMPTY;
            
            switch(char)
            {
                case '#': tile = WALL; break;
                case ' ': tile = FLOOR; break;
                case '.': tile = TARGET; break;
                case '$': tile = BOX; break;
                case '*': tile = BOX_ON_TARGET; break;
                case '@': 
                    tile = FLOOR; 
                    playerPos = vec2(x, y);
                    break;
                case '+':
                    tile = TARGET;
                    playerPos = vec2(x, y);
                    break;
            }
            
            gridRow.push(tile);
        }
        grid.push(gridRow);
    }
}

function loadLevel(levelIndex)
{
    currentLevel = levelIndex % LEVELS.length;
    parseLevel(LEVELS[currentLevel]);
    moves = 0;
    pushes = 0;
    undoStack = [];
    levelComplete = false;
    showingMessage = false;
    
    // Center camera on level
    cameraPos = vec2(gridWidth / 2 - 0.5, gridHeight / 2 - 0.5);
}

function getTile(x, y)
{
    if (x < 0 || x >= gridWidth || y < 0 || y >= gridHeight)
        return WALL;
    return grid[y][x];
}

function setTile(x, y, tile)
{
    if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight)
        grid[y][x] = tile;
}

function isWalkable(tile)
{
    return tile === FLOOR || tile === TARGET;
}

function hasBox(tile)
{
    return tile === BOX || tile === BOX_ON_TARGET;
}

function saveState()
{
    const state = {
        playerPos: playerPos.copy(),
        grid: grid.map(row => row.slice()),
        moves: moves,
        pushes: pushes
    };
    undoStack.push(state);
    
    // Limit undo stack size
    if (undoStack.length > 1000)
        undoStack.shift();
}

function undo()
{
    if (undoStack.length === 0 || levelComplete)
        return false;
    
    const state = undoStack.pop();
    playerPos = state.playerPos;
    grid = state.grid;
    moves = state.moves;
    pushes = state.pushes;
    
    sfxUndo && sfxUndo.play();
    return true;
}

function tryMove(dx, dy)
{
    if (levelComplete)
        return false;
    
    const newX = playerPos.x + dx;
    const newY = playerPos.y + dy;
    const tile = getTile(newX, newY);
    
    // Can't walk into walls
    if (tile === WALL || tile === EMPTY)
        return false;
    
    // Check if there's a box to push
    if (hasBox(tile))
    {
        const pushX = newX + dx;
        const pushY = newY + dy;
        const pushTile = getTile(pushX, pushY);
        
        // Can only push into empty floor or target
        if (!isWalkable(pushTile))
            return false;
        
        // Save state for undo
        saveState();
        
        // Move the box
        const wasOnTarget = tile === BOX_ON_TARGET;
        const pushingOntoTarget = pushTile === TARGET;
        
        // Clear old box position
        setTile(newX, newY, wasOnTarget ? TARGET : FLOOR);
        
        // Place box in new position
        setTile(pushX, pushY, pushingOntoTarget ? BOX_ON_TARGET : BOX);
        
        // Move player
        playerPos = vec2(newX, newY);
        moves++;
        pushes++;
        
        sfxPush && sfxPush.play();
        
        // Check win condition
        checkWin();
        return true;
    }
    
    // Walking onto empty floor or target
    if (isWalkable(tile))
    {
        saveState();
        playerPos = vec2(newX, newY);
        moves++;
        sfxMove && sfxMove.play();
        return true;
    }
    
    return false;
}

function checkWin()
{
    // Check if all boxes are on targets
    for (let y = 0; y < gridHeight; y++)
    {
        for (let x = 0; x < gridWidth; x++)
        {
            if (grid[y][x] === BOX)
                return; // Found a box not on target
        }
    }
    
    // All boxes are on targets!
    levelComplete = true;
    showingMessage = true;
    messageTimer = 0;
    sfxComplete && sfxComplete.play();
}

function nextLevel()
{
    loadLevel(currentLevel + 1);
}

function drawTile3D(pos, size, baseColor, isRaised = false)
{
    const hi = baseColor.lerp(rgb(1,1,1), .2);
    const sh = baseColor.lerp(rgb(0,0,0), .25);
    
    if (isRaised)
    {
        // Draw shadow
        drawRect(pos.add(vec2(.08, -.08)), vec2(size), rgb(0,0,0,.3));
        
        // Draw raised block
        const depth = .15;
        drawRect(pos.add(vec2(0, -depth/2)), vec2(size, size - depth), sh);
        drawRect(pos.add(vec2(0, depth)), vec2(size), baseColor);
        
        // Highlight on top
        drawRect(pos.add(vec2(0, depth + size/4)), vec2(size * .9, size * .3), hi);
    }
    else
    {
        drawRect(pos, vec2(size), baseColor);
    }
}

function drawBox(pos, onTarget)
{
    const color = onTarget ? COLOR_BOX_ON_TARGET : COLOR_BOX;
    const size = .85;
    
    // Shadow
    drawRect(pos.add(vec2(.1, -.1)), vec2(size), rgb(0,0,0,.35));
    
    // Main box body
    drawRect(pos, vec2(size), color);
    
    // 3D effect - lighter top edge
    drawRect(pos.add(vec2(0, size/3)), vec2(size * .85, size * .2), color.lerp(rgb(1,1,1), .25));
    
    // Darker bottom edge
    drawRect(pos.add(vec2(0, -size/3)), vec2(size * .85, size * .15), color.lerp(rgb(0,0,0), .2));
    
    // Inner cross pattern
    const lineColor = color.lerp(rgb(0,0,0), .15);
    drawRect(pos, vec2(size * .6, size * .12), lineColor);
    drawRect(pos, vec2(size * .12, size * .6), lineColor);
    
    // Checkmark if on target
    if (onTarget)
    {
        drawRect(pos, vec2(size * .3), rgb(1,1,1,.5));
    }
}

function drawPlayer(pos)
{
    const size = .75;
    const bobOffset = Math.sin(time * 4) * .03;
    const drawPos = pos.add(vec2(0, bobOffset));
    
    // Shadow
    drawCircle(pos.add(vec2(.05, -.12)), size * .85, rgb(0,0,0,.3));
    
    // Body
    drawCircle(drawPos, size, COLOR_PLAYER);
    
    // Inner highlight
    drawCircle(drawPos.add(vec2(-.1, .15)), size * .4, COLOR_PLAYER.lerp(rgb(1,1,1), .35));
    
    // Face - eyes
    const eyeOffset = .15;
    const eyeSize = .12;
    drawCircle(drawPos.add(vec2(-eyeOffset, .1)), eyeSize, rgb(1,1,1));
    drawCircle(drawPos.add(vec2(eyeOffset, .1)), eyeSize, rgb(1,1,1));
    drawCircle(drawPos.add(vec2(-eyeOffset, .08)), eyeSize * .5, rgb(.1,.1,.2));
    drawCircle(drawPos.add(vec2(eyeOffset, .08)), eyeSize * .5, rgb(.1,.1,.2));
    
    // Smile
    drawRect(drawPos.add(vec2(0, -.12)), vec2(.22, .06), rgb(.1,.1,.2));
}

function drawTarget(pos)
{
    // Glowing target indicator
    const pulse = .5 + Math.sin(time * 3) * .15;
    
    // Outer glow
    drawCircle(pos, .5, COLOR_TARGET.lerp(rgb(1,1,1), .2).scale(1, pulse * .4));
    
    // Inner circle
    drawCircle(pos, .35, COLOR_TARGET.scale(1, pulse * .6));
    
    // Center dot
    drawCircle(pos, .15, COLOR_TARGET);
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    setCanvasFixedSize(vec2(960, 720));
    
    // Initialize sounds
    sfxMove = new SoundGenerator({ frequency: 280, release: .04, volume: .3 });
    sfxPush = new SoundGenerator({ frequency: 180, release: .08, volume: .5, noise: .05 });
    sfxComplete = new SoundGenerator({ frequency: 520, release: .3, slide: .5, pitchJump: 200, pitchJumpTime: .1, volume: .6 });
    sfxUndo = new SoundGenerator({ frequency: 350, release: .06, slide: -.5, volume: .3 });
    sfxRestart = new SoundGenerator({ frequency: 200, release: .1, volume: .4 });
    
    loadLevel(0);
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    // Handle level complete state
    if (levelComplete)
    {
        messageTimer += timeDelta;
        
        if (messageTimer > 1.0 && (mouseWasPressed(0) || keyWasPressed('Space') || keyWasPressed('Enter')))
        {
            nextLevel();
        }
        return;
    }
    
    // Restart level
    if (keyWasPressed('KeyR'))
    {
        loadLevel(currentLevel);
        sfxRestart && sfxRestart.play();
    }
    
    // Undo
    if (keyWasPressed('KeyZ') || keyWasPressed('KeyU') || keyWasPressed('Backspace'))
    {
        undo();
    }
    
    // Level skip (for testing)
    if (keyWasPressed('KeyN'))
        nextLevel();
    if (keyWasPressed('KeyP'))
        loadLevel(max(0, currentLevel - 1));
    
    // Movement with timing
    moveTimer -= timeDelta;
    
    let dx = 0, dy = 0;
    
    if (keyWasPressed('ArrowUp') || keyWasPressed('KeyW'))
        dy = 1;
    else if (keyWasPressed('ArrowDown') || keyWasPressed('KeyS'))
        dy = -1;
    else if (keyWasPressed('ArrowLeft') || keyWasPressed('KeyA'))
        dx = -1;
    else if (keyWasPressed('ArrowRight') || keyWasPressed('KeyD'))
        dx = 1;
    
    // Also allow held keys with delay
    if (dx === 0 && dy === 0 && moveTimer <= 0)
    {
        if (keyIsDown('ArrowUp') || keyIsDown('KeyW'))
            dy = 1;
        else if (keyIsDown('ArrowDown') || keyIsDown('KeyS'))
            dy = -1;
        else if (keyIsDown('ArrowLeft') || keyIsDown('KeyA'))
            dx = -1;
        else if (keyIsDown('ArrowRight') || keyIsDown('KeyD'))
            dx = 1;
    }
    
    if (dx !== 0 || dy !== 0)
    {
        if (tryMove(dx, dy))
            moveTimer = MOVE_DELAY;
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // Adjust camera scale based on level size
    const padding = 3;
    const scaleX = mainCanvasSize.x / (gridWidth + padding);
    const scaleY = mainCanvasSize.y / (gridHeight + padding + 2);
    cameraScale = min(scaleX, scaleY);
    cameraScale = clamp(cameraScale, 24, 48);
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // Background
    drawRect(cameraPos, vec2(50), rgb(.12, .1, .08));
    
    // Draw grid
    for (let y = 0; y < gridHeight; y++)
    {
        for (let x = 0; x < gridWidth; x++)
        {
            const pos = vec2(x, y);
            const tile = grid[y][x];
            
            // Draw floor for all non-empty tiles
            if (tile !== EMPTY && tile !== WALL)
            {
                drawRect(pos, vec2(.98), COLOR_FLOOR);
                
                // Floor texture
                drawRect(pos.add(vec2(-.3, -.3)), vec2(.08), COLOR_FLOOR.lerp(rgb(0,0,0), .1));
                drawRect(pos.add(vec2(.25, .2)), vec2(.06), COLOR_FLOOR.lerp(rgb(0,0,0), .1));
            }
            
            // Draw walls
            if (tile === WALL)
            {
                // Shadow
                drawRect(pos.add(vec2(.08, -.08)), vec2(.98), rgb(0,0,0,.4));
                
                // Wall block
                drawRect(pos, vec2(.98), COLOR_WALL);
                
                // Brick pattern
                const brickHi = COLOR_WALL.lerp(rgb(1,1,1), .1);
                const brickSh = COLOR_WALL.lerp(rgb(0,0,0), .15);
                
                // Top edge highlight
                drawRect(pos.add(vec2(0, .4)), vec2(.9, .1), brickHi);
                
                // Bottom edge shadow
                drawRect(pos.add(vec2(0, -.4)), vec2(.9, .1), brickSh);
                
                // Horizontal mortar lines
                drawRect(pos.add(vec2(0, .15)), vec2(.95, .03), brickSh);
                drawRect(pos.add(vec2(0, -.2)), vec2(.95, .03), brickSh);
            }
            
            // Draw targets
            if (tile === TARGET)
            {
                drawTarget(pos);
            }
            
            // Draw boxes
            if (tile === BOX)
            {
                drawBox(pos, false);
            }
            else if (tile === BOX_ON_TARGET)
            {
                drawTarget(pos); // Show target underneath
                drawBox(pos, true);
            }
        }
    }
    
    // Draw player
    drawPlayer(playerPos);
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    // UI - Level info
    const levelText = `Level ${currentLevel + 1}/${LEVELS.length}`;
    drawTextScreen(levelText, vec2(20, 24), 28, rgb(1,1,1), 4, rgb(0,0,0), 'left');
    
    // Moves and pushes
    const statsText = `Moves: ${moves}  Pushes: ${pushes}`;
    drawTextScreen(statsText, vec2(mainCanvasSize.x - 20, 24), 22, rgb(.9,.9,.9), 3, rgb(0,0,0), 'right');
    
    // Controls hint
    const controlsText = 'Arrows/WASD: Move | Z/U: Undo | R: Restart | N/P: Skip Level';
    drawTextScreen(controlsText, vec2(mainCanvasSize.x / 2, mainCanvasSize.y - 20), 18, rgb(.7,.7,.7), 2, rgb(0,0,0));
    
    // Level complete message
    if (levelComplete)
    {
        // Darken background
        drawRect(cameraPos, vec2(100), rgb(0,0,0,.5));
        
        // Victory message
        const isLastLevel = currentLevel >= LEVELS.length - 1;
        
        if (isLastLevel)
        {
            drawTextScreen('CONGRATULATIONS!', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 - 40), 52, hsl(.14, .9, .6), 6, rgb(0,0,0));
            drawTextScreen('You completed all levels!', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 20), 32, rgb(1,1,1), 4, rgb(0,0,0));
        }
        else
        {
            drawTextScreen('LEVEL COMPLETE!', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 - 30), 48, hsl(.33, .8, .55), 6, rgb(0,0,0));
            drawTextScreen(`Moves: ${moves}  Pushes: ${pushes}`, vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 20), 28, rgb(1,1,1), 4, rgb(0,0,0));
        }
        
        if (messageTimer > 1.0)
        {
            const blink = Math.sin(time * 5) > 0;
            if (blink)
            {
                const nextText = isLastLevel ? 'Click or Space to play again' : 'Click or Space for next level';
                drawTextScreen(nextText, vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 70), 24, rgb(.9,.9,.6), 3, rgb(0,0,0));
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body></html>
