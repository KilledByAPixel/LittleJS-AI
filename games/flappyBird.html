<!DOCTYPE html><head>
<title>LittleJS AI Starter Project</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/littlejs.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false; // Hide debug watermark in corner
showEngineVersion = false; // Hide engine version console display
paused = false; // Start unpaused

// engine settings, customize if necessary
gravity = vec2(0, 0); // we'll do our own gravity for consistent feel
cameraPos = vec2(0, 0); // Camera centered at origin
cameraScale = 48; // Camera zoom

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Flappy Bird (no external assets)

// world bounds (in world units, with cameraScale=48 and 1280x720 -> about 26.6 x 15)
const WORLD_W = 26;
const WORLD_H = 15;
const WORLD_TOP =  WORLD_H/2;
const WORLD_BOT = -WORLD_H/2;

const FLOOR_H = 1.4;
const FLOOR_Y = WORLD_BOT + FLOOR_H/2;

const BIRD_X = -6.5;
const BIRD_SIZE = vec2(.95, .75);
const GRAVITY = -28;           // units/s^2
const FLAP_VELOCITY = 10.2;    // units/s
const MAX_FALL_SPEED = -18;

const PIPE_W = 2.3;
const GAP_H = 4.6;
const PIPE_SPEED = 8.8;        // units/s
const PIPE_SPAWN_TIME = 1.25;  // seconds

let gameState; // 'ready' | 'play' | 'dead'
let score = 0;
let bestScore = 0;

let bird;
let pipes = []; // {x, gapY, scored}
let pipeSpawnTimer = 0;
let shakeTimer = 0;

// sounds
const sFlap  = new SoundGenerator({volume:.55, frequency:560, release:.09, slide:-1.2, randomness:.06});
const sScore = new SoundGenerator({volume:.55, frequency:880, release:.12, pitchJump:440, pitchJumpTime:.02, randomness:.02});
const sHit   = new SoundGenerator({volume:.65, frequency:140, release:.18, noise:.25, randomness:.1});

class Bird extends EngineObject
{
    constructor()
    {
        super(vec2(BIRD_X, 0), BIRD_SIZE);
        this.vel = vec2(0, 0);
        this.alive = true;
        this.t = 0;
        this.renderOrder = 10;
    }

    flap()
    {
        if (!this.alive) return;
        this.vel.y = FLAP_VELOCITY;
        sFlap.play();
    }

    die()
    {
        if (!this.alive) return;
        this.alive = false;
        gameState = 'dead';
        shakeTimer = .25;
        sHit.play();

        // best score
        bestScore = max(bestScore, score);
        try { localStorage.setItem('flappy_best', ''+bestScore); } catch(e) {}
    }

    update()
    {
        const dt = timeDelta;
        this.t += dt;

        // input
        const pressed = keyWasPressed('Space') || keyWasPressed('ArrowUp') || mouseWasPressed(0) || gamepadWasPressed(0);
        if (pressed)
        {
            if (gameState === 'ready')
                startGame();
            else if (gameState === 'play')
                this.flap();
            else if (gameState === 'dead')
                resetGame();
        }

        // idle bob
        if (gameState === 'ready')
        {
            this.pos.y = .6 * Math.sin(this.t*3);
            this.vel.y = 0;
            return;
        }

        // physics
        if (gameState === 'play' || gameState === 'dead')
        {
            this.vel.y += GRAVITY * dt;
            this.vel.y = max(this.vel.y, MAX_FALL_SPEED);
            this.pos.y += this.vel.y * dt;
        }

        // collision with bounds
        if (gameState !== 'ready')
        {
            const ceiling = WORLD_TOP - 0.2;
            if (this.pos.y + this.size.y/2 > ceiling)
                this.pos.y = ceiling - this.size.y/2, this.vel.y = min(this.vel.y, 0);

            // floor
            const floorTop = FLOOR_Y + FLOOR_H/2;
            if (this.pos.y - this.size.y/2 < floorTop)
            {
                this.pos.y = floorTop + this.size.y/2;
                if (gameState === 'play')
                    this.die();
            }
        }

        // rotate for feel (purely visual)
        const vy = this.vel.y;
        this.angle = clamp(vy / 14, -1, 1) * -0.9; // clockwise positive in LittleJS
    }

    // prevent built-in physics integration
    updatePhysics() {}

    render()
    {
        // body
        drawEllipse(this.pos, vec2(this.size.x, this.size.y), hsl(.14, .95, .55), this.angle);
        // wing
        const wingPos = this.pos.add(vec2(-.15, 0).rotate(this.angle));
        drawEllipse(wingPos, vec2(.35, .22), hsl(.09, .75, .45), this.angle + .2);
        // eye
        const eyePos = this.pos.add(vec2(.22, .16).rotate(this.angle));
        drawCircle(eyePos, .23, WHITE);
        drawCircle(eyePos.add(vec2(.07, -.03).rotate(this.angle)), .11, BLACK);
        // beak (define in bird-local space, then rotate as part of drawPoly)
        const beakPoints = [vec2(.42,.12), vec2(.82,-.03), vec2(.42,-.18)];
        drawPoly(beakPoints, hsl(.09,.95,.55), 0, BLACK, this.pos, this.angle);
    }
}

function resetGame()
{
    // clear objects/pipes
    engineObjectsDestroy();
    pipes = [];
    score = 0;
    pipeSpawnTimer = 0;
    shakeTimer = 0;

    bird = new Bird();
    gameState = 'ready';
}

function startGame()
{
    if (gameState !== 'ready') return;
    gameState = 'play';
    bird.flap();
    pipeSpawnTimer = .2; // spawn soon
}

function spawnPipe()
{
    // keep gap away from floor/ceiling
    const padTop = 1.4;
    const padBot = 2.2;
    const minY = (FLOOR_Y + FLOOR_H/2) + padBot;
    const maxY = (WORLD_TOP - padTop);

    const gapY = rand(minY, maxY);
    pipes.push({x: WORLD_W/2 + 3, gapY, scored:false});
}

function pipeRects(pipe)
{
    const gapHalf = GAP_H/2;
    const floorTop = FLOOR_Y + FLOOR_H/2;
    const topStart = pipe.gapY + gapHalf;
    const botEnd   = pipe.gapY - gapHalf;

    // top pipe
    const topH = max(0, WORLD_TOP - topStart);
    const topPos = vec2(pipe.x, topStart + topH/2);
    const topSize = vec2(PIPE_W, topH);

    // bottom pipe
    const botH = max(0, botEnd - floorTop);
    const botPos = vec2(pipe.x, floorTop + botH/2);
    const botSize = vec2(PIPE_W, botH);

    return {topPos, topSize, botPos, botSize};
}

function collideBirdWithPipes()
{
    for (const p of pipes)
    {
        const r = pipeRects(p);
        if (r.topSize.y > 0 && isOverlapping(bird.pos, bird.size, r.topPos, r.topSize))
            return true;
        if (r.botSize.y > 0 && isOverlapping(bird.pos, bird.size, r.botPos, r.botSize))
            return true;
    }
    return false;
}

function updateScore()
{
    for (const p of pipes)
    {
        if (!p.scored && p.x + PIPE_W/2 < bird.pos.x)
        {
            p.scored = true;
            score++;
            sScore.play();
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    // fixed size canvas for consistent feel
    setCanvasFixedSize(vec2(1280, 720));

    // load best score
    try { bestScore = parseInt(localStorage.getItem('flappy_best')||'0')||0; } catch(e) { bestScore = 0; }

    resetGame();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    const dt = timeDelta;

    // screenshake
    if (shakeTimer > 0)
        shakeTimer = max(0, shakeTimer - dt);

    if (gameState === 'play')
    {
        // spawn pipes
        pipeSpawnTimer -= dt;
        if (pipeSpawnTimer <= 0)
        {
            pipeSpawnTimer += PIPE_SPAWN_TIME;
            spawnPipe();
        }

        // move pipes
        for (const p of pipes)
            p.x -= PIPE_SPEED * dt;

        // cull pipes
        pipes = pipes.filter(p => p.x > -WORLD_W/2 - 5);

        // score
        updateScore();

        // collisions
        if (collideBirdWithPipes())
            bird.die();
    }
    else if (gameState === 'dead')
    {
        // let pipes keep moving a bit for drama
        for (const p of pipes)
            p.x -= PIPE_SPEED * dt * 0.35;
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // camera centered, with slight shake
    let shake = vec2();
    if (shakeTimer > 0)
    {
        const s = (shakeTimer/.25);
        shake = randVec2(1).scale(.15*s);
    }
    cameraPos = shake;
    cameraAngle = 0;
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // background
    const camSize = getCameraSize();
    const skyTop = hsl(.57, .45, .70);
    const skyBot = hsl(.57, .35, .88);
    drawRectGradient(cameraPos, camSize, skyBot, skyTop);

    // subtle sun
    drawCircle(cameraPos.add(vec2(7,4)), 4.5, hsl(.14,.55,.9,.25));

    // pipes
    for (const p of pipes)
    {
        const r = pipeRects(p);
        const pipeColor = hsl(.33, .55, .42);
        const pipeRim   = hsl(.33, .45, .32);

        if (r.topSize.y > 0)
        {
            drawRect(r.topPos, r.topSize, pipeColor);
            // rim at end
            drawRect(vec2(p.x, (p.gapY+GAP_H/2) + .35), vec2(PIPE_W+0.3, .7), pipeRim);
        }
        if (r.botSize.y > 0)
        {
            drawRect(r.botPos, r.botSize, pipeColor);
            drawRect(vec2(p.x, (p.gapY-GAP_H/2) - .35), vec2(PIPE_W+0.3, .7), pipeRim);
        }
    }

    // ground
    const groundColorTop = hsl(.11,.55,.55);
    const groundColorBot = hsl(.11,.55,.40);
    drawRectGradient(vec2(0, FLOOR_Y), vec2(WORLD_W*2, FLOOR_H), groundColorBot, groundColorTop);

    // grass strip
    drawRect(vec2(0, FLOOR_Y + FLOOR_H/2 - .1), vec2(WORLD_W*2, .25), hsl(.33,.55,.45));
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    // UI
    const cx = mainCanvasSize.x/2;

    // score
    const scoreText = '' + score;
    drawTextScreen(scoreText, vec2(cx, 70), 90, WHITE, 8, hsl(0,0,0,.55));

    if (gameState === 'ready')
    {
        drawTextScreen('FLAPPY', vec2(cx, 170), 80, WHITE, 10, hsl(0,0,0,.55));
        drawTextScreen('Click / Tap / Space', vec2(cx, 240), 40, hsl(0,0,1), 6, hsl(0,0,0,.55));
        drawTextScreen('Avoid the pipes', vec2(cx, 285), 32, hsl(0,0,1), 5, hsl(0,0,0,.55));
    }
    else if (gameState === 'dead')
    {
        drawTextScreen('GAME OVER', vec2(cx, 190), 70, hsl(0,0,1), 10, hsl(0,0,0,.65));
        drawTextScreen(`Best: ${bestScore}`, vec2(cx, 255), 42, hsl(0,0,1), 6, hsl(0,0,0,.65));
        drawTextScreen('Tap/Space to Restart', vec2(cx, 320), 34, hsl(0,0,1), 6, hsl(0,0,0,.65));
    }
}

///////////////////////////////////////////////////////////////////////////////
// Startup LittleJS Engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
