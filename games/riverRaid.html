<!DOCTYPE html><head>
<title>LittleJS AI Starter Project</title>
<meta charset=utf-8>
</head><body>
<script src="../dist/littlejs.js?1.18.0"></script>
<script>
'use strict';

// engine settings
debugWatermark = false; // Hide debug watermark in corner
showEngineVersion = false; // Hide engine version console display

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// River Raid (tiny untextured prototype)

// tuning
const SEG_LEN = 8;
const MIN_WIDTH = 10;
const MAX_WIDTH = 18;
const CENTER_LIMIT = 14;

const PLAYER_SIZE = vec2(1.1, 1.2);
const PLAYER_X_SPEED = .18;
const SPEED_BASE = .25;
const SPEED_MIN = .14;
const SPEED_MAX = .38;

const MAX_FUEL = 100;

// colors
const LAND  = rgb(.08,.25,.10);
const WATER = rgb(.08,.25,.55);
const BANK  = rgb(.02,.12,.05);
const PLAYER_COLOR = rgb(.95,.95,.98);
const ENEMY_COLOR  = rgb(.85,.25,.25);
const ISLAND_COLOR = rgb(.10,.20,.08);
const FUEL_COLOR   = rgb(.95,.90,.25);
const BULLET_COLOR = rgb(1,1,1);

// state
let seed;
let riverNodes, lastNodeI;
let lastSpawnSeg;
let objects, bullets;
let playerPos, playerVelX, playerAngle;
let speed;
let score;
let fuel;
let gameOver, gameOverReason;
let flashTimer;
let shootCooldown;
let cameraX;

// sounds
let sShoot, sExplode, sFuel;

function resetGame()
{
    seed = randInt(1e9);

    riverNodes = [{ i:0, center:0, width:16 }];
    lastNodeI = 0;
    lastSpawnSeg = 0;

    objects = [];
    bullets = [];

    playerPos = vec2(0, 3);
    playerVelX = 0;
    playerAngle = 0;
    cameraX = 0;

    speed = SPEED_BASE;
    score = 0;
    fuel = MAX_FUEL;

    gameOver = false;
    gameOverReason = '';
    flashTimer = 0;
    shootCooldown = 0;
}

function ensureNode(i)
{
    while (lastNodeI < i)
    {
        const nextI = lastNodeI + 1;
        const prev = riverNodes[lastNodeI];

        const r = new RandomGenerator((seed ^ (nextI * 1337)) >>> 0);
        const drift = r.float(2.8, -2.8);
        const widen = r.float(1.25, -1.25);

        const center = clamp(prev.center + drift, -CENTER_LIMIT, CENTER_LIMIT);
        const width  = clamp(prev.width  + widen, MIN_WIDTH, MAX_WIDTH);

        riverNodes.push({ i: nextI, center, width });
        lastNodeI = nextI;
    }
}

function riverAtY(y)
{
    const i = Math.max(0, Math.floor(y / SEG_LEN));
    ensureNode(i + 1);
    const a = riverNodes[i];
    const b = riverNodes[i + 1];

    let t = (y - i*SEG_LEN) / SEG_LEN;
    t = smoothStep(clamp(t, 0, 1));

    return {
        center: lerp(a.center, b.center, t),
        width:  lerp(a.width,  b.width,  t),
    };
}

function aabbOverlap(posA, sizeA, posB, sizeB)
{
    return Math.abs(posA.x - posB.x) * 2 < (sizeA.x + sizeB.x)
        && Math.abs(posA.y - posB.y) * 2 < (sizeA.y + sizeB.y);
}

function spawnObject(type, pos, size, extra={})
{
    const o = {
        type,
        pos: pos.copy(),
        size: size.copy(),
        destroyed: false,
        velX: 0,
        hp: 1,
        ...extra,
    };
    objects.push(o);
    return o;
}

function ensureSpawnsUpTo(yMax)
{
    const targetSeg = Math.floor(yMax / SEG_LEN);
    for (let seg = lastSpawnSeg + 1; seg <= targetSeg; ++seg)
    {
        const r = new RandomGenerator((seed + seg*99991) >>> 0);
        const y0 = seg * SEG_LEN;
        const y  = y0 + r.float(SEG_LEN-1, 1);

        const {center, width} = riverAtY(y);
        const margin = 1.2;
        const minX = center - width/2 + margin;
        const maxX = center + width/2 - margin;

        // enemies / islands
        if (r.float() < .70)
        {
            if (r.float() < .55)
            {
                // boat
                const x = r.float(maxX, minX);
                const velX = r.float(.04, -.04);
                spawnObject('boat', vec2(x, y), vec2(1.5, .8), { color: ENEMY_COLOR, velX, score: 50 });
            }
            else
            {
                // island / obstacle protruding from bank
                const side = r.float() < .5 ? -1 : 1;
                const sx = r.float(4.2, 2.4);
                const sy = r.float(2.2, 1.1);
                const bankX = center + side * (width/2);
                const x = bankX - side * (sx * .35);
                spawnObject('island', vec2(x, y), vec2(sx, sy), { color: ISLAND_COLOR, score: 25 });
            }
        }

        // fuel depots
        if (r.float() < .28)
        {
            // smaller pickups (less like big bars)
            const sx = r.float(3.2, 2.0);
            const x  = clamp(center + r.float(1.5, -1.5), minX, maxX);
            spawnObject('fuel', vec2(x, y + r.float(2, -2)), vec2(sx, .6), { color: FUEL_COLOR, score: 100, fuel: 45 });
        }

        lastSpawnSeg = seg;
    }
}

function crash(reason)
{
    if (gameOver) return;
    gameOver = true;
    gameOverReason = reason;
    flashTimer = 30;
    sExplode && sExplode.play();
}

function shoot()
{
    if (shootCooldown > 0 || gameOver) return;
    shootCooldown = 8;

    const b = {
        pos: playerPos.add(vec2(0, .9)),
        size: vec2(.2, .6),
        destroyed: false,
        vel: 0.9 + speed,
    };
    bullets.push(b);
    sShoot && sShoot.play();
}

///////////////////////////////////////////////////////////////////////////////
function gameInit()
{
    setCanvasFixedSize(vec2(960, 540));
    cameraScale = 32;

    // sound effects (simple)
    sShoot = new SoundGenerator({ volume:.35, frequency:620, release:.06, shapeCurve:.2, slide:-1.6, noise:.02 });
    sExplode = new SoundGenerator({ volume:.9, frequency:120, release:.35, shapeCurve:1.4, noise:.35, bitCrush:2, delay:.02 });
    sFuel = new SoundGenerator({ volume:.6, frequency:280, release:.18, shapeCurve:1.2, slide:1.4, pitchJump:200, pitchJumpTime:.04 });

    resetGame();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    if (keyWasPressed('Enter'))
        resetGame();

    if (gameOver)
        return;

    // speed control
    if (keyIsDown('ArrowUp') || keyIsDown('KeyW'))
        speed = clamp(speed + .004, SPEED_MIN, SPEED_MAX);
    else if (keyIsDown('ArrowDown') || keyIsDown('KeyS'))
        speed = clamp(speed - .004, SPEED_MIN, SPEED_MAX);
    else
        speed = lerp(speed, SPEED_BASE, .03);

    // lateral control
    let dx = 0;
    if (keyIsDown('ArrowLeft') || keyIsDown('KeyA')) dx -= PLAYER_X_SPEED;
    if (keyIsDown('ArrowRight') || keyIsDown('KeyD')) dx += PLAYER_X_SPEED;

    playerVelX = lerp(playerVelX, dx, .25);
    playerPos.x += playerVelX;
    playerPos.y += speed;

    // bank into the direction of movement (positive velX should tilt right)
    playerAngle = lerp(playerAngle, playerVelX*1.2, .2);

    // shoot (hold to keep firing; cooldown controls rate)
    if (keyIsDown('Space'))
        shoot();

    if (shootCooldown > 0)
        --shootCooldown;

    // fuel
    fuel -= (0.03 + speed*0.06);
    if (fuel <= 0)
    {
        fuel = 0;
        crash('OUT OF FUEL');
    }

    // spawn content ahead of camera
    const camSize = getCameraSize();
    ensureSpawnsUpTo(playerPos.y + camSize.y + 12);

    // update bullets
    for (const b of bullets)
    {
        if (b.destroyed) continue;
        b.pos.y += b.vel;
        if (b.pos.y > playerPos.y + 40)
            b.destroyed = true;

        // hit test vs objects
        for (const o of objects)
        {
            if (o.destroyed) continue;
            if (aabbOverlap(b.pos, b.size, o.pos, o.size))
            {
                b.destroyed = true;

                if (o.type === 'fuel')
                {
                    // shooting fuel gives points, but no refill
                    o.destroyed = true;
                    score += o.score;
                }
                else if (o.type === 'boat' || o.type === 'island')
                {
                    o.hp -= 1;
                    if (o.hp <= 0)
                    {
                        o.destroyed = true;
                        score += o.score || 25;
                    }
                }

                break;
            }
        }
    }

    // update objects
    for (const o of objects)
    {
        if (o.destroyed) continue;

        if (o.type === 'boat')
        {
            o.pos.x += o.velX;
            const r = riverAtY(o.pos.y);
            const minX = r.center - r.width/2 + o.size.x/2 + .2;
            const maxX = r.center + r.width/2 - o.size.x/2 - .2;
            if (o.pos.x < minX) { o.pos.x = minX; o.velX = Math.abs(o.velX); }
            if (o.pos.x > maxX) { o.pos.x = maxX; o.velX = -Math.abs(o.velX); }
        }

        // remove far behind
        if (o.pos.y < playerPos.y - 30)
            o.destroyed = true;
    }

    // collision with river banks
    const r = riverAtY(playerPos.y);
    const bankPad = .25;
    const left  = r.center - r.width/2 + PLAYER_SIZE.x/2 + bankPad;
    const right = r.center + r.width/2 - PLAYER_SIZE.x/2 - bankPad;
    if (playerPos.x < left || playerPos.x > right)
        crash('CRASHED');

    // collision with objects
    for (const o of objects)
    {
        if (o.destroyed) continue;
        if (Math.abs(o.pos.y - playerPos.y) > 3) continue;

        if (aabbOverlap(playerPos, PLAYER_SIZE, o.pos, o.size))
        {
            if (o.type === 'fuel')
            {
                o.destroyed = true;
                fuel = clamp(fuel + o.fuel, 0, MAX_FUEL);
                score += o.score;
                sFuel && sFuel.play();
            }
            else
                crash('CRASHED');
        }
    }

    // cleanup
    bullets = bullets.filter(b=>!b.destroyed);
    objects = objects.filter(o=>!o.destroyed);
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    if (flashTimer > 0)
        --flashTimer;

    const r = riverAtY(playerPos.y + 8);
    cameraX = lerp(cameraX, r.center, .08);
    // smaller forward offset makes the player appear higher on screen
    cameraPos = vec2(cameraX, playerPos.y + 6);
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    const camSize = getCameraSize();

    // land background
    drawRect(cameraPos, camSize.scale(1.25), LAND);

    // river fill (strip drawing)
    const step = 1;
    const yMin = cameraPos.y - camSize.y/2 - 2;
    const yMax = cameraPos.y + camSize.y/2 + 2;

    let lastLeft, lastRight;
    for (let y = Math.floor(yMin/step)*step; y <= yMax; y += step)
    {
        const r = riverAtY(y);
        drawRect(vec2(r.center, y), vec2(r.width, step+0.05), WATER);

        const left  = vec2(r.center - r.width/2, y);
        const right = vec2(r.center + r.width/2, y);

        if (lastLeft)
        {
            drawLine(lastLeft, left, .15, BANK);
            drawLine(lastRight, right, .15, BANK);
        }
        lastLeft = left;
        lastRight = right;
    }

    // draw objects
    for (const o of objects)
    {
        if (o.type === 'boat')
        {
            drawRect(o.pos, o.size, o.color);
            drawRect(o.pos.add(vec2(0, .18)), vec2(.35, .25), rgb(.1,.1,.1));
        }
        else if (o.type === 'fuel')
        {
            drawRect(o.pos, o.size, o.color);
            // little "cap" so it reads like a pickup even when small
            drawRect(o.pos.add(vec2(0, .02)), vec2(o.size.x*.28, o.size.y*.65), rgb(.2,.2,.2));
        }
        else // island
        {
            drawRect(o.pos, o.size, o.color);
            drawRect(o.pos.add(vec2(0, o.size.y*.2)), vec2(o.size.x*.5, o.size.y*.25), rgb(.06,.14,.05));
        }
    }

    // bullets
    for (const b of bullets)
        drawRect(b.pos, b.size, BULLET_COLOR);

    // player
    const p = playerPos;
    drawRect(p, vec2(.6, 1.0), PLAYER_COLOR, playerAngle);
    drawRect(p.add(vec2(0,-.1).rotate(playerAngle)), vec2(1.35, .25), PLAYER_COLOR, playerAngle);
    drawRect(p.add(vec2(0,.55).rotate(playerAngle)), vec2(.22, .28), rgb(.1,.1,.1), playerAngle);

    // simple crash flash
    if (flashTimer > 0)
    {
        const alpha = (flashTimer/30) * .35;
        drawRect(cameraPos, camSize, rgb(1,1,1, alpha));
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    const fuelPct = fuel / MAX_FUEL;
    const bars = 18;
    const filled = Math.max(0, Math.min(bars, Math.floor(fuelPct * bars)));
    const bar = '|' .repeat(filled) + '.' .repeat(bars - filled);

    drawTextScreen(`SCORE ${score}`, vec2(mainCanvasSize.x/2, 26), 34, hsl(0,0,1), 4, hsl(0,0,0));
    drawTextScreen(`FUEL  [${bar}]`, vec2(mainCanvasSize.x/2, 60), 26, hsl(.15,1,.6), 4, hsl(0,0,0));

    if (!gameOver)
    {
        drawTextScreen('ARROWS/WASD: MOVE  •  SPACE: SHOOT  •  ENTER: RESTART',
            vec2(mainCanvasSize.x/2, mainCanvasSize.y - 24), 20, hsl(0,0,1), 3, hsl(0,0,0));
    }
    else
    {
        drawTextScreen(gameOverReason, vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 10), 64,
            hsl(0,1,.6), 6, hsl(0,0,0));
        drawTextScreen('PRESS ENTER TO RESTART', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 46), 26,
            hsl(0,0,1), 4, hsl(0,0,0));
    }
}

///////////////////////////////////////////////////////////////////////////////
// Startup LittleJS Engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
