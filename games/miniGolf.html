<!DOCTYPE html><head>
<title>LittleJS AI Starter Project</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/littlejs.js"></script>
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/box2d.wasm.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false; // Hide debug watermark in corner
showEngineVersion = false; // Hide engine version console display
paused = false; // Start unpaused
debugKey = 'Backquote'; // Use tilde key for debug instead of Escape

// engine settings, customize if necessary
gravity = vec2(0, 0); // No gravity by default
cameraPos = vec2(0, 0); // Camera centered at origin
cameraScale = 32; // Camera zoom, larger is more zoomed in

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// mini golf (box2d)

// course constants
const COURSE_SIZE = vec2(34, 18);
const WALL_THICKNESS = 1;
const BALL_DIAMETER = 1.0;
const HOLE_DIAMETER = 1.6;
const HOLE_RING_DIAMETER = 2.2;
const MAX_DRAG = 10;        // world units
const SHOT_STRENGTH = 22;   // impulse scale
const STOP_SPEED = .2;

// game state
let courseObjects = [];
let ball, hole;
let holeIndex = 0;
let holeStrokes = 0;
let totalStrokes = 0;
let completeTimer = new Timer();
let gameState = 'menu';  // 'menu' or 'play'

// aiming
let aiming = false;
let aimMouseStart = vec2();
let aimDrag = vec2();

// sounds
let sfxHit, sfxSink;

// holes (simple hand-built layouts) - 9 holes total
const holes = [
    // Hole 1: Simple diagonal with obstacles
    {
        tee:  vec2(-14, -7),
        hole: vec2( 14,  7),
        obstacles: [
            {type:'box', pos:vec2(-2,  0), size:vec2(1.2, 10), angle: 0.2},
            {type:'box', pos:vec2( 6, -3), size:vec2(8,   1.2), angle:-0.25},
            {type:'circle', pos:vec2(-8,  5), diameter:3.0},
        ],
    },
    // Hole 2: X-shaped barriers
    {
        tee:  vec2(-15,  6),
        hole: vec2( 15, -6),
        obstacles: [
            {type:'box', pos:vec2(-4,  0), size:vec2(10,  1.2), angle: 0.35},
            {type:'box', pos:vec2( 4,  0), size:vec2(10,  1.2), angle:-0.35},
            {type:'box', pos:vec2( 0, -6), size:vec2(1.2,  5.5), angle:0},
            {type:'circle', pos:vec2( 0,  6), diameter:2.6},
        ],
    },
    // Hole 3: Corridor with pillars
    {
        tee:  vec2(-14,  0),
        hole: vec2( 14,  0),
        obstacles: [
            {type:'box', pos:vec2( 0,  5), size:vec2(24, 1.2), angle:0},
            {type:'box', pos:vec2( 0, -5), size:vec2(24, 1.2), angle:0},
            {type:'circle', pos:vec2(-4, 0), diameter:3.0},
            {type:'circle', pos:vec2( 4, 0), diameter:3.0},
        ],
    },
    // Hole 4: Zigzag
    {
        tee:  vec2(-14, -6),
        hole: vec2( 14,  6),
        obstacles: [
            {type:'box', pos:vec2(-8, 3), size:vec2(12, 1.2), angle:0},
            {type:'box', pos:vec2( 0,-3), size:vec2(12, 1.2), angle:0},
            {type:'box', pos:vec2( 8, 3), size:vec2(12, 1.2), angle:0},
        ],
    },
    // Hole 5: Pillar maze
    {
        tee:  vec2(-14, 0),
        hole: vec2( 14, 0),
        obstacles: [
            {type:'circle', pos:vec2(-10, 4), diameter:2.5},
            {type:'circle', pos:vec2(-10,-4), diameter:2.5},
            {type:'circle', pos:vec2(-5,  0), diameter:3.0},
            {type:'circle', pos:vec2( 0,  5), diameter:2.5},
            {type:'circle', pos:vec2( 0, -5), diameter:2.5},
            {type:'circle', pos:vec2( 5,  0), diameter:3.0},
            {type:'circle', pos:vec2( 10, 4), diameter:2.5},
            {type:'circle', pos:vec2( 10,-4), diameter:2.5},
        ],
    },
    // Hole 6: L-shaped corridor
    {
        tee:  vec2(-14, -6),
        hole: vec2( 14,  6),
        obstacles: [
            {type:'box', pos:vec2(-5, -2), size:vec2(1.2, 10), angle:0},
            {type:'box', pos:vec2( 5,  2), size:vec2(10, 1.2), angle:0},
            {type:'circle', pos:vec2( 0, -6), diameter:2.8},
        ],
    },
    // Hole 7: Funnel
    {
        tee:  vec2(-14, 0),
        hole: vec2( 14, 0),
        obstacles: [
            {type:'box', pos:vec2(-6, 5), size:vec2(8, 1.2), angle:-0.3},
            {type:'box', pos:vec2(-6,-5), size:vec2(8, 1.2), angle: 0.3},
            {type:'circle', pos:vec2(0, 0), diameter:3.5},
            {type:'box', pos:vec2( 6, 3), size:vec2(8, 1.2), angle: 0.3},
            {type:'box', pos:vec2( 6,-3), size:vec2(8, 1.2), angle:-0.3},
        ],
    },
    // Hole 8: Center obstacle
    {
        tee:  vec2(-14, 0),
        hole: vec2( 14, 0),
        obstacles: [
            {type:'circle', pos:vec2(0, 0), diameter:6.0},
            {type:'box', pos:vec2(-8, 6), size:vec2(6, 1.2), angle:0.2},
            {type:'box', pos:vec2(-8,-6), size:vec2(6, 1.2), angle:-0.2},
            {type:'box', pos:vec2( 8, 6), size:vec2(6, 1.2), angle:-0.2},
            {type:'box', pos:vec2( 8,-6), size:vec2(6, 1.2), angle:0.2},
        ],
    },
    // Hole 9: Gauntlet
    {
        tee:  vec2(-14, 0),
        hole: vec2( 14, 0),
        obstacles: [
            {type:'circle', pos:vec2(-10, 2), diameter:2.0},
            {type:'circle', pos:vec2(-10,-2), diameter:2.0},
            {type:'box', pos:vec2(-5, 0), size:vec2(1.2, 6), angle:0.15},
            {type:'circle', pos:vec2( 0, 4), diameter:2.5},
            {type:'circle', pos:vec2( 0,-4), diameter:2.5},
            {type:'box', pos:vec2( 5, 0), size:vec2(1.2, 6), angle:-0.15},
            {type:'circle', pos:vec2( 10, 2), diameter:2.0},
            {type:'circle', pos:vec2( 10,-2), diameter:2.0},
        ],
    },
];

///////////////////////////////////////////////////////////////////////////////
// helpers

function drawRectScreenSpace(pos, size, color)
{
    mainContext.fillStyle = color.toString();
    mainContext.fillRect(pos.x - size.x/2, pos.y - size.y/2, size.x, size.y);
}

function drawRotatedRectScreenSpace(pos, size, angle, color)
{
    mainContext.save();
    mainContext.translate(pos.x, pos.y);
    mainContext.rotate(-angle);  // negative because screen Y is flipped
    mainContext.fillStyle = color.toString();
    mainContext.fillRect(-size.x/2, -size.y/2, size.x, size.y);
    mainContext.restore();
}

function drawCircleScreenSpace(pos, radius, color)
{
    mainContext.fillStyle = color.toString();
    mainContext.beginPath();
    mainContext.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
    mainContext.fill();
}

function addCourseObject(o)
{
    courseObjects.push(o);
    return o;
}

function clearCourse()
{
    aiming = false;
    aimDrag = vec2();

    if (ball) ball.destroy();
    if (hole) hole.destroy();

    for (const o of courseObjects)
        o.destroy();
    courseObjects.length = 0;
}

function createWall(pos, size, angle=0)
{
    const w = addCourseObject(new Box2dStaticObject(pos));
    w.color = rgb(.2,.25,.2);
    w.outlineColor = rgb(0,0,0,.5);
    w.lineWidth = .08;
    // addBox(size, offset=vec2(), angle=0, density=0, friction=.2, restitution=0, isSensor=false)
    // higher restitution so the ball bounces more off walls
    w.addBox(size, vec2(), angle, 0, .25, .9);
    return w;
}

function createBumper(pos, size, angle=0)
{
    const b = addCourseObject(new Box2dStaticObject(pos));
    b.color = rgb(.5,.4,.2);
    b.outlineColor = rgb(0,0,0,.6);
    b.lineWidth = .08;
    b.addBox(size, vec2(), angle, 0, .3, .6);
    return b;
}

function createPillar(pos, diameter)
{
    const p = addCourseObject(new Box2dStaticObject(pos));
    p.color = rgb(.45,.45,.5);
    p.outlineColor = rgb(0,0,0,.6);
    p.lineWidth = .08;
    p.addCircle(diameter, vec2(), 0, .3, .4);
    return p;
}

class GolfBall extends Box2dObject
{
    constructor(pos)
    {
        super(pos);
        this.color = WHITE;
        this.outlineColor = rgb(0,0,0,.7);
        this.lineWidth = .06;

        this.addCircle(BALL_DIAMETER, vec2(), 1, .25, .1);
        // almost no damping so the ball keeps rolling
        this.setLinearDamping(.22);
        this.setAngularDamping(.14);
        this.setBullet(true);
    }
}

class Hole extends Box2dStaticObject
{
    constructor(pos)
    {
        super(pos);
        this.pos = pos.copy();
        this.color = BLACK;
        this.outlineColor = BLACK;
        this.lineWidth = 0;

        // sensor so we can detect contacts
        this.addCircle(HOLE_DIAMETER, vec2(), 0, 0, 0, true);
    }

    beginContact(other)
    {
        // only sink the golf ball, and only once
        if (other !== ball || completeTimer.isSet())
            return;

        // require it to be slow-ish to "count" as sunk
        if (ball.getSpeed() > 16)
            return;

        // start completion
        completeTimer.set(1.0);

        // a little suction + heavy damping
        ball.setLinearDamping(8);
        ball.setAngularDamping(8);
        ball.setLinearVelocity(ball.getLinearVelocity().scale(.25));
        ball.applyAcceleration(this.pos.subtract(ball.pos).scale(4), ball.getCenterOfMass());

        sfxSink.play();
    }

    render()
    {
        // draw hole ring and center
        drawCircle(this.pos, HOLE_RING_DIAMETER, rgb(0,0,0,.35));
        drawCircle(this.pos, HOLE_DIAMETER, rgb(0,0,0,.9));

        // simple flag
        const poleTop = this.pos.add(vec2(0, 3.2));
        drawLine(this.pos.add(vec2(0, .8)), poleTop, .12, rgb(.9,.9,.9));
        drawPoly([
            poleTop,
            poleTop.add(vec2(2.1, -.6)),
            poleTop.add(vec2(0, -1.2)),
        ], rgb(1,.2,.2));
    }
}

function buildHole(index)
{
    clearCourse();

    holeIndex = mod(index, holes.length);
    holeStrokes = 0;
    completeTimer.unset();

    const h = holes[holeIndex];

    // boundaries
    const half = COURSE_SIZE.scale(.5);
    createWall(vec2(0,  half.y + WALL_THICKNESS/2), vec2(COURSE_SIZE.x + 2*WALL_THICKNESS, WALL_THICKNESS)); // top
    createWall(vec2(0, -half.y - WALL_THICKNESS/2), vec2(COURSE_SIZE.x + 2*WALL_THICKNESS, WALL_THICKNESS)); // bottom
    createWall(vec2( half.x + WALL_THICKNESS/2, 0), vec2(WALL_THICKNESS, COURSE_SIZE.y)); // right
    createWall(vec2(-half.x - WALL_THICKNESS/2, 0), vec2(WALL_THICKNESS, COURSE_SIZE.y)); // left

    // obstacles
    for (const o of h.obstacles)
    {
        if (o.type === 'box')
            createBumper(o.pos, o.size, o.angle || 0);
        else if (o.type === 'circle')
            createPillar(o.pos, o.diameter);
    }

    // hole + ball
    hole = new Hole(h.hole);
    ball = new GolfBall(h.tee);

    // tiny tee marker
    const tee = addCourseObject(new EngineObject(h.tee, vec2(.8,.8)));
    tee.color = rgb(1,1,1,.2);
    tee.renderOrder = -1;
    tee.update = ()=>{};
}

function canShoot()
{
    return ball && !completeTimer.isSet() && ball.getSpeed() < STOP_SPEED;
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    // setup box2d first!
    await box2dInit();

    // visuals
    canvasClearColor = rgb(.08,.12,.08);
    setCanvasFixedSize(vec2(1280, 720));
    cameraPos = vec2();
    cameraScale = 32;

    // sounds
    sfxHit = new SoundGenerator({
        volume:.9,
        frequency:260,
        attack:0,
        release:.12,
        shapeCurve:1.4,
        slide:-2.2,
        noise:.02,
    });

    sfxSink = new SoundGenerator({
        volume:.8,
        frequency:620,
        attack:0,
        release:.18,
        shapeCurve:1.1,
        slide:-3.5,
        pitchJump:120,
        pitchJumpTime:.06,
        delay:.05,
    });

    // start at menu
    gameState = 'menu';
    totalStrokes = 0;
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    // Menu state
    if (gameState == 'menu')
    {
        // Handle hole selection clicks
        if (mouseWasPressed(0))
        {
            const gridSize = 3;
            const cellW = 360;
            const cellH = 200;
            const startX = (mainCanvasSize.x - gridSize * cellW) / 2;
            const startY = 140;
            
            for (let i = 0; i < 9; i++)
            {
                const col = i % gridSize;
                const row = (i / gridSize) | 0;
                const cx = startX + col * cellW + cellW/2;
                const cy = startY + row * cellH + cellH/2;
                
                // Check if mouse is within this cell
                if (mousePosScreen.x > cx - cellW/2 + 10 && mousePosScreen.x < cx + cellW/2 - 10 &&
                    mousePosScreen.y > cy - cellH/2 + 10 && mousePosScreen.y < cy + cellH/2 - 10)
                {
                    gameState = 'play';
                    totalStrokes = 0;
                    buildHole(i);
                    return;
                }
            }
        }
        return;
    }

    // reset/retry
    if (keyWasPressed('KeyR'))
        buildHole(holeIndex);

    // next hole (debug)
    if (keyWasPressed('KeyN'))
        buildHole(holeIndex + 1);

    // return to menu
    if (keyWasPressed('Escape'))
    {
        clearCourse();
        gameState = 'menu';
        return;
    }

    // completion
    if (completeTimer.elapsed())
        buildHole(holeIndex + 1);

    // aiming controls
    if (completeTimer.isSet())
    {
        aiming = false;
        return;
    }

    if (aiming)
    {
        if (mouseIsDown(0))
        {
            // aim in the direction you drag the mouse
            aimDrag = mousePos.subtract(ball.pos);
        }
        else
            aiming = false;

        if (mouseWasReleased(0))
        {
            const drag = mousePos.subtract(ball.pos);
            const dragLen = drag.length();
            const power = clamp(dragLen / MAX_DRAG);

            aiming = false;
            aimDrag = vec2();

            if (!canShoot() || power < .05)
                return;

            const dir = drag.normalize();
            const impulse = dir.scale(power * SHOT_STRENGTH);

            ball.applyAcceleration(impulse, ball.getCenterOfMass());
            sfxHit.play();

            holeStrokes++;
            totalStrokes++;
        }
    }
    else
    {
        // start aiming only if clicking near ball and ball is stopped
        if (mouseWasPressed(0) && canShoot())
        {
            if (mousePos.distance(ball.pos) < 2.4)
            {
                aiming = true;
                aimMouseStart = mousePos.copy();
                aimDrag = vec2();
            }
        }
    }

    // gentle clamp: if ball escaped somehow, respawn at tee
    const half = COURSE_SIZE.scale(.5).add(vec2(6));
    if (ball.pos.x < -half.x || ball.pos.x > half.x || ball.pos.y < -half.y || ball.pos.y > half.y)
        buildHole(holeIndex);
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // center camera
    setCameraPos(vec2());
    
    // Rapid slowdown when ball is moving slowly but not yet stopped
    if (ball && !completeTimer.isSet())
    {
        const speed = ball.getSpeed();
        const slowdownThreshold = STOP_SPEED * 10;  // 2.0 - starts slowing down earlier
        if (speed > STOP_SPEED && speed < slowdownThreshold)
        {
            // Apply extra damping to rapidly slow down the ball
            const vel = ball.getLinearVelocity();
            ball.setLinearVelocity(vel.scale(0.92));  // reduce velocity each frame
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    if (gameState == 'menu')
        return;  // Don't render game world in menu

    // background grass
    drawRect(cameraPos, COURSE_SIZE.add(vec2(6)), rgb(.12,.22,.12));
    drawRect(cameraPos, COURSE_SIZE.add(vec2(1.2)), rgb(.18,.35,.18));
    drawRect(cameraPos, COURSE_SIZE, rgb(.14,.28,.14));

    // subtle stripes
    for (let i=-8; i<=8; i++)
        drawRect(vec2(i*2, 0), vec2(.7, COURSE_SIZE.y), rgb(1,1,1,.03));

    // tee -> hole hint line (only when stopped)
    if (canShoot())
        drawLine(ball.pos, hole.pos, .08, rgb(1,1,1,.12));
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    // Menu rendering
    if (gameState == 'menu')
    {
        // Title
        drawTextScreen('MINI GOLF', vec2(mainCanvasSize.x/2, 70), 72, WHITE, 6, BLACK);
        
        // 3x3 grid of hole previews
        const gridSize = 3;
        const cellW = 360;
        const cellH = 200;
        const startX = (mainCanvasSize.x - gridSize * cellW) / 2;
        const startY = 100;
        const previewScale = 8;  // Scale for drawing preview
        
        for (let i = 0; i < 9; i++)
        {
            const col = i % gridSize;
            const row = (i / gridSize) | 0;
            const cx = startX + col * cellW + cellW/2;
            const cy = startY + row * cellH + cellH/2;
            
            const h = holes[i];
            
            // Cell background
            const hovered = mousePosScreen.x > cx - cellW/2 + 10 && mousePosScreen.x < cx + cellW/2 - 10 &&
                           mousePosScreen.y > cy - cellH/2 + 10 && mousePosScreen.y < cy + cellH/2 - 10;
            const bgColor = hovered ? rgb(.2,.35,.2) : rgb(.12,.22,.12);
            drawRectScreenSpace(vec2(cx, cy), vec2(cellW - 20, cellH - 20), bgColor);
            drawRectScreenSpace(vec2(cx, cy), vec2(cellW - 24, cellH - 24), rgb(.14,.28,.14));
            
            // Hole number
            drawTextScreen('Hole ' + (i+1), vec2(cx, cy - 70), 28, WHITE, 3, BLACK);
            
            // Draw mini preview of course
            const courseW = COURSE_SIZE.x * previewScale;
            const courseH = COURSE_SIZE.y * previewScale;
            
            // Draw obstacles as simple shapes
            for (const o of h.obstacles)
            {
                const ox = cx + o.pos.x * previewScale;
                const oy = cy + 10 - o.pos.y * previewScale;  // flip Y
                
                if (o.type === 'box')
                {
                    const w = o.size.x * previewScale;
                    const hh = o.size.y * previewScale;
                    const angle = o.angle || 0;
                    drawRotatedRectScreenSpace(vec2(ox, oy), vec2(w, hh), angle, rgb(.5,.4,.2));
                }
                else if (o.type === 'circle')
                {
                    const r = o.diameter * previewScale / 2;
                    drawCircleScreenSpace(vec2(ox, oy), r, rgb(.45,.45,.5));
                }
            }
            
            // Tee position (white dot)
            const tx = cx + h.tee.x * previewScale;
            const ty = cy + 10 - h.tee.y * previewScale;
            drawRectScreenSpace(vec2(tx, ty), vec2(8, 8), WHITE);
            
            // Hole position (black dot with ring)
            const hx = cx + h.hole.x * previewScale;
            const hy = cy + 10 - h.hole.y * previewScale;
            drawRectScreenSpace(vec2(hx, hy), vec2(14, 14), rgb(0,0,0,.5));
            drawRectScreenSpace(vec2(hx, hy), vec2(10, 10), BLACK);
        }
        
        return;
    }

    // aim UI
    if (aiming && canShoot())
    {
        const drag = mousePos.subtract(ball.pos);
        const dragLen = drag.length();
        const power = clamp(dragLen / MAX_DRAG);

        const dir = dragLen ? drag.scale(1/dragLen) : vec2(1,0);
        const tip = ball.pos.add(dir.scale(6*power));
        const headLen = 1.1;
        const headWid = .7;
        const base = tip.subtract(dir.scale(headLen));
        const perp = vec2(-dir.y, dir.x);

        // shaft stops at the base of the triangle head (avoids a "Y" look)
        drawLine(ball.pos, base, .18, rgb(1,1,1,.7));

        // pointed triangle arrow head
        const p1 = base.add(perp.scale(headWid*.5));
        const p2 = base.subtract(perp.scale(headWid*.5));
        drawPoly([tip, p1, p2], rgb(1,1,1,.7));

        // power text
        drawTextScreen(`Power ${(power*100|0)}%`, vec2(mainCanvasSize.x/2, mainCanvasSize.y-36), 36, WHITE, 4, BLACK);
    }

    // completion text
    if (completeTimer.isSet())
    {
        drawTextScreen('SUNK!', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2), 120, rgb(1,1,1,.95), 8, rgb(0,0,0,.7));
    }

    // hud
    const hud = `Hole ${holeIndex+1}/${holes.length}   Strokes: ${holeStrokes}   Total: ${totalStrokes}\n` +
        `Drag from the ball to aim + shoot.  R = Retry, N = Next hole`;
    drawTextScreen(hud, vec2(mainCanvasSize.x/2, 52), 36, WHITE, 4, rgb(0,0,0,.6));
}

///////////////////////////////////////////////////////////////////////////////
// Startup LittleJS Engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
