<!DOCTYPE html><head>
<title>LittleJS 2048</title>
<meta charset=utf-8>
</head><body style="background:#000">
<script src="../dist/littlejs.js?1.18.0"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;

gravity = vec2(0, 0);
cameraPos = vec2(0, 0);
cameraScale = 32;
enablePhysicsSolver = false;
showSplashScreen = false;
fontDefault = 'arial';

// AI can use this class to make sound effects
class SoundGenerator extends Sound
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// 2048 Game

const GRID = 4;
const CELL_SIZE = 1;
const GAP = .12;

let grid;
let popGrid;
let score = 0;
let best = 0;
let gameOver = false;
let won = false;
let continueAfterWin = false;

let swipeStartScreen;
let swipeArmed = false;

let sMove, sMerge, sSpawn, sLose, sWin;

function gameInit()
{
    setCanvasFixedSize(vec2(720, 900));
    canvasClearColor = hsl(0, 0, .08);

    best = +localStorage.getItem('ljs2048_best') || 0;

    sMove  = new SoundGenerator({frequency: 260, release: .06, volume: .7, randomness: .02});
    sMerge = new SoundGenerator({frequency: 190, pitchJump: 320, pitchJumpTime: .02, release: .14, volume: .9, randomness: .02});
    sSpawn = new SoundGenerator({frequency: 520, release: .05, volume: .35, randomness: .05});
    sLose  = new SoundGenerator({frequency: 120, slide: -.15, release: .35, volume: .9, randomness: .02});
    sWin   = new SoundGenerator({frequency: 620, pitchJump: 220, pitchJumpTime: .05, release: .25, volume: 1, randomness: .01});

    newGame();
}

///////////////////////////////////////////////////////////////////////////////
function newGame()
{
    score = 0;
    gameOver = false;
    won = false;
    continueAfterWin = false;

    grid = [];
    popGrid = [];
    for (let y = 0; y < GRID; ++y)
    {
        grid[y] = [];
        popGrid[y] = [];
        for (let x = 0; x < GRID; ++x)
        {
            grid[y][x] = 0;
            popGrid[y][x] = 0;
        }
    }

    addRandomTile();
    addRandomTile();
}

function boardWorldSize()
{
    return GRID * CELL_SIZE + (GRID + 1) * GAP;
}

function cellCenterWorld(x, y)
{
    const s = boardWorldSize();
    const o = -s / 2;
    return vec2(
        o + GAP + CELL_SIZE / 2 + x * (CELL_SIZE + GAP),
        o + GAP + CELL_SIZE / 2 + (GRID - 1 - y) * (CELL_SIZE + GAP)
    );
}

function empties()
{
    const e = [];
    for (let y = 0; y < GRID; ++y)
        for (let x = 0; x < GRID; ++x)
            if (!grid[y][x]) e.push([x, y]);
    return e;
}

function addRandomTile()
{
    const e = empties();
    if (!e.length) return false;
    const [x, y] = e[(Math.random() * e.length) | 0];
    const v = Math.random() < .9 ? 2 : 4;
    grid[y][x] = v;
    popGrid[y][x] = .14;
    sSpawn.play();
    return true;
}

function slideLine(line)
{
    const src = line.filter(v => v);
    const out = [];
    let moved = false;
    let mergedAny = false;

    for (let i = 0; i < src.length; ++i)
    {
        let v = src[i];
        if (i + 1 < src.length && src[i + 1] === v)
        {
            v *= 2;
            i++;
            score += v;
            mergedAny = true;
            moved = true;
        }
        out.push(v);
    }
    while (out.length < GRID) out.push(0);

    for (let i = 0; i < GRID; ++i)
        if (out[i] !== line[i]) { moved = true; break; }

    return { out, moved, mergedAny };
}

function canMove()
{
    for (let y = 0; y < GRID; ++y)
        for (let x = 0; x < GRID; ++x)
        {
            const v = grid[y][x];
            if (!v) return true;
            if (x + 1 < GRID && grid[y][x + 1] === v) return true;
            if (y + 1 < GRID && grid[y + 1][x] === v) return true;
        }
    return false;
}

function applyMove(dir)
{
    if (gameOver) return;
    if (won && !continueAfterWin) return;

    let anyMoved = false;
    let anyMerged = false;

    const markPop = (x, y) => popGrid[y][x] = max(popGrid[y][x], .16);

    if (dir === 'L' || dir === 'R')
    {
        for (let y = 0; y < GRID; ++y)
        {
            const row = grid[y].slice();
            const line = dir === 'L' ? row : row.slice().reverse();
            const { out, moved, mergedAny } = slideLine(line);
            const newLine = dir === 'L' ? out : out.slice().reverse();
            grid[y] = newLine;
            if (moved) anyMoved = true;
            if (mergedAny)
            {
                anyMerged = true;
                for (let x = 0; x < GRID; ++x)
                    if (newLine[x] && newLine[x] !== row[x]) markPop(x, y);
            }
        }
    }
    else
    {
        for (let x = 0; x < GRID; ++x)
        {
            const col = [];
            for (let y = 0; y < GRID; ++y) col.push(grid[y][x]);
            const line = dir === 'U' ? col : col.slice().reverse();
            const { out, moved, mergedAny } = slideLine(line);
            const newLine = dir === 'U' ? out : out.slice().reverse();
            for (let y = 0; y < GRID; ++y)
            {
                const oldV = grid[y][x];
                const newV = newLine[y];
                grid[y][x] = newV;
                if (mergedAny && newV && newV !== oldV) markPop(x, y);
            }
            if (moved) anyMoved = true;
            if (mergedAny) anyMerged = true;
        }
    }

    if (!anyMoved) return;

    if (anyMerged) sMerge.play();
    else sMove.play();

    best = max(best, score);
    localStorage.setItem('ljs2048_best', best);

    if (!won)
    {
        outer: for (let y = 0; y < GRID; ++y)
            for (let x = 0; x < GRID; ++x)
                if (grid[y][x] >= 2048) { won = true; sWin.play(); break outer; }
    }

    addRandomTile();

    if (!canMove())
    {
        gameOver = true;
        sLose.play();
    }
}

function readMoveInput()
{
    if (keyWasPressed('ArrowLeft') || keyWasPressed('KeyA')) return 'L';
    if (keyWasPressed('ArrowRight') || keyWasPressed('KeyD')) return 'R';
    if (keyWasPressed('ArrowUp') || keyWasPressed('KeyW')) return 'U';
    if (keyWasPressed('ArrowDown') || keyWasPressed('KeyS')) return 'D';

    if (mouseWasPressed(0))
    {
        swipeStartScreen = mousePosScreen.copy();
        swipeArmed = true;
    }
    if (swipeArmed && mouseWasReleased(0))
    {
        swipeArmed = false;
        const d = mousePosScreen.subtract(swipeStartScreen);
        const ax = abs(d.x), ay = abs(d.y);
        const minSwipe = 40;
        if (max(ax, ay) < minSwipe) return;
        if (ax > ay) return d.x < 0 ? 'L' : 'R';
        return d.y < 0 ? 'U' : 'D';
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    // decay pop timers
    for (let y = 0; y < GRID; ++y)
        for (let x = 0; x < GRID; ++x)
            popGrid[y][x] = max(0, popGrid[y][x] - timeDelta);

    if (keyWasPressed('KeyR'))
        newGame();

    if (won && !continueAfterWin && keyWasPressed('KeyC'))
        continueAfterWin = true;

    const dir = readMoveInput();
    if (dir)
        applyMove(dir);
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    cameraPos = vec2(0, 0);
    const s = boardWorldSize();
    const margin = 1.1;
    const viewPixels = min(mainCanvasSize.x, mainCanvasSize.y * 0.78);
    cameraScale = viewPixels / (s + margin * 2);
}

///////////////////////////////////////////////////////////////////////////////
function tileFillColor(v)
{
    const p = clamp((Math.log2(v) - 1) / 11, 0, 1);
    const hue = .12 - .10 * p; // golden -> red
    const sat = .55 + .25 * p;
    const lit = .80 - .38 * p;
    return hsl(hue, sat, lit);
}

function tileTextColor(v)
{
    return v <= 4 ? hsl(0, 0, .15) : hsl(0, 0, .98);
}

function gameRender()
{
    // background
    drawRect(cameraPos, vec2(200), hsl(0, 0, .09));

    const boardSize = boardWorldSize();
    drawRect(vec2(0, 0), vec2(boardSize), hsl(0, 0, .18));

    // cells + tiles
    for (let y = 0; y < GRID; ++y)
    for (let x = 0; x < GRID; ++x)
    {
        const c = cellCenterWorld(x, y);
        drawRect(c, vec2(CELL_SIZE), hsl(0, 0, .25)); // empty slot

        const v = grid[y][x];
        if (!v) continue;

        const pop = popGrid[y][x];
        const popT = pop ? pop / .16 : 0;
        const scale = 1 + .10 * popT;
        const size = vec2(CELL_SIZE * .92 * scale);

        drawRect(c, size, tileFillColor(v));

        const digits = ('' + v).length;
        const textSize = clamp(.52 - .07 * (digits - 1), .24, .52);
        drawText(
            '' + v,
            c.add(vec2(0, -textSize * .06)),
            textSize,
            tileTextColor(v),
            .08,
            hsl(0, 0, .05)
        );
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    const topY = 54;
    drawTextScreen('2048', vec2(86, topY), 64, hsl(.12, .7, .9), 6, hsl(0, 0, 0));
    drawTextScreen(`Score: ${score}`, vec2(mainCanvasSize.x / 2, topY), 34, hsl(0, 0, 1), 4, hsl(0, 0, 0));
    drawTextScreen(`Best: ${best}`, vec2(mainCanvasSize.x - 110, topY), 28, hsl(0, 0, .9), 4, hsl(0, 0, 0));
    drawTextScreen('Arrows/WASD or swipe Â· R = restart', vec2(mainCanvasSize.x / 2, mainCanvasSize.y - 22), 20, hsl(0, 0, .8), 3, hsl(0, 0, 0));

    if (won && !continueAfterWin)
    {
        drawRect(vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2), mainCanvasSize, hsl(0, 0, 0, .55), 0, false, true);
        drawTextScreen('You made 2048!', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 - 30), 56, hsl(.25, .7, .9), 6, hsl(0, 0, 0));
        drawTextScreen('Press C to keep going', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 28), 28, hsl(0, 0, 1), 4, hsl(0, 0, 0));
    }

    if (gameOver)
    {
        drawRect(vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2), mainCanvasSize, hsl(0, 0, 0, .65), 0, false, true);
        drawTextScreen('Game Over', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 - 18), 64, hsl(0, 0, 1), 6, hsl(0, 0, 0));
        drawTextScreen('Press R to restart', vec2(mainCanvasSize.x / 2, mainCanvasSize.y / 2 + 36), 28, hsl(0, 0, .9), 4, hsl(0, 0, 0));
    }
}

///////////////////////////////////////////////////////////////////////////////
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
