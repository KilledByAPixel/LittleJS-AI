<!DOCTYPE html><head>
<title>LittleJS Othello</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="../dist/littlejs.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;

gravity = vec2(0, 0);
cameraPos = vec2(0, 0);
cameraScale = 42;

// AI can use this class to make sound effects
class SoundGenerator extends Sound
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;

        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0,
            pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// OTHELLO GAME

const BOARD_SIZE = 8;
const CELL_SIZE = 1.8;
const DISC_RADIUS = 0.7;

const DISC_BLACK = 1;
const DISC_WHITE = 2;
const DISC_EMPTY = 0;

const PLAYER_HUMAN = DISC_BLACK;
const PLAYER_AI = DISC_WHITE;

// Game state
let board = [];
let currentPlayer = DISC_BLACK;
let gameOver = false;
let winner = null;
let blackScore = 2;
let whiteScore = 2;
let validMoves = [];
let gameMode = 'menu'; // 'menu', 'pvp', 'ai'
let passCount = 0;

// Animation
let flippingDiscs = []; // {row, col, progress, fromColor}
const FLIP_DURATION = 0.3;

// UI
let hoverCell = null;
let menuButtons = [];

// Sounds
let sfxPlace, sfxFlip, sfxWin, sfxLose, sfxSelect;

///////////////////////////////////////////////////////////////////////////////
// BOARD LOGIC

function initBoard()
{
    board = [];
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        board[row] = [];
        for (let col = 0; col < BOARD_SIZE; col++)
            board[row][col] = DISC_EMPTY;
    }
    
    // Starting position
    const mid = BOARD_SIZE / 2;
    board[mid-1][mid-1] = DISC_WHITE;
    board[mid][mid] = DISC_WHITE;
    board[mid-1][mid] = DISC_BLACK;
    board[mid][mid-1] = DISC_BLACK;
    
    currentPlayer = DISC_BLACK;
    gameOver = false;
    winner = null;
    blackScore = 2;
    whiteScore = 2;
    passCount = 0;
    flippingDiscs = [];
    
    updateValidMoves();
}

function getOpponent(player)
{
    return player === DISC_BLACK ? DISC_WHITE : DISC_BLACK;
}

function isInBounds(row, col)
{
    return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
}

function checkDirection(row, col, player, dRow, dCol)
{
    const opponent = getOpponent(player);
    let r = row + dRow;
    let c = col + dCol;
    let hasOpponent = false;
    
    while (isInBounds(r, c))
    {
        if (board[r][c] === DISC_EMPTY)
            return [];
        
        if (board[r][c] === opponent)
        {
            hasOpponent = true;
            r += dRow;
            c += dCol;
        }
        else if (board[r][c] === player)
        {
            if (hasOpponent)
            {
                // Found valid flip sequence
                const flips = [];
                r = row + dRow;
                c = col + dCol;
                while (board[r][c] === opponent)
                {
                    flips.push({row: r, col: c});
                    r += dRow;
                    c += dCol;
                }
                return flips;
            }
            return [];
        }
    }
    
    return [];
}

function getFlipsForMove(row, col, player)
{
    if (board[row][col] !== DISC_EMPTY)
        return [];
    
    const allFlips = [];
    const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [0, -1],           [0, 1],
        [1, -1],  [1, 0],  [1, 1]
    ];
    
    for (const [dRow, dCol] of directions)
    {
        const flips = checkDirection(row, col, player, dRow, dCol);
        allFlips.push(...flips);
    }
    
    return allFlips;
}

function isValidMove(row, col, player)
{
    return getFlipsForMove(row, col, player).length > 0;
}

function updateValidMoves()
{
    validMoves = [];
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        for (let col = 0; col < BOARD_SIZE; col++)
        {
            if (isValidMove(row, col, currentPlayer))
                validMoves.push({row, col});
        }
    }
}

function makeMove(row, col, player)
{
    const flips = getFlipsForMove(row, col, player);
    if (flips.length === 0)
        return false;
    
    board[row][col] = player;
    
    // Start flip animations
    for (const flip of flips)
    {
        const fromColor = board[flip.row][flip.col];
        board[flip.row][flip.col] = player;
        flippingDiscs.push({
            row: flip.row,
            col: flip.col,
            progress: 0,
            fromColor: fromColor
        });
    }
    
    updateScore();
    
    // Play sounds
    sfxPlace && sfxPlace.play(getCellWorldPos(row, col));
    if (flips.length > 0)
        sfxFlip && sfxFlip.play(getCellWorldPos(row, col));
    
    // Switch player
    currentPlayer = getOpponent(currentPlayer);
    updateValidMoves();
    
    // Check if next player has moves
    if (validMoves.length === 0)
    {
        passCount++;
        currentPlayer = getOpponent(currentPlayer);
        updateValidMoves();
        
        // If still no moves, game over
        if (validMoves.length === 0 || passCount >= 2)
            endGame();
    }
    else
    {
        passCount = 0;
    }
    
    return true;
}

function updateScore()
{
    blackScore = 0;
    whiteScore = 0;
    
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        for (let col = 0; col < BOARD_SIZE; col++)
        {
            if (board[row][col] === DISC_BLACK)
                blackScore++;
            else if (board[row][col] === DISC_WHITE)
                whiteScore++;
        }
    }
}

function endGame()
{
    gameOver = true;
    
    if (blackScore > whiteScore)
    {
        winner = DISC_BLACK;
        if (gameMode === 'ai')
            sfxWin && sfxWin.play();
    }
    else if (whiteScore > blackScore)
    {
        winner = DISC_WHITE;
        if (gameMode === 'ai')
            sfxLose && sfxLose.play();
    }
    else
    {
        winner = null; // Tie
    }
}

///////////////////////////////////////////////////////////////////////////////
// AI

function evaluateBoard(player)
{
    let score = 0;
    
    // Corner bonus
    const corners = [[0,0], [0,7], [7,0], [7,7]];
    for (const [r, c] of corners)
    {
        if (board[r][c] === player)
            score += 25;
        else if (board[r][c] === getOpponent(player))
            score -= 25;
    }
    
    // Edge bonus
    for (let i = 0; i < BOARD_SIZE; i++)
    {
        if (board[0][i] === player) score += 5;
        if (board[7][i] === player) score += 5;
        if (board[i][0] === player) score += 5;
        if (board[i][7] === player) score += 5;
        
        if (board[0][i] === getOpponent(player)) score -= 5;
        if (board[7][i] === getOpponent(player)) score -= 5;
        if (board[i][0] === getOpponent(player)) score -= 5;
        if (board[i][7] === getOpponent(player)) score -= 5;
    }
    
    // Mobility (number of valid moves)
    let playerMoves = 0;
    let opponentMoves = 0;
    
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        for (let col = 0; col < BOARD_SIZE; col++)
        {
            if (isValidMove(row, col, player))
                playerMoves++;
            if (isValidMove(row, col, getOpponent(player)))
                opponentMoves++;
        }
    }
    
    score += playerMoves * 2;
    score -= opponentMoves * 2;
    
    // Disc count (less important early game)
    const totalDiscs = blackScore + whiteScore;
    if (totalDiscs > 40)
    {
        if (player === DISC_BLACK)
            score += blackScore - whiteScore;
        else
            score += whiteScore - blackScore;
    }
    
    return score;
}

function findBestAIMove()
{
    let bestMove = null;
    let bestScore = -Infinity;
    
    for (const move of validMoves)
    {
        // Simulate move
        const oldBoard = board.map(row => [...row]);
        const flips = getFlipsForMove(move.row, move.col, PLAYER_AI);
        
        board[move.row][move.col] = PLAYER_AI;
        for (const flip of flips)
            board[flip.row][flip.col] = PLAYER_AI;
        
        const score = evaluateBoard(PLAYER_AI);
        
        if (score > bestScore)
        {
            bestScore = score;
            bestMove = move;
        }
        
        // Restore board
        board = oldBoard;
    }
    
    return bestMove;
}

///////////////////////////////////////////////////////////////////////////////
// RENDERING

function getCellWorldPos(row, col)
{
    const boardOffset = vec2(
        -(BOARD_SIZE * CELL_SIZE) / 2,
        -(BOARD_SIZE * CELL_SIZE) / 2
    );
    
    return vec2(
        boardOffset.x + col * CELL_SIZE + CELL_SIZE / 2,
        boardOffset.y + (BOARD_SIZE - 1 - row) * CELL_SIZE + CELL_SIZE / 2
    );
}

function worldPosToCell(worldPos)
{
    const boardOffset = vec2(
        -(BOARD_SIZE * CELL_SIZE) / 2,
        -(BOARD_SIZE * CELL_SIZE) / 2
    );
    
    const col = Math.floor((worldPos.x - boardOffset.x) / CELL_SIZE);
    const row = BOARD_SIZE - 1 - Math.floor((worldPos.y - boardOffset.y) / CELL_SIZE);
    
    if (isInBounds(row, col))
        return {row, col};
    return null;
}

function drawDisc(pos, color, scale = 1)
{
    const radius = DISC_RADIUS * scale;
    
    // Shadow
    drawCircle(pos.add(vec2(0.08, -0.08)), radius * 0.95, rgb(0, 0, 0, 0.3));
    
    if (color === DISC_BLACK)
    {
        // Black disc with highlight
        drawCircle(pos, radius, rgb(0.15, 0.15, 0.15));
        drawCircle(pos.add(vec2(-0.15, 0.15)), radius * 0.3, rgb(0.4, 0.4, 0.4, 0.6));
    }
    else
    {
        // White disc with shading
        drawCircle(pos, radius, rgb(0.95, 0.95, 0.95));
        drawCircle(pos.add(vec2(-0.15, 0.15)), radius * 0.3, rgb(1, 1, 1, 0.8));
        drawCircle(pos.add(vec2(0.1, -0.1)), radius * 0.25, rgb(0.7, 0.7, 0.7, 0.4));
    }
}

function drawFlippingDisc(pos, fromColor, toColor, progress)
{
    // Scale down and back up to create flip effect
    const scale = Math.abs(Math.cos(progress * Math.PI));
    const currentColor = progress < 0.5 ? fromColor : toColor;
    
    drawDisc(pos, currentColor, scale);
}

function drawBoard()
{
    const boardWorldSize = BOARD_SIZE * CELL_SIZE;
    const boardCenter = vec2(0, 0);
    
    // Board background
    drawRect(boardCenter, vec2(boardWorldSize + 0.4), rgb(0.1, 0.1, 0.1));
    drawRect(boardCenter, vec2(boardWorldSize), rgb(0.15, 0.5, 0.15));
    
    // Grid lines
    for (let i = 1; i < BOARD_SIZE; i++)
    {
        const offset = -(boardWorldSize / 2) + i * CELL_SIZE;
        
        // Vertical line
        drawLine(
            vec2(offset, -boardWorldSize / 2),
            vec2(offset, boardWorldSize / 2),
            0.05,
            rgb(0.1, 0.35, 0.1)
        );
        
        // Horizontal line
        drawLine(
            vec2(-boardWorldSize / 2, offset),
            vec2(boardWorldSize / 2, offset),
            0.05,
            rgb(0.1, 0.35, 0.1)
        );
    }
    
    // Corner dots
    const dots = [
        {row: 2, col: 2}, {row: 2, col: 5},
        {row: 5, col: 2}, {row: 5, col: 5}
    ];
    for (const dot of dots)
    {
        const pos = getCellWorldPos(dot.row, dot.col);
        drawCircle(pos, 0.12, rgb(0.1, 0.35, 0.1));
    }
    
    // Valid move indicators
    if (!gameOver && validMoves.length > 0)
    {
        for (const move of validMoves)
        {
            const pos = getCellWorldPos(move.row, move.col);
            const isHover = hoverCell && hoverCell.row === move.row && hoverCell.col === move.col;
            
            const color = currentPlayer === DISC_BLACK ? 
                rgb(0.3, 0.3, 0.3, isHover ? 0.6 : 0.3) : 
                rgb(0.8, 0.8, 0.8, isHover ? 0.6 : 0.3);
            
            drawCircle(pos, DISC_RADIUS * 0.4, color);
        }
    }
    
    // Discs
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        for (let col = 0; col < BOARD_SIZE; col++)
        {
            if (board[row][col] !== DISC_EMPTY)
            {
                const pos = getCellWorldPos(row, col);
                
                // Check if this disc is flipping
                const flipping = flippingDiscs.find(f => f.row === row && f.col === col);
                
                if (flipping)
                    drawFlippingDisc(pos, flipping.fromColor, board[row][col], flipping.progress);
                else
                    drawDisc(pos, board[row][col]);
            }
        }
    }
}

function drawUI()
{
    const screenSize = vec2(mainCanvasSize.x, mainCanvasSize.y);
    
    // Scores
    drawTextScreen(`Black: ${blackScore}`, vec2(30, 30), 32, WHITE, 4, BLACK, 'left');
    drawTextScreen(`White: ${whiteScore}`, vec2(30, 70), 32, WHITE, 4, BLACK, 'left');
    
    // Current player indicator
    if (!gameOver)
    {
        const playerText = gameMode === 'ai' ? 
            (currentPlayer === DISC_BLACK ? "Your Turn" : "AI Thinking...") :
            (currentPlayer === DISC_BLACK ? "Black's Turn" : "White's Turn");
        
        const color = currentPlayer === BLACK ? rgb(0.3, 0.3, 0.3) : rgb(0.95, 0.95, 0.95);
        drawTextScreen(playerText, vec2(30, 110), 28, color, 4, BLACK, 'left');
    }
    
    // Game over message
    if (gameOver)
    {
        drawTextScreen('GAME OVER', vec2(screenSize.x / 2, screenSize.y / 2 - 60), 64, 
            rgb(1, 0.8, 0), 6, BLACK);
        
        let resultText;
        let resultColor;
        
        if (winner === null)
        {
            resultText = "It's a Tie!";
            resultColor = WHITE;
        }
        else if (gameMode === 'ai')
        {
            resultText = winner === PLAYER_HUMAN ? "You Win!" : "AI Wins!";
            resultColor = winner === PLAYER_HUMAN ? rgb(0, 1, 0.3) : rgb(1, 0.3, 0.3);
        }
        else
        {
            resultText = winner === DISC_BLACK ? "Black Wins!" : "White Wins!";
            resultColor = winner === DISC_BLACK ? rgb(0.5, 0.5, 0.5) : rgb(1, 1, 1);
        }
        
        drawTextScreen(resultText, vec2(screenSize.x / 2, screenSize.y / 2), 48, 
            resultColor, 5, BLACK);
        
        drawTextScreen('Press R to restart or ESC for menu', vec2(screenSize.x / 2, screenSize.y / 2 + 60), 24, 
            WHITE, 3, BLACK);
    }
    
    // Controls
    drawTextScreen('R: Restart | ESC: Menu', vec2(screenSize.x / 2, screenSize.y - 30), 20, 
        rgb(0.7, 0.7, 0.7), 2, BLACK);
}

function drawMenu()
{
    const screenSize = vec2(mainCanvasSize.x, mainCanvasSize.y);
    
    // Title
    drawTextScreen('OTHELLO', vec2(screenSize.x / 2, 150), 80, 
        rgb(0, 0.8, 0.3), 8, BLACK);
    
    // Subtitle
    drawTextScreen('(Reversi)', vec2(screenSize.x / 2, 230), 32, 
        rgb(0.7, 0.7, 0.7), 3, BLACK);
    
    // Menu items
    const menuY = 350;
    const menuSpacing = 80;
    
    drawTextScreen('1 - Player vs AI', vec2(screenSize.x / 2, menuY), 40, 
        WHITE, 4, BLACK);
    drawTextScreen('2 - Player vs Player', vec2(screenSize.x / 2, menuY + menuSpacing), 40, 
        WHITE, 4, BLACK);
    
    // Instructions
    const instructY = screenSize.y - 150;
    drawTextScreen('How to Play:', vec2(screenSize.x / 2, instructY), 28, 
        rgb(0.8, 0.8, 0.8), 3, BLACK);
    drawTextScreen('Sandwich opponent discs to flip them', vec2(screenSize.x / 2, instructY + 40), 22, 
        rgb(0.7, 0.7, 0.7), 2, BLACK);
    drawTextScreen('Player with most discs wins!', vec2(screenSize.x / 2, instructY + 70), 22, 
        rgb(0.7, 0.7, 0.7), 2, BLACK);
}

///////////////////////////////////////////////////////////////////////////////
// GAME LOOP

let aiThinkTimer = 0;
const AI_THINK_DELAY = 0.8;

async function gameInit()
{
    setCanvasFixedSize(vec2(1280, 720));
    cameraPos = vec2(0, 0);
    
    // Create sounds
    sfxPlace = new SoundGenerator({frequency: 440, release: 0.1, volume: 0.5});
    sfxFlip = new SoundGenerator({frequency: 330, release: 0.15, slide: -0.3, volume: 0.4});
    sfxWin = new SoundGenerator({frequency: 660, release: 0.3, pitchJump: 220, pitchJumpTime: 0.1, volume: 0.6});
    sfxLose = new SoundGenerator({frequency: 220, release: 0.35, slide: -0.5, volume: 0.5});
    sfxSelect = new SoundGenerator({frequency: 550, release: 0.08, volume: 0.4});
    
    gameMode = 'menu';
}

function gameUpdate()
{
    if (gameMode === 'menu')
    {
        // Menu input
        if (keyWasPressed('Digit1'))
        {
            sfxSelect && sfxSelect.play();
            gameMode = 'ai';
            initBoard();
        }
        else if (keyWasPressed('Digit2'))
        {
            sfxSelect && sfxSelect.play();
            gameMode = 'pvp';
            initBoard();
        }
        return;
    }
    
    // Update flip animations
    for (let i = flippingDiscs.length - 1; i >= 0; i--)
    {
        flippingDiscs[i].progress += timeDelta / FLIP_DURATION;
        if (flippingDiscs[i].progress >= 1)
            flippingDiscs.splice(i, 1);
    }
    
    // Input
    if (keyWasPressed('KeyR'))
    {
        initBoard();
        aiThinkTimer = 0;
    }
    
    if (keyWasPressed('Escape'))
    {
        gameMode = 'menu';
        return;
    }
    
    if (gameOver)
        return;
    
    // Update hover cell
    hoverCell = worldPosToCell(mousePos);
    
    // AI turn
    if (gameMode === 'ai' && currentPlayer === PLAYER_AI && !gameOver && flippingDiscs.length === 0)
    {
        aiThinkTimer += timeDelta;
        if (aiThinkTimer >= AI_THINK_DELAY)
        {
            const move = findBestAIMove();
            if (move)
            {
                makeMove(move.row, move.col, PLAYER_AI);
                aiThinkTimer = 0;
            }
        }
    }
    
    // Human input
    if ((gameMode === 'pvp' || currentPlayer === PLAYER_HUMAN) && mouseWasPressed(0))
    {
        const cell = worldPosToCell(mousePos);
        if (cell && isValidMove(cell.row, cell.col, currentPlayer))
        {
            makeMove(cell.row, cell.col, currentPlayer);
            aiThinkTimer = 0;
        }
    }
}

function gameUpdatePost()
{
    cameraPos = vec2(0, 0);
}

function gameRender()
{
    // Background
    drawRect(cameraPos, vec2(100, 100), rgb(0.05, 0.05, 0.08));
    
    if (gameMode === 'menu')
        return;
    
    drawBoard();
}

function gameRenderPost()
{
    if (gameMode === 'menu')
        drawMenu();
    else
        drawUI();
}

///////////////////////////////////////////////////////////////////////////////
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body></html>
