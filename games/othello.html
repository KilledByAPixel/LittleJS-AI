<!DOCTYPE html><head>
<title>LittleJS Othello</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="../dist/littlejs.js?1.18.0"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;

gravity = vec2(0, 0);
cameraPos = vec2(0, 0);
cameraScale = 42;

// AI can use this class to make sound effects
class SoundGenerator extends Sound
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;

        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0,
            pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// OTHELLO GAME

const BOARD_SIZE = 8;
const CELL_SIZE = 1.8;
const DISC_RADIUS = 0.7;

const DISC_BLACK = 1;
const DISC_WHITE = 2;
const DISC_EMPTY = 0;

const PLAYER_HUMAN = DISC_BLACK;
const PLAYER_AI = DISC_WHITE;

// Game state
let board = [];
let currentPlayer = DISC_BLACK;
let gameOver = false;
let winner = null;
let blackScore = 2;
let whiteScore = 2;
let validMoves = [];
let gameMode = 'menu'; // 'menu', 'pvp', 'ai'
let passCount = 0;
let aiDifficulty = 'medium'; // 'easy', 'medium', 'hard'
let moveHistory = []; // For undo: {board, currentPlayer, blackScore, whiteScore}
let lastMove = null; // {row, col} for highlighting

// Animation
let flippingDiscs = []; // {row, col, progress, fromColor}
const FLIP_DURATION = 0.3;
let placingDisc = null; // {row, col, progress} for spawn animation
const PLACE_DURATION = 0.25;

// UI
let hoverCell = null;
let menuButtons = [];

// Sounds
let sfxPlace, sfxFlip, sfxWin, sfxLose, sfxSelect;

///////////////////////////////////////////////////////////////////////////////
// BOARD LOGIC

function initBoard()
{
    board = [];
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        board[row] = [];
        for (let col = 0; col < BOARD_SIZE; col++)
            board[row][col] = DISC_EMPTY;
    }
    
    // Starting position
    const mid = BOARD_SIZE / 2;
    board[mid-1][mid-1] = DISC_WHITE;
    board[mid][mid] = DISC_WHITE;
    board[mid-1][mid] = DISC_BLACK;
    board[mid][mid-1] = DISC_BLACK;
    
    currentPlayer = DISC_BLACK;
    gameOver = false;
    winner = null;
    blackScore = 2;
    whiteScore = 2;
    passCount = 0;
    flippingDiscs = [];
    moveHistory = [];
    lastMove = null;
    placingDisc = null;
    
    updateValidMoves();
}

function getOpponent(player)
{
    return player === DISC_BLACK ? DISC_WHITE : DISC_BLACK;
}

function isInBounds(row, col)
{
    return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
}

function checkDirection(row, col, player, dRow, dCol)
{
    const opponent = getOpponent(player);
    let r = row + dRow;
    let c = col + dCol;
    let hasOpponent = false;
    
    while (isInBounds(r, c))
    {
        if (board[r][c] === DISC_EMPTY)
            return [];
        
        if (board[r][c] === opponent)
        {
            hasOpponent = true;
            r += dRow;
            c += dCol;
        }
        else if (board[r][c] === player)
        {
            if (hasOpponent)
            {
                // Found valid flip sequence
                const flips = [];
                r = row + dRow;
                c = col + dCol;
                while (board[r][c] === opponent)
                {
                    flips.push({row: r, col: c});
                    r += dRow;
                    c += dCol;
                }
                return flips;
            }
            return [];
        }
    }
    
    return [];
}

function getFlipsForMove(row, col, player)
{
    if (board[row][col] !== DISC_EMPTY)
        return [];
    
    const allFlips = [];
    const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [0, -1],           [0, 1],
        [1, -1],  [1, 0],  [1, 1]
    ];
    
    for (const [dRow, dCol] of directions)
    {
        const flips = checkDirection(row, col, player, dRow, dCol);
        allFlips.push(...flips);
    }
    
    return allFlips;
}

function isValidMove(row, col, player)
{
    return getFlipsForMove(row, col, player).length > 0;
}

function updateValidMoves()
{
    validMoves = [];
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        for (let col = 0; col < BOARD_SIZE; col++)
        {
            if (isValidMove(row, col, currentPlayer))
                validMoves.push({row, col});
        }
    }
}

function makeMove(row, col, player)
{
    const flips = getFlipsForMove(row, col, player);
    if (flips.length === 0)
        return false;
    
    // Save state for undo (deep copy)
    moveHistory.push({
        board: board.map(row => [...row]),
        currentPlayer: currentPlayer,
        blackScore: blackScore,
        whiteScore: whiteScore,
        lastMove: lastMove ? {...lastMove} : null
    });
    
    board[row][col] = player;
    lastMove = {row, col};
    
    // Start placement animation
    placingDisc = {row, col, progress: 0};
    
    // Start flip animations
    for (const flip of flips)
    {
        const fromColor = board[flip.row][flip.col];
        board[flip.row][flip.col] = player;
        flippingDiscs.push({
            row: flip.row,
            col: flip.col,
            progress: 0,
            fromColor: fromColor
        });
    }
    
    updateScore();
    
    // Play sounds
    sfxPlace && sfxPlace.play(getCellWorldPos(row, col));
    if (flips.length > 0)
        sfxFlip && sfxFlip.play(getCellWorldPos(row, col));
    
    // Switch player
    currentPlayer = getOpponent(currentPlayer);
    updateValidMoves();
    
    // Check if next player has moves
    if (validMoves.length === 0)
    {
        passCount++;
        currentPlayer = getOpponent(currentPlayer);
        updateValidMoves();
        
        // If still no moves, game over
        if (validMoves.length === 0 || passCount >= 2)
            endGame();
    }
    else
    {
        passCount = 0;
    }
    
    return true;
}

function updateScore()
{
    blackScore = 0;
    whiteScore = 0;
    
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        for (let col = 0; col < BOARD_SIZE; col++)
        {
            if (board[row][col] === DISC_BLACK)
                blackScore++;
            else if (board[row][col] === DISC_WHITE)
                whiteScore++;
        }
    }
}

function undoMove()
{
    if (moveHistory.length === 0 || gameOver)
        return false;
    
    // In AI mode, undo both AI and player moves (2 states back)
    const undoCount = (gameMode === 'ai' && moveHistory.length >= 2) ? 2 : 1;
    
    for (let i = 0; i < undoCount && moveHistory.length > 0; i++)
    {
        const state = moveHistory.pop();
        board = state.board;
        currentPlayer = state.currentPlayer;
        blackScore = state.blackScore;
        whiteScore = state.whiteScore;
        lastMove = state.lastMove;
    }
    
    flippingDiscs = [];
    placingDisc = null;
    passCount = 0;
    updateValidMoves();
    sfxSelect && sfxSelect.play();
    return true;
}

function endGame()
{
    gameOver = true;
    
    if (blackScore > whiteScore)
    {
        winner = DISC_BLACK;
        if (gameMode === 'ai')
            sfxWin && sfxWin.play();
    }
    else if (whiteScore > blackScore)
    {
        winner = DISC_WHITE;
        if (gameMode === 'ai')
            sfxLose && sfxLose.play();
    }
    else
    {
        winner = null; // Tie
    }
}

///////////////////////////////////////////////////////////////////////////////
// AI

function evaluateBoard(player)
{
    let score = 0;
    
    // Corner bonus
    const corners = [[0,0], [0,7], [7,0], [7,7]];
    for (const [r, c] of corners)
    {
        if (board[r][c] === player)
            score += 25;
        else if (board[r][c] === getOpponent(player))
            score -= 25;
    }
    
    // Edge bonus
    for (let i = 0; i < BOARD_SIZE; i++)
    {
        if (board[0][i] === player) score += 5;
        if (board[7][i] === player) score += 5;
        if (board[i][0] === player) score += 5;
        if (board[i][7] === player) score += 5;
        
        if (board[0][i] === getOpponent(player)) score -= 5;
        if (board[7][i] === getOpponent(player)) score -= 5;
        if (board[i][0] === getOpponent(player)) score -= 5;
        if (board[i][7] === getOpponent(player)) score -= 5;
    }
    
    // Mobility (number of valid moves)
    let playerMoves = 0;
    let opponentMoves = 0;
    
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        for (let col = 0; col < BOARD_SIZE; col++)
        {
            if (isValidMove(row, col, player))
                playerMoves++;
            if (isValidMove(row, col, getOpponent(player)))
                opponentMoves++;
        }
    }
    
    score += playerMoves * 2;
    score -= opponentMoves * 2;
    
    // Disc count (less important early game)
    const totalDiscs = blackScore + whiteScore;
    if (totalDiscs > 40)
    {
        if (player === DISC_BLACK)
            score += blackScore - whiteScore;
        else
            score += whiteScore - blackScore;
    }
    
    return score;
}

function findBestAIMove()
{
    if (validMoves.length === 0)
        return null;
    
    // Easy: Random valid move
    if (aiDifficulty === 'easy')
        return validMoves[Math.floor(Math.random() * validMoves.length)];
    
    // Medium & Hard: Evaluate positions
    const moves = [];
    
    for (const move of validMoves)
    {
        // Simulate move
        const oldBoard = board.map(row => [...row]);
        const flips = getFlipsForMove(move.row, move.col, PLAYER_AI);
        
        board[move.row][move.col] = PLAYER_AI;
        for (const flip of flips)
            board[flip.row][flip.col] = PLAYER_AI;
        
        let score = evaluateBoard(PLAYER_AI);
        
        // Add flip count bonus for medium (values quantity)
        if (aiDifficulty === 'medium')
            score += flips.length * 3;
        
        moves.push({move, score});
        
        // Restore board
        board = oldBoard;
    }
    
    moves.sort((a, b) => b.score - a.score);
    
    // Medium: Occasionally pick 2nd or 3rd best (20% chance)
    if (aiDifficulty === 'medium' && Math.random() < 0.2 && moves.length > 1)
    {
        const idx = Math.min(Math.floor(Math.random() * 3), moves.length - 1);
        return moves[idx].move;
    }
    
    // Hard: Always best move
    return moves[0].move;
}

///////////////////////////////////////////////////////////////////////////////
// RENDERING

function getCellWorldPos(row, col)
{
    const boardOffset = vec2(
        -(BOARD_SIZE * CELL_SIZE) / 2,
        -(BOARD_SIZE * CELL_SIZE) / 2
    );
    
    return vec2(
        boardOffset.x + col * CELL_SIZE + CELL_SIZE / 2,
        boardOffset.y + (BOARD_SIZE - 1 - row) * CELL_SIZE + CELL_SIZE / 2
    );
}

function worldPosToCell(worldPos)
{
    const boardOffset = vec2(
        -(BOARD_SIZE * CELL_SIZE) / 2,
        -(BOARD_SIZE * CELL_SIZE) / 2
    );
    
    const col = Math.floor((worldPos.x - boardOffset.x) / CELL_SIZE);
    const row = BOARD_SIZE - 1 - Math.floor((worldPos.y - boardOffset.y) / CELL_SIZE);
    
    if (isInBounds(row, col))
        return {row, col};
    return null;
}

function drawDisc(pos, color, scale = 1)
{
    const radius = DISC_RADIUS * scale;
    
    // Shadow
    drawCircle(pos.add(vec2(0.08, -0.08)), radius * 2, rgb(0, 0, 0, 0.3));
    
    if (color === DISC_BLACK)
    {
        // Black disc with highlight
        drawCircle(pos, radius*2, rgb(0.15, 0.15, 0.15));
        drawCircle(pos.add(vec2(-0.15, 0.15)), radius * 0.6, rgb(0.4, 0.4, 0.4, 0.6));
    }
    else
    {
        // White disc with shading
        drawCircle(pos, radius*2, rgb(0.95, 0.95, 0.95));
        drawCircle(pos.add(vec2(-0.15, 0.15)), radius * 0.6, rgb(1, 1, 1, 0.8));
    }
}

function drawDiscFlip(pos, color, scaleX = 1, scaleY = 1)
{
    const radiusX = DISC_RADIUS * scaleX;
    const radiusY = DISC_RADIUS * scaleY;
    
    // Shadow (ellipse)
    drawEllipse(pos.add(vec2(0.08, -0.08)), vec2(radiusX * 2 * 0.95, radiusY * 2 * 0.95), rgb(0, 0, 0, 0.3));
    
    if (color === DISC_BLACK)
    {
        // Black disc with highlight
        drawEllipse(pos, vec2(radiusX * 2, radiusY * 2), rgb(0.15, 0.15, 0.15));
        drawEllipse(pos.add(vec2(-0.15 * scaleX, 0.15 * scaleY)), vec2(radiusX * 2 * 0.3, radiusY * 2 * 0.3), rgb(0.4, 0.4, 0.4, 0.6));
    }
    else
    {
        // White disc with shading
        drawEllipse(pos, vec2(radiusX * 2, radiusY * 2), rgb(0.95, 0.95, 0.95));
        drawEllipse(pos.add(vec2(-0.15 * scaleX, 0.15 * scaleY)), vec2(radiusX * 2 * 0.3, radiusY * 2 * 0.3), rgb(1, 1, 1, 0.8));
    }
}

function drawFlippingDisc(pos, fromColor, toColor, progress)
{
    // Flip effect: scale Y down to 0.1, switch color at middle, scale back up
    const minScale = 0.1;
    let scaleY;
    let currentColor;
    
    if (progress < 0.5)
    {
        // First half: scale down, old color
        scaleY = 1 - (progress * 2) * (1 - minScale);
        currentColor = fromColor;
    }
    else
    {
        // Second half: scale up, new color
        scaleY = minScale + ((progress - 0.5) * 2) * (1 - minScale);
        currentColor = toColor;
    }
    
    drawDiscFlip(pos, currentColor, 1, scaleY);
}

function drawBoard()
{
    const boardWorldSize = BOARD_SIZE * CELL_SIZE;
    const boardCenter = vec2(0, 0);
    
    // Board background
    drawRect(boardCenter, vec2(boardWorldSize + 0.4), rgb(0.1, 0.1, 0.1));
    drawRect(boardCenter, vec2(boardWorldSize), rgb(0.15, 0.5, 0.15));
    
    // Grid lines
    for (let i = 1; i < BOARD_SIZE; i++)
    {
        const offset = -(boardWorldSize / 2) + i * CELL_SIZE;
        
        // Vertical line
        drawLine(
            vec2(offset, -boardWorldSize / 2),
            vec2(offset, boardWorldSize / 2),
            0.05,
            rgb(0.1, 0.35, 0.1)
        );
        
        // Horizontal line
        drawLine(
            vec2(-boardWorldSize / 2, offset),
            vec2(boardWorldSize / 2, offset),
            0.05,
            rgb(0.1, 0.35, 0.1)
        );
    }
    
    // Last move highlight (drawn BEFORE discs so it's under them but above board) (drawn BEFORE discs so it's under them but above board)
    if (lastMove && !gameOver)
    {
        const pos = getCellWorldPos(lastMove.row, lastMove.col);
        const pulseSize = 1 + Math.sin(time * 5) * 0.12;
        drawCircle(pos, DISC_RADIUS * 2.3 * pulseSize, rgb(1, 0.9, 0.1, 0.7));
        drawCircle(pos, DISC_RADIUS * 2.1 * pulseSize, rgb(1, 1, 0.3, 0.5));
    }
    
    // Valid move indicators
    if (!gameOver && validMoves.length > 0)
    {
        for (const move of validMoves)
        {
            const pos = getCellWorldPos(move.row, move.col);
            const isHover = hoverCell && hoverCell.row === move.row && hoverCell.col === move.col;
            
            const color = currentPlayer === DISC_BLACK ? 
                rgb(0.3, 0.3, 0.3, isHover ? 0.6 : 0.3) : 
                rgb(0.8, 0.8, 0.8, isHover ? 0.6 : 0.3);
            
            drawCircle(pos, DISC_RADIUS * 0.8, color);
            
            // Show flip count on hover
            if (isHover)
            {
                const flipCount = getFlipsForMove(move.row, move.col, currentPlayer).length;
                const offsetY = 0.6;
                drawText(`+${flipCount}`, pos.add(vec2(0, offsetY)), 0.5, 
                    rgb(1, 1, 0.3), 0.15, rgb(0, 0, 0, 0.8));
            }
        }
    }
    
    // Discs
    for (let row = 0; row < BOARD_SIZE; row++)
    {
        for (let col = 0; col < BOARD_SIZE; col++)
        {
            if (board[row][col] !== DISC_EMPTY)
            {
                const pos = getCellWorldPos(row, col);
                
                // Check if this disc is flipping
                const flipping = flippingDiscs.find(f => f.row === row && f.col === col);
                
                // Check if this is the newly placed disc
                const placing = placingDisc && placingDisc.row === row && placingDisc.col === col;
                
                if (placing)
                {
                    // Scale up animation for newly placed disc
                    const scale = Math.min(placingDisc.progress * 1.3, 1);
                    drawDisc(pos, board[row][col], scale);
                }
                else if (flipping)
                    drawFlippingDisc(pos, flipping.fromColor, board[row][col], flipping.progress);
                else
                    drawDisc(pos, board[row][col]);
            }
        }
    }
}

function drawUI()
{
    const screenSize = vec2(mainCanvasSize.x, mainCanvasSize.y);
    
    // Scores
    drawTextScreen(`Black: ${blackScore}`, vec2(30, 30), 32, WHITE, 4, BLACK, 'left');
    drawTextScreen(`White: ${whiteScore}`, vec2(30, 70), 32, WHITE, 4, BLACK, 'left');
    
    // Current player indicator
    if (!gameOver)
    {
        const playerText = gameMode === 'ai' ? 
            (currentPlayer === DISC_BLACK ? "Your Turn" : "AI Thinking...") :
            (currentPlayer === DISC_BLACK ? "Black's Turn" : "White's Turn");
        
        const color = currentPlayer === BLACK ? rgb(0.3, 0.3, 0.3) : rgb(0.95, 0.95, 0.95);
        drawTextScreen(playerText, vec2(30, 110), 28, color, 4, BLACK, 'left');        
        // Show AI difficulty
        if (gameMode === 'ai')
        {
            const diffText = `AI: ${aiDifficulty.toUpperCase()}`;
            drawTextScreen(diffText, vec2(30, 145), 20, rgb(0.7, 0.7, 0.7), 2, BLACK, 'left');
        }
    }
    
    // Undo availability
    if (moveHistory.length > 0 && !gameOver)
    {
        drawTextScreen(`U: Undo (${moveHistory.length})`, vec2(30, 175), 18, 
            rgb(0.6, 0.8, 1), 2, BLACK, 'left');    }
    
    // Game over message
    if (gameOver)
    {
        drawTextScreen('GAME OVER', vec2(screenSize.x / 2, screenSize.y / 2 - 60), 64, 
            rgb(1, 0.8, 0), 6, BLACK);
        
        let resultText;
        let resultColor;
        
        if (winner === null)
        {
            resultText = "It's a Tie!";
            resultColor = WHITE;
        }
        else if (gameMode === 'ai')
        {
            resultText = winner === PLAYER_HUMAN ? "You Win!" : "AI Wins!";
            resultColor = winner === PLAYER_HUMAN ? rgb(0, 1, 0.3) : rgb(1, 0.3, 0.3);
        }
        else
        {
            resultText = winner === DISC_BLACK ? "Black Wins!" : "White Wins!";
            resultColor = winner === DISC_BLACK ? rgb(0.5, 0.5, 0.5) : rgb(1, 1, 1);
        }
        
        drawTextScreen(resultText, vec2(screenSize.x / 2, screenSize.y / 2), 48, 
            resultColor, 5, BLACK);
        
        drawTextScreen('Press R to restart or ESC for menu', vec2(screenSize.x / 2, screenSize.y / 2 + 60), 24, 
            WHITE, 3, BLACK);
    }
    
    // Controls
    const controls = gameMode === 'ai' ? 
        'U: Undo | R: Restart | D: Difficulty | ESC: Menu' :
        'U: Undo | R: Restart | ESC: Menu';
    drawTextScreen(controls, vec2(screenSize.x / 2, screenSize.y - 30), 20, 
        rgb(0.7, 0.7, 0.7), 2, BLACK);
}

function drawMenu()
{
    const screenSize = vec2(mainCanvasSize.x, mainCanvasSize.y);
    
    // Title
    drawTextScreen('OTHELLO', vec2(screenSize.x / 2, 150), 80, 
        rgb(0, 0.8, 0.3), 8, BLACK);
    
    // Subtitle
    drawTextScreen('(Reversi)', vec2(screenSize.x / 2, 230), 32, 
        rgb(0.7, 0.7, 0.7), 3, BLACK);
    
    // Menu items
    const menuY = 320;
    const menuSpacing = 70;
    
    drawTextScreen('1 - Player vs AI', vec2(screenSize.x / 2, menuY), 40, 
        WHITE, 4, BLACK);
    drawTextScreen('2 - Player vs Player', vec2(screenSize.x / 2, menuY + menuSpacing), 40, 
        WHITE, 4, BLACK);
    
    // AI Difficulty selector
    drawTextScreen('AI Difficulty:', vec2(screenSize.x / 2, menuY + menuSpacing * 2 + 20), 28, 
        rgb(0.8, 0.8, 0.8), 3, BLACK);
    
    const difficulties = ['easy', 'medium', 'hard'];
    const diffY = menuY + menuSpacing * 2 + 60;
    for (let i = 0; i < difficulties.length; i++)
    {
        const diff = difficulties[i];
        const isSelected = aiDifficulty === diff;
        const diffColor = isSelected ? rgb(0, 1, 0.5) : rgb(0.6, 0.6, 0.6);
        const label = `${i + 3} - ${diff.toUpperCase()}`;
        drawTextScreen(label, vec2(screenSize.x / 2, diffY + i * 40), 26, 
            diffColor, isSelected ? 4 : 3, BLACK);
    }
    
    // Instructions
    const instructY = screenSize.y - 150;
    drawTextScreen('How to Play:', vec2(screenSize.x / 2, instructY), 28, 
        rgb(0.8, 0.8, 0.8), 3, BLACK);
    drawTextScreen('Sandwich opponent discs to flip them', vec2(screenSize.x / 2, instructY + 40), 22, 
        rgb(0.7, 0.7, 0.7), 2, BLACK);
    drawTextScreen('Player with most discs wins!', vec2(screenSize.x / 2, instructY + 70), 22, 
        rgb(0.7, 0.7, 0.7), 2, BLACK);
}

///////////////////////////////////////////////////////////////////////////////
// GAME LOOP

let aiThinkTimer = 0;
const AI_THINK_DELAY = 0.8;

async function gameInit()
{
    setCanvasFixedSize(vec2(1280, 720));
    cameraPos = vec2(0, 0);
    
    // Create sounds
    sfxPlace = new SoundGenerator({frequency: 440, release: 0.1, volume: 0.5});
    sfxFlip = new SoundGenerator({frequency: 330, release: 0.15, slide: -0.3, volume: 0.4});
    sfxWin = new SoundGenerator({frequency: 660, release: 0.3, pitchJump: 220, pitchJumpTime: 0.1, volume: 0.6});
    sfxLose = new SoundGenerator({frequency: 220, release: 0.35, slide: -0.5, volume: 0.5});
    sfxSelect = new SoundGenerator({frequency: 550, release: 0.08, volume: 0.4});
    
    gameMode = 'menu';
}

function gameUpdate()
{
    if (gameMode === 'menu')
    {
        // Menu input
        if (keyWasPressed('Digit1'))
        {
            sfxSelect && sfxSelect.play();
            gameMode = 'ai';
            initBoard();
        }
        else if (keyWasPressed('Digit2'))
        {
            sfxSelect && sfxSelect.play();
            gameMode = 'pvp';
            initBoard();
        }
        else if (keyWasPressed('Digit3'))
        {
            sfxSelect && sfxSelect.play();
            aiDifficulty = 'easy';
        }
        else if (keyWasPressed('Digit4'))
        {
            sfxSelect && sfxSelect.play();
            aiDifficulty = 'medium';
        }
        else if (keyWasPressed('Digit5'))
        {
            sfxSelect && sfxSelect.play();
            aiDifficulty = 'hard';
        }
        return;
    }
    
    // Update flip animations
    for (let i = flippingDiscs.length - 1; i >= 0; i--)
    {
        flippingDiscs[i].progress += timeDelta / FLIP_DURATION;
        if (flippingDiscs[i].progress >= 1)
            flippingDiscs.splice(i, 1);
    }
    
    // Update placement animation
    if (placingDisc)
    {
        placingDisc.progress += timeDelta / PLACE_DURATION;
        if (placingDisc.progress >= 1)
            placingDisc = null;
    }
    
    // Input
    if (keyWasPressed('KeyR'))
    {
        initBoard();
        aiThinkTimer = 0;
    }
    
    if (keyWasPressed('KeyU'))
    {
        undoMove();
        aiThinkTimer = 0;
    }
    
    if (keyWasPressed('KeyD') && gameMode === 'ai')
    {
        const diffs = ['easy', 'medium', 'hard'];
        const idx = (diffs.indexOf(aiDifficulty) + 1) % diffs.length;
        aiDifficulty = diffs[idx];
        sfxSelect && sfxSelect.play();
    }
    
    if (keyWasPressed('Escape'))
    {
        gameMode = 'menu';
        return;
    }
    
    if (gameOver)
        return;
    
    // Update hover cell
    hoverCell = worldPosToCell(mousePos);
    
    // AI turn
    if (gameMode === 'ai' && currentPlayer === PLAYER_AI && !gameOver && flippingDiscs.length === 0)
    {
        aiThinkTimer += timeDelta;
        if (aiThinkTimer >= AI_THINK_DELAY)
        {
            const move = findBestAIMove();
            if (move)
            {
                makeMove(move.row, move.col, PLAYER_AI);
                aiThinkTimer = 0;
            }
        }
    }
    
    // Human input
    if ((gameMode === 'pvp' || currentPlayer === PLAYER_HUMAN) && mouseWasPressed(0))
    {
        const cell = worldPosToCell(mousePos);
        if (cell && isValidMove(cell.row, cell.col, currentPlayer))
        {
            makeMove(cell.row, cell.col, currentPlayer);
            aiThinkTimer = 0;
        }
    }
}

function gameUpdatePost()
{
    cameraPos = vec2(0, 0);
}

function gameRender()
{
    // Background
    drawRect(cameraPos, vec2(100, 100), rgb(0.05, 0.05, 0.08));
    
    if (gameMode === 'menu')
        return;
    
    drawBoard();
}

function gameRenderPost()
{
    if (gameMode === 'menu')
        drawMenu();
    else
        drawUI();
}

///////////////////////////////////////////////////////////////////////////////
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body></html>
