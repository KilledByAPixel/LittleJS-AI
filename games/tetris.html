<!DOCTYPE html><head>
<title>LittleJS Tetris</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="../AI/littlejs.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;
setDebugKey('Backquote'); // Use tilde key instead of Escape for debug

gravity = vec2(0, 0);
cameraPos = vec2(0, 0);
cameraScale = 42;

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// CONSTANTS

const COLS = 10;
const ROWS = 20;
const CELL = 1;

const GAP_X = 4.5;
const BOARD_SIZE = vec2(COLS*CELL, ROWS*CELL);
const LEFT_CENTER_X  = -(BOARD_SIZE.x/2 + GAP_X/2);
const RIGHT_CENTER_X = +(BOARD_SIZE.x/2 + GAP_X/2);
const BOARD_BOTTOM_Y = -10;
const START_GRAVITY = 2;  // cells per second (doubled from 1)
const SOFT_DROP_MULT = 24;
const LOCK_DELAY = .25; // time before piece locks after touching ground
const MOVE_DAS = .14;
const MOVE_ARR = .045;
const NEXT_COUNT = 4;

// Line clear "chain" animation
const CLEAR_STEP_TIME = .03;

// Particles
const PARTICLE_LIFE = .45;
const PARTICLES_PER_CELL = 10;

// Sparkles (tiny ambient particles on pieces)
const SPARKLE_LIFE = .35;
const SPARKLE_RATE = 22;          // approx sparkles per second per active piece
const SPARKLE_SIZE_MIN = .04;
const SPARKLE_SIZE_MAX = .11;

// VS / Garbage
const GARBAGE_TYPE = 7;
const GARBAGE_COLOR = rgb(.35,.35,.38);
const ATTACK_TABLE = [0, 0, 1, 2, 4]; // cleared lines -> garbage lines

// Screen shake
let screenShake = vec2(0, 0);
let screenShakeTime = 0;
let screenShakeType = 'none'; // 'drop' or 'garbage'
let renderShakeOffset = vec2(0, 0); // Applied during rendering

// AI (human-ish)
const AI_THINK_DELAY_MIN = .04;
const AI_THINK_DELAY_MAX = .11;
const AI_ACTION_INTERVAL_MIN = .02;
const AI_ACTION_INTERVAL_MAX = .05;
const AI_DROP_DELAY_MIN = .025;
const AI_DROP_DELAY_MAX = .10;
const AI_SOFT_DROP_CHANCE = .35;
const AI_MISTAKE_CHANCE = .04; // occasionally choose 2nd-best-ish

///////////////////////////////////////////////////////////////////////////////
// PIECES

const PIECES = [
    { name:'I', color:hsl(.55, .9, .55), rots:[
        [vec2(-2,0), vec2(-1,0), vec2(0,0), vec2(1,0)],
        [vec2(0,-1), vec2(0,0), vec2(0,1), vec2(0,2)],
        [vec2(-2,1), vec2(-1,1), vec2(0,1), vec2(1,1)],
        [vec2(-1,-1), vec2(-1,0), vec2(-1,1), vec2(-1,2)],
    ]},
    { name:'O', color:hsl(.14, .9, .55), rots:[
        [vec2(0,0), vec2(1,0), vec2(0,1), vec2(1,1)],
        [vec2(0,0), vec2(1,0), vec2(0,1), vec2(1,1)],
        [vec2(0,0), vec2(1,0), vec2(0,1), vec2(1,1)],
        [vec2(0,0), vec2(1,0), vec2(0,1), vec2(1,1)],
    ]},
    { name:'T', color:hsl(.84, .75, .6), rots:[
        [vec2(-1,0), vec2(0,0), vec2(1,0), vec2(0,1)],
        [vec2(0,-1), vec2(0,0), vec2(0,1), vec2(1,0)],
        [vec2(-1,0), vec2(0,0), vec2(1,0), vec2(0,-1)],
        [vec2(0,-1), vec2(0,0), vec2(0,1), vec2(-1,0)],
    ]},
    { name:'S', color:hsl(.33, .9, .55), rots:[
        // S piece (CW rotation uses (x,y)->(y,-x))
        [vec2(-1,0), vec2(0,0), vec2(0,1), vec2(1,1)],
        [vec2(0,1), vec2(0,0), vec2(1,0), vec2(1,-1)],
        [vec2(1,0), vec2(0,0), vec2(0,-1), vec2(-1,-1)],
        [vec2(0,-1), vec2(0,0), vec2(-1,0), vec2(-1,1)],
    ]},
    { name:'Z', color:hsl(.02, .9, .6), rots:[
        // Z piece
        [vec2(-1,1), vec2(0,1), vec2(0,0), vec2(1,0)],
        [vec2(1,1), vec2(1,0), vec2(0,0), vec2(0,-1)],
        [vec2(1,-1), vec2(0,-1), vec2(0,0), vec2(-1,0)],
        [vec2(-1,-1), vec2(-1,0), vec2(0,0), vec2(0,1)],
    ]},

    { name:'J', color:hsl(.62, .85, .58), rots:[
        [vec2(-1,0), vec2(0,0), vec2(1,0), vec2(-1,1)],
        [vec2(0,-1), vec2(0,0), vec2(0,1), vec2(1,1)],
        [vec2(-1,0), vec2(0,0), vec2(1,0), vec2(1,-1)],
        [vec2(0,-1), vec2(0,0), vec2(0,1), vec2(-1,-1)],
    ]},
    { name:'L', color:hsl(.08, .9, .6), rots:[
        [vec2(-1,0), vec2(0,0), vec2(1,0), vec2(1,1)],
        [vec2(0,-1), vec2(0,0), vec2(0,1), vec2(1,-1)],
        [vec2(-1,0), vec2(0,0), vec2(1,0), vec2(-1,-1)],
        [vec2(0,-1), vec2(0,0), vec2(0,1), vec2(-1,1)],
    ]},
];

const KICKS = [vec2(0,0), vec2(-1,0), vec2(1,0), vec2(0,1), vec2(-2,0), vec2(2,0)];

///////////////////////////////////////////////////////////////////////////////
// GLOBAL STATE

let gameState = 'menu'; // 'menu' or 'playing'
let gameMode = 'vs';    // 'single' or 'vs'

// Menu UI elements (title drawn manually for animation)
let btnSinglePlayer, btnVsAI, menuInstructions;

// Menu background animation
let menuBgPieces = [];
let menuSpawnTimer = 0;
const MENU_SPAWN_RATE = 0.4; // seconds between spawns
const MENU_FALL_SPEED = 3; // cells per second

let players = []; // [human, ai]
let particles = [];

// sounds
let sMove, sRotate, sDrop, sLock, sClear, sHold, sOver, sGarbage, sSelect;

///////////////////////////////////////////////////////////////////////////////
// HELPERS

function frand(min=0, max=1){ return min + Math.random()*(max-min); }
function clamp01(x){ return x < 0 ? 0 : x > 1 ? 1 : x; }

function clamp(x, a, b){ return x < a ? a : x > b ? b : x; }
function shadeColor(c, amount)
{
    // amount: -1..+1 (negative darkens)
    const out = c.copy();
    out.r = clamp(out.r + amount, 0, 1);
    out.g = clamp(out.g + amount, 0, 1);
    out.b = clamp(out.b + amount, 0, 1);
    return out;
}

function withAlpha(c, a)
{
    const out = c.copy();
    out.a = a;
    return out;
}

function getBlocks(type, rot){ return PIECES[type].rots[mod(rot,4)]; }

function makeEmptyBoard()
{
    const b = [];
    for (let y=0; y<ROWS; ++y)
    {
        const row = [];
        for (let x=0; x<COLS; ++x) row.push(-1);
        b.push(row);
    }
    return b;
}

function cloneBoard(src)
{
    const out = [];
    for (let y=0; y<ROWS; ++y) out.push(src[y].slice());
    return out;
}

function fitsType(type, rot, pos, boardRef)
{
    const b = getBlocks(type, rot);
    for (const p of b)
    {
        const x = (pos.x + p.x) | 0;
        const y = (pos.y + p.y) | 0;
        if (x < 0 || x >= COLS || y < 0) return false;
        if (y < ROWS && boardRef[y][x] != -1) return false;
    }
    return true;
}

function worldFromCell(player, cx, cy)
{
    return player.boardPos.add(vec2((cx + .5)*CELL, (cy + .5)*CELL)).add(renderShakeOffset);
}

function drawBlock3D(pos, size, color)
{
    // size is side length (world units)
    const base = color.copy();
    const hi   = shadeColor(color, .18);
    const hi2  = shadeColor(color, .28);
    const sh   = shadeColor(color, -.18);
    const sh2  = shadeColor(color, -.28);

    // proportional styling so previews match in feel
    const outline = size * .09;
    const bevel   = size * .22;
    const inner   = size - bevel;

    // outer outline
    drawRect(pos, vec2(size + outline), withAlpha(rgb(0,0,0), base.a));

    // base
    drawRect(pos, vec2(size), base);

    // top highlight strip
    drawRect(pos.add(vec2(0, inner/2)), vec2(size - outline*0.7, bevel), withAlpha(hi2, base.a));
    // left highlight strip
    drawRect(pos.add(vec2(-inner/2, 0)), vec2(bevel, size - outline*0.7), withAlpha(hi, base.a));

    // bottom shadow strip
    drawRect(pos.add(vec2(0, -inner/2)), vec2(size - outline*0.7, bevel), withAlpha(sh2, base.a));
    // right shadow strip
    drawRect(pos.add(vec2(inner/2, 0)), vec2(bevel, size - outline*0.7), withAlpha(sh, base.a));

    // tiny specular corner
    drawRect(pos.add(vec2(-inner/2 + bevel*0.55, inner/2 - bevel*0.55)), vec2(bevel*0.75), withAlpha(rgb(1,1,1), .12*base.a));
}

function drawCell(player, cx, cy, color, pad=.06)
{
    // Same 3D treatment everywhere (board blocks + previews)
    const pos = worldFromCell(player, cx, cy);
    const size = CELL - pad*2;
    drawBlock3D(pos, size, color);
}

function drawMiniCell(pos, color)
{
    // Mini preview version uses the exact same block renderer
    drawBlock3D(pos, .88, color);
}

function shuffleBag()
{
    const bag = [0,1,2,3,4,5,6];
    for (let i=bag.length-1; i>0; --i)
    {
        const j = randInt(i+1);
        const t = bag[i]; bag[i] = bag[j]; bag[j] = t;
    }
    return bag;
}

function takeFromBag(player)
{
    if (!player.nextBag.length)
        player.nextBag = shuffleBag();
    return player.nextBag.pop();
}

function ensureNextQueue(player)
{
    while (player.nextQueue.length < NEXT_COUNT)
        player.nextQueue.push(takeFromBag(player));
}

function findFullRows(boardRef)
{
    const rows = [];
    for (let y=0; y<ROWS; ++y)
    {
        let full = true;
        for (let x=0; x<COLS; ++x)
            if (boardRef[y][x] == -1) { full = false; break; }
        if (full) rows.push(y);
    }
    return rows;
}

function applyClearRows(rows, boardRef)
{
    if (!rows.length) return;

    const set = new Set(rows);
    const newBoard = [];

    for (let y=0; y<ROWS; ++y)
        if (!set.has(y))
            newBoard.push(boardRef[y]);

    while (newBoard.length < ROWS)
    {
        const row = [];
        for (let x=0; x<COLS; ++x) row.push(-1);
        newBoard.push(row);
    }

    for (let y=0; y<ROWS; ++y)
        boardRef[y] = newBoard[y];
}

function addGarbage(player, count)
{
    for (let i=0; i<count; ++i)
    {
        // push everything up by 1: drop top row, shift up, insert garbage at bottom
        for (let y=ROWS-1; y>0; --y)
            for (let x=0; x<COLS; ++x)
                player.board[y][x] = player.board[y-1][x];

        // new bottom garbage row
        const hole = randInt(COLS);
        for (let x=0; x<COLS; ++x)
            player.board[0][x] = (x === hole) ? -1 : GARBAGE_TYPE;
    }

    sGarbage && sGarbage.play(player.boardCenter);
    
    // Screen shake for receiving garbage (side to side) - only for human
    if (!player.isAI)
        startScreenShake('garbage', 0.2 + count * 0.05);
}

// Garbage cancellation: attacks remove queued incoming first
function applyGarbageCancellation(player, attack)
{
    const cancel = Math.min(attack, player.pendingGarbage);
    player.pendingGarbage -= cancel;
    return attack - cancel;
}

function startScreenShake(type, duration)
{
    screenShakeType = type;
    screenShakeTime = duration;
}

function updateScreenShake(dt)
{
    if (screenShakeTime <= 0)
    {
        screenShake = vec2(0, 0);
        return;
    }
    
    screenShakeTime -= dt;
    const t = screenShakeTime / 0.3; // normalize to 0-1 range (based on duration)
    
    if (screenShakeType === 'drop')
    {
        // Downward impact shake
        const intensity = t * t; // quadratic falloff
        screenShake = vec2(
            rand(-0.4, 0.4) * intensity,
            -0.6 * intensity
        );
    }
    else if (screenShakeType === 'garbage')
    {
        // Side to side shake
        const intensity = t;
        screenShake = vec2(
            Math.sin(screenShakeTime * 50) * 0.5 * intensity,
            rand(-0.2, 0.2) * intensity
        );
    }
}

///////////////////////////////////////////////////////////////////////////////
// PARTICLES

function spawnCellParticles(player, cellX, cellY, baseColor)
{
    const p0 = worldFromCell(player, cellX, cellY);
    const c = baseColor.copy();

    for (let i=0; i<PARTICLES_PER_CELL; ++i)
    {
        const a = frand(0, Math.PI*2);
        const speed = frand(3, 8);
        const vel = vec2(Math.cos(a), Math.sin(a)).scale(speed);

        particles.push({
            kind: 'burst',
            pos: p0.add(vec2(frand(-.25,.25), frand(-.25,.25))),
            vel: vel.add(vec2(0, frand(1,4))),
            life: PARTICLE_LIFE,
            lifeMax: PARTICLE_LIFE,
            size: frand(.08, .22),
            color: c,
        });
    }
}

function spawnSparkleAt(pos, color)
{
    const vel = vec2(frand(-1.1, 1.1), frand(0.2, 2.4));
    const size = frand(SPARKLE_SIZE_MIN, SPARKLE_SIZE_MAX);
    particles.push({
        kind: 'sparkle',
        pos: pos.add(vec2(frand(-.28,.28), frand(-.28,.28))),
        vel,
        life: SPARKLE_LIFE,
        lifeMax: SPARKLE_LIFE,
        size,
        size0: size,
        color: withAlpha(shadeColor(color, .25), 1),
        tw: frand(0, 6.28),
        aMul: 1,
    });
}

function stepPieceSparkles(p, dt)
{
    if (!p.cur || p.gameOver || p.clearAnim) return;

    // spawn a few sparkles over time around the active piece
    p.sparkleAcc += dt * SPARKLE_RATE;
    while (p.sparkleAcc >= 1)
    {
        p.sparkleAcc -= 1;

        const blocks = getBlocks(p.cur.type, p.cur.rot);
        const b = blocks[randInt(blocks.length)];
        const cx = (p.cur.pos.x + b.x) | 0;
        const cy = (p.cur.pos.y + b.y) | 0;
        if (cx < 0 || cx >= COLS || cy < 0 || cy >= ROWS) continue;

        const baseColor = PIECES[p.cur.type].color;
        spawnSparkleAt(worldFromCell(p, cx, cy), baseColor);
    }
}

function spawnLockSparkles(p)
{
    const blocks = getBlocks(p.cur.type, p.cur.rot);
    const baseColor = PIECES[p.cur.type].color;
    for (const b of blocks)
    {
        const cx = (p.cur.pos.x + b.x) | 0;
        const cy = (p.cur.pos.y + b.y) | 0;
        if (cx < 0 || cx >= COLS || cy < 0 || cy >= ROWS) continue;
        // small burst of sparkles on lock
        for (let i=0; i<3; ++i)
            spawnSparkleAt(worldFromCell(p, cx, cy), baseColor);
    }
}


function updateParticles(dt)
{
    const gBurst = -14;
    const gSpark = -3;

    for (let i=particles.length-1; i>=0; --i)
    {
        const p = particles[i];
        p.life -= dt;
        if (p.life <= 0)
        {
            particles.splice(i,1);
            continue;
        }

        const t = p.lifeMax ? (p.life / p.lifeMax) : 1;

        if (p.kind === 'sparkle')
        {
            // float and drift
            p.vel = p.vel.add(vec2(0, gSpark*dt));
            p.vel = p.vel.scale(0.992);

            // mild twinkle
            p.tw = (p.tw || frand(0, 6.28)) + dt*9;
            p.aMul = .6 + .4*Math.sin(p.tw);

            // shrink a bit
            p.size = p.size0 ? (p.size0 * (0.7 + 0.3*t)) : p.size;
        }
        else
        {
            // juicy burst
            p.vel = p.vel.add(vec2(0, gBurst*dt));
            p.vel = p.vel.scale(0.985);
        }

        p.pos = p.pos.add(p.vel.scale(dt));
    }
}


function renderParticles()
{
    for (const p of particles)
    {
        const t = p.lifeMax ? clamp01(p.life / p.lifeMax) : 1;
        const c = p.color.copy();

        if (p.kind === 'sparkle')
        {
            c.a *= t * (p.aMul || 1);
            // bright core + faint glow
            drawRect(p.pos, vec2(p.size), c);
            drawRect(p.pos, vec2(p.size*2.2), withAlpha(rgb(1,1,1), c.a*.15));
        }
        else
        {
            c.a *= t;
            drawRect(p.pos, vec2(p.size), c);
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
// PLAYER MODEL

function makePlayer(name, boardCenterX, isAI)
{
    const boardPos = vec2(boardCenterX - BOARD_SIZE.x/2, BOARD_BOTTOM_Y);
    const boardCenter = boardPos.add(BOARD_SIZE.scale(.5));

    // UI positions per side
    const uiX = isAI ? (boardPos.x + BOARD_SIZE.x + 3.2) : (boardPos.x - 3.2);
    const uiPos = vec2(uiX, boardPos.y + BOARD_SIZE.y - 1.2);

    return {
        name,
        isAI,

        board: makeEmptyBoard(),
        cur: null,

        nextBag: [],
        nextQueue: [],
        holdType: -1,
        holdUsed: false,

        score: 0,
        lines: 0,
        level: 1,
        gameOver: false,

        moveDir: 0,
        moveTimer: 0,
        arrTimer: 0,

        fallAcc: 0,
        lockTimer: -1,

        clearAnim: null, // {rows, col, timer, clearedCount}

        pendingGarbage: 0,

        // AI state
        aiEnabled: isAI,
        aiPlan: null,         // {rot, x}
        aiStepTimer: 0,
        aiThinkTimer: 0,
        aiDropTimer: 0,
        aiSoftMode: false,

        // sparkles
        sparkleAcc: 0,

        // placement / layout
        boardPos,
        boardCenter,
        uiPos,
        boardCenterX,
    };
}

function resetPlayer(p)
{
    p.board = makeEmptyBoard();

    p.nextBag = [];
    p.nextQueue = [];
    ensureNextQueue(p);

    p.holdType = -1;
    p.holdUsed = false;
    p.score = 0;
    p.lines = 0;
    p.level = 1;
    p.gameOver = false;
    p.sparkleAcc = 0;
    p.moveDir = 0;
    p.moveTimer = 0;
    p.arrTimer = 0;
    p.fallAcc = 0;
    p.lockTimer = -1;
    p.clearAnim = null;
    p.pendingGarbage = 0;
    p.aiPlan = null;
    p.aiStepTimer = 0;
    p.aiThinkTimer = frand(AI_THINK_DELAY_MIN, AI_THINK_DELAY_MAX);
    p.aiDropTimer = 0;
    p.aiSoftMode = false;

    spawnPiece(p);
}

function gravityCellsPerSecond(p)
{
    return START_GRAVITY * (1 + (p.level-1)*.15);
}

function spawnPiece(p, type)
{
    if (p.gameOver) return;

    // Apply pending garbage right before a new piece spawns
    if (p.pendingGarbage > 0)
    {
        addGarbage(p, p.pendingGarbage);
        p.pendingGarbage = 0;
    }

    if (type === undefined)
    {
        ensureNextQueue(p);
        type = p.nextQueue.shift();
        ensureNextQueue(p);
    }

    p.cur = {
        type,
        rot: 0,
        pos: vec2(4, ROWS-2),
    };

    p.holdUsed = false;
    p.lockTimer = -1;

    if (!fitsType(p.cur.type, p.cur.rot, p.cur.pos, p.board))
    {
        // Keep cur set so the piece is visible at spawn position
        p.gameOver = true;
        sOver && sOver.play(p.boardCenter);
        return; // Don't reset AI state, game is over
    }

    // AI new-piece think
    p.aiPlan = null;
    p.aiThinkTimer = frand(AI_THINK_DELAY_MIN, AI_THINK_DELAY_MAX);
    p.aiDropTimer = 0;
    p.aiSoftMode = (Math.random() < AI_SOFT_DROP_CHANCE);
}

function tryMove(p, dx, dy)
{
    if (p.gameOver || p.clearAnim) return false;
    const np = p.cur.pos.add(vec2(dx,dy));
    if (!fitsType(p.cur.type, p.cur.rot, np, p.board))
        return false;

    p.cur.pos = np;
    if (dy) p.lockTimer = -1; // only dropping resets lock timer
    return true;
}

function tryRotate(p, dir)
{
    if (p.gameOver || p.clearAnim) return false;
    const nr = mod(p.cur.rot + dir, 4);
    for (const k of KICKS)
    {
        const np = p.cur.pos.add(k);
        if (fitsType(p.cur.type, nr, np, p.board))
        {
            p.cur.rot = nr;
            p.cur.pos = np;
            sRotate && sRotate.play(p.boardCenter);
            return true;
        }
    }
    return false;
}

function hardDrop(p)
{
    if (p.gameOver || p.clearAnim) return;
    let dropped = 0;
    while (tryMove(p, 0, -1)) dropped++;
    if (dropped) sDrop && sDrop.play(p.boardCenter);
    
    // Screen shake on hard drop (downward impact) - only for human
    if (!p.isAI)
        startScreenShake('drop', 0.3);
    
    lockPiece(p, true);
}

function lockPiece(p, fromHardDrop=false)
{
    if (p.gameOver || p.clearAnim) return;

    const blocks = getBlocks(p.cur.type, p.cur.rot);
    for (const b of blocks)
    {
        const x = (p.cur.pos.x + b.x) | 0;
        const y = (p.cur.pos.y + b.y) | 0;
        if (y >= ROWS) continue;
        if (y < 0) { p.gameOver = true; break; }
        p.board[y][x] = p.cur.type;
    }
    
    // Screen shake on any piece lock (smaller for soft drop)
    if (!p.isAI && !fromHardDrop)
        startScreenShake('drop', 0.15);

    sLock && sLock.play(p.boardCenter);
    spawnLockSparkles(p);

    const rows = findFullRows(p.board);
    if (rows.length)
    {
        startClearAnim(p, rows);
        return;
    }

    if (fromHardDrop) p.score += 2;

    spawnPiece(p);
}

function hold(p)
{
    if (p.gameOver || p.holdUsed || p.clearAnim) return;

    const t = p.cur.type;
    if (p.holdType == -1)
    {
        p.holdType = t;
        spawnPiece(p);
    }
    else
    {
        const swap = p.holdType;
        p.holdType = t;
        spawnPiece(p, swap);
    }

    p.holdUsed = true;
    sHold && sHold.play(p.boardCenter);
}

///////////////////////////////////////////////////////////////////////////////
// CLEAR ANIMATION + VS ATTACK

function startClearAnim(p, rows)
{
    p.clearAnim = { rows, col: 0, timer: 0, clearedCount: rows.length };
    sClear && sClear.play(p.boardCenter);
}

function stepClearAnim(p, opponent, dt)
{
    if (!p.clearAnim) return;

    p.clearAnim.timer += dt;
    while (p.clearAnim && p.clearAnim.timer >= CLEAR_STEP_TIME)
    {
        p.clearAnim.timer -= CLEAR_STEP_TIME;

        const x = p.clearAnim.col;
        for (const y of p.clearAnim.rows)
        {
            const t = p.board[y][x];
            if (t != -1)
            {
                const color = (t === GARBAGE_TYPE) ? GARBAGE_COLOR : PIECES[t].color;
                spawnCellParticles(p, x, y, color);
                p.board[y][x] = -1;
            }
        }

        p.clearAnim.col++;
        if (p.clearAnim.col >= COLS)
        {
            const cleared = p.clearAnim.clearedCount;
            const rowsToRemove = p.clearAnim.rows;
            p.clearAnim = null;

            // collapse
            applyClearRows(rowsToRemove, p.board);

            // scoring
            const table = [0, 100, 300, 500, 800];
            p.score += (table[cleared] || (cleared*200)) * p.level;
            p.lines += cleared;
            p.level = 1 + (p.lines/10|0);

            // send garbage (with cancellation)
            let attack = ATTACK_TABLE[cleared] || 0;
            if (attack)
            {
                // cancel incoming first (classic VS behavior)
                attack = applyGarbageCancellation(p, attack);

                // then send any remaining to opponent
                if (attack && opponent && !opponent.gameOver)
                    opponent.pendingGarbage += attack;
            }

            spawnPiece(p);
            break;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// AI

function computeDropY(type, rot, x, boardRef)
{
    let y = ROWS + 6;
    while (!fitsType(type, rot, vec2(x,y), boardRef) && y > 0)
        y--;
    if (!fitsType(type, rot, vec2(x,y), boardRef))
        return null;

    while (fitsType(type, rot, vec2(x,y-1), boardRef))
        y--;

    // reject placements above top
    const blocks = getBlocks(type, rot);
    for (const b of blocks)
        if ((y + b.y) >= ROWS)
            return null;

    return y;
}

function placeOnBoard(type, rot, x, y, boardRef)
{
    const blocks = getBlocks(type, rot);
    for (const b of blocks)
    {
        const cx = (x + b.x) | 0;
        const cy = (y + b.y) | 0;
        if (cy < 0) return false;
        if (cy >= ROWS) continue;
        if (cx < 0 || cx >= COLS) return false;
        if (boardRef[cy][cx] != -1) return false;
        boardRef[cy][cx] = type;
    }
    return true;
}

function boardStats(boardRef)
{
    const heights = new Array(COLS).fill(0);
    let holes = 0;

    for (let x=0; x<COLS; ++x)
    {
        let top = -1;
        for (let y=ROWS-1; y>=0; --y)
            if (boardRef[y][x] != -1) { top = y; break; }

        heights[x] = top + 1;

        if (top >= 0)
            for (let y=0; y<top; ++y)
                if (boardRef[y][x] == -1) holes++;
    }

    let aggHeight = 0;
    let bump = 0;
    let maxH = 0;
    for (let x=0; x<COLS; ++x)
    {
        const h = heights[x];
        aggHeight += h;
        maxH = h > maxH ? h : maxH;
        if (x) bump += Math.abs(h - heights[x-1]);
    }

    return { aggHeight, bump, maxH, holes, heights };
}

function isSurvivalMode(boardRef)
{
    // Survival mode when board is halfway full - go for any clear
    const s = boardStats(boardRef);
    return s.maxH >= 10 || s.holes >= 12; // halfway up = survival
}

// Check if column x is a "well" (lower than neighbors, good for Tetris)
function getWellDepth(heights, x)
{
    const h = heights[x];
    const leftH = x > 0 ? heights[x-1] : 99;
    const rightH = x < COLS-1 ? heights[x+1] : 99;
    // A well is a column lower than both neighbors
    if (h < leftH && h < rightH)
        return Math.min(leftH, rightH) - h;
    return 0;
}

function evalBoard(boardRef, linesCleared, survival)
{
    const s = boardStats(boardRef);

    // In normal mode: penalize single clears, strongly reward multi-clears
    // Single clear = 0 garbage sent, wastes potential!
    // In survival mode: any clear is good
    const clearBonus = survival 
        ? [0, 400, 1200, 2200, 4000]   // survival: all clears are good
        : [0, -200, 1200, 2500, 5000]; // normal: penalize singles, reward multi
    
    const lineBonus = clearBonus[linesCleared] || 0;

    // Well bonus: reward having exactly one deep well (Tetris setup)
    // Only in normal mode when safe
    let wellBonus = 0;
    if (!survival)
    {
        // Find the deepest well
        let bestWell = 0;
        let wellCount = 0;
        for (let x = 0; x < COLS; x++)
        {
            const depth = getWellDepth(s.heights, x);
            if (depth >= 3)
            {
                wellCount++;
                bestWell = Math.max(bestWell, depth);
            }
        }
        // Reward having exactly one good well (edge wells are best for I-piece)
        if (wellCount === 1 && bestWell >= 3)
        {
            // Bonus for well depth (encourages building up for Tetris)
            wellBonus = Math.min(bestWell, 4) * 80;
            // Extra bonus if well is on the edge (easier I-piece placement)
            const leftWell = getWellDepth(s.heights, 0) >= 3;
            const rightWell = getWellDepth(s.heights, COLS-1) >= 3;
            if (leftWell || rightWell) wellBonus += 150;
        }
        else if (wellCount > 1)
        {
            // Penalize multiple wells (messy board)
            wellBonus = -100 * wellCount;
        }
    }

    const holesW = survival ? 130 : 95;
    const aggW   = survival ? 12  : 6;  // Less penalty for height in normal mode (build up for Tetris)
    const bumpW  = survival ? 16  : 10;
    const maxW   = survival ? 16  : 5;

    return lineBonus + wellBonus - s.holes*holesW - s.aggHeight*aggW - s.bump*bumpW - s.maxH*maxW;
}

const I_PIECE = 0; // I-piece is type 0

// Find the best Tetris (4-line clear) opportunity for a given piece type
// Returns {rot, x, lines} or null if no Tetris possible
function findTetrisOpportunity(type, boardRef)
{
    for (let rot = 0; rot < 4; ++rot)
    for (let x = -4; x < COLS + 4; ++x)
    {
        const y = computeDropY(type, rot, x, boardRef);
        if (y === null) continue;

        const b2 = cloneBoard(boardRef);
        if (!placeOnBoard(type, rot, x, y, b2)) continue;

        const rows = findFullRows(b2);
        if (rows.length === 4)
            return { rot, x, lines: 4 };
    }
    return null;
}

function computeBestMove(type, boardRef)
{
    // Decide whether we are in "survival mode" based on the CURRENT board (not the hypothetical).
    const survival = isSurvivalMode(boardRef);

    // gather a small list of top candidates
    const candidates = [];

    for (let rot=0; rot<4; ++rot)
    for (let x=-4; x<COLS+4; ++x)
    {
        const y = computeDropY(type, rot, x, boardRef);
        if (y === null) continue;

        const b2 = cloneBoard(boardRef);
        if (!placeOnBoard(type, rot, x, y, b2)) continue;

        const rows = findFullRows(b2);
        const cleared = rows.length;
        if (cleared) applyClearRows(rows, b2);

        const v = evalBoard(b2, cleared, survival);
        candidates.push({rot, x, v, cleared});
    }

    if (!candidates.length) return null;
    candidates.sort((a,b)=>b.v-a.v);

    // If we can do a Tetris, ALWAYS do it (no mistakes)
    const tetrisMove = candidates.find(c => c.cleared === 4);
    if (tetrisMove)
        return tetrisMove;

    // human-ish mistakes: sometimes pick 2nd/3rd best
    const pickIndex = (Math.random() < AI_MISTAKE_CHANCE) ? Math.min(2, candidates.length-1) : 0;
    return candidates[pickIndex];
}

function planAI(p)
{
    if (!p.aiEnabled || p.gameOver || p.clearAnim) return;
    if (p.aiPlan) return;

    p.aiThinkTimer -= timeDelta;
    if (p.aiThinkTimer > 0)
        return;

    const survival = isSurvivalMode(p.board);

    // Check if current piece can do a Tetris
    const currentTetris = findTetrisOpportunity(p.cur.type, p.board);
    if (currentTetris)
    {
        // Always go for Tetris!
        p.aiPlan = { rot: currentTetris.rot, x: currentTetris.x };
        p.aiStepTimer = frand(AI_ACTION_INTERVAL_MIN, AI_ACTION_INTERVAL_MAX);
        return;
    }
    
    // Check if hold piece (or next piece if no hold) can do a Tetris
    if (!p.holdUsed)
    {
        const holdType = p.holdType >= 0 ? p.holdType : p.nextQueue[0];
        const holdTetris = findTetrisOpportunity(holdType, p.board);
        if (holdTetris)
        {
            // Swap to hold piece and do the Tetris!
            p.aiPlan = { rot: holdTetris.rot, x: holdTetris.x, useHold: true };
            p.aiStepTimer = frand(AI_ACTION_INTERVAL_MIN, AI_ACTION_INTERVAL_MAX);
            return;
        }
    }
    
    // Strategic hold: save I-piece for later Tetris (only when not in survival mode)
    if (!survival && !p.holdUsed && p.cur.type === I_PIECE)
    {
        // Only hold if we don't already have an I-piece in hold
        if (p.holdType !== I_PIECE)
        {
            // Hold the I-piece for later
            p.aiPlan = { rot: 0, x: 0, useHold: true };
            p.aiStepTimer = frand(AI_ACTION_INTERVAL_MIN, AI_ACTION_INTERVAL_MAX);
            return;
        }
    }

    // No Tetris available, use normal best move
    const best = computeBestMove(p.cur.type, p.board);
    if (best)
        p.aiPlan = { rot: best.rot, x: best.x };
    else
        p.aiPlan = { rot: p.cur.rot, x: p.cur.pos.x };

    p.aiStepTimer = frand(AI_ACTION_INTERVAL_MIN, AI_ACTION_INTERVAL_MAX);
}

function stepAI(p, dt)
{
    if (!p.aiEnabled || p.gameOver || p.clearAnim) return;

    planAI(p);
    if (!p.aiPlan) return;

    p.aiStepTimer -= dt;
    if (p.aiStepTimer > 0)
        return;
    p.aiStepTimer = frand(AI_ACTION_INTERVAL_MIN, AI_ACTION_INTERVAL_MAX);

    // If plan says to use hold, do it first
    if (p.aiPlan && p.aiPlan.useHold && !p.holdUsed)
    {
        hold(p);
        // Clear plan so it will re-plan with the new piece
        p.aiPlan = null;
        return;
    }
    
    if (!p.aiPlan) return;

    // rotate to target (CW only)
    const rotDelta = mod(p.aiPlan.rot - p.cur.rot, 4);
    if (rotDelta)
    {
        if (!tryRotate(p, 1))
            p.aiPlan = null;
        return;
    }

    // move to target x
    const dx = p.aiPlan.x - p.cur.pos.x;
    if (dx)
    {
        const step = dx > 0 ? 1 : -1;
        if (!tryMove(p, step, 0))
            p.aiPlan = null;
        return;
    }

    // aligned and in position: use soft drop (gravity-based, not instant)
    const cps = gravityCellsPerSecond(p) * SOFT_DROP_MULT;
    p.fallAcc += cps * dt;
    
    while (p.fallAcc >= 1)
    {
        p.fallAcc -= 1;
        if (!tryMove(p, 0, -1))
        {
            // lock when grounded
            if (p.lockTimer < 0)
                p.lockTimer = LOCK_DELAY;
            break;
        }
    }
    
    // handle lock timer
    if (p.lockTimer >= 0)
    {
        p.lockTimer -= dt;
        if (p.lockTimer <= 0)
        {
            while (tryMove(p, 0, -1)) {}
            lockPiece(p, false);
            p.aiPlan = null;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// RENDERING

function drawPiece(player, type, rot, pos, alpha=1, ghost=false)
{
    const blocks = getBlocks(type, rot);
    const c = (type === GARBAGE_TYPE) ? GARBAGE_COLOR.copy() : PIECES[type].color.copy();
    c.a *= alpha;

    for (const b of blocks)
    {
        const x = (pos.x + b.x) | 0;
        const y = (pos.y + b.y) | 0;
        if (y < 0 || x < 0 || x >= COLS || y >= ROWS) continue;
        const pad = ghost ? .18 : .06;
        drawCell(player, x, y, c, pad);
    }
}

function ghostPos(p)
{
    let pos = p.cur.pos.copy();
    while (fitsType(p.cur.type, p.cur.rot, pos.add(vec2(0,-1)), p.board))
        pos.y -= 1;
    return pos;
}

function drawMini(type, at)
{
    if (type < 0) return;

    const blocks = getBlocks(type, 0);
    let minX =  1e9, maxX = -1e9, minY =  1e9, maxY = -1e9;
    for (const b of blocks)
    {
        minX = b.x < minX ? b.x : minX;
        maxX = b.x > maxX ? b.x : maxX;
        minY = b.y < minY ? b.y : minY;
        maxY = b.y > maxY ? b.y : maxY;
    }

    const center = vec2((minX + maxX) * .5, (minY + maxY) * .5);
    const offset = center.scale(-1);
    const c = PIECES[type].color;

    for (const b of blocks)
    {
        const p = at.add(vec2(b.x, b.y).add(offset));
        drawMiniCell(p, c);
    }
}

function drawPlayer(p, applyShake = false)
{
    // Set shake offset for this player
    renderShakeOffset = applyShake ? screenShake : vec2(0, 0);
    
    // frame
    const center = p.boardCenter.add(renderShakeOffset);
    drawRect(center, BOARD_SIZE.add(vec2(.35)), rgb(.15,.15,.18));
    drawRect(center, BOARD_SIZE.add(vec2(.10)), rgb(.05,.05,.06));

    // blocks
    for (let y=0; y<ROWS; ++y)
    for (let x=0; x<COLS; ++x)
    {
        const t = p.board[y][x];
        if (t == -1) continue;
        const color = (t === GARBAGE_TYPE) ? GARBAGE_COLOR : PIECES[t].color;
        drawCell(p, x, y, color);
    }

    // current + ghost
    if (!p.clearAnim && p.cur)
    {
        if (!p.gameOver)
        {
            const gp = ghostPos(p);
            drawPiece(p, p.cur.type, p.cur.rot, gp, .25, true);
        }
        // Always draw current piece (including game over to show it didn't fit)
        drawPiece(p, p.cur.type, p.cur.rot, p.cur.pos, p.gameOver ? 0.7 : 1, false);
    }

    // name
    drawText(p.name, vec2(p.boardCenterX, p.boardPos.y + BOARD_SIZE.y + 1.4).add(renderShakeOffset), 1.2, WHITE, .25, BLACK);

    // UI
    const u = p.uiPos.add(renderShakeOffset);
    drawText('NEXT', u.add(vec2(0,0)), 1.0, WHITE, .25, BLACK);
    ensureNextQueue(p);
    for (let i=0; i<NEXT_COUNT; ++i)
        drawMini(p.nextQueue[i], u.add(vec2(0,-2.2 - i*2.1)));

    drawText('HOLD', u.add(vec2(0,-11.0)), 1.0, WHITE, .25, BLACK);
    drawMini(p.holdType, u.add(vec2(0,-13.2)));

    drawText(`Score ${p.score}`, u.add(vec2(0,-16.0)), .9, WHITE, .2, BLACK);
    drawText(`Lines ${p.lines}`, u.add(vec2(0,-17.1)), .9, WHITE, .2, BLACK);
    drawText(`Level ${p.level}`, u.add(vec2(0,-18.2)), .9, WHITE, .2, BLACK);

    if (p.pendingGarbage)
        drawText(`+${p.pendingGarbage} incoming`, u.add(vec2(0,-19.4)), .7, hsl(.05,.1,.85), .2, BLACK);

    if (p.gameOver)
    {
        drawRect(center, BOARD_SIZE, rgb(0,0,0,.6));
        drawText('KO', center.add(vec2(0,2)), 3, RED, .4, BLACK);
    }
    
    // Reset shake offset after drawing
    renderShakeOffset = vec2(0, 0);
}

///////////////////////////////////////////////////////////////////////////////
// INPUT (HUMAN)

function humanUpdate(p, dt)
{
    // rotation
    if (keyWasPressed('KeyZ')) tryRotate(p, -1);
    if (keyWasPressed('KeyX') || keyWasPressed('ArrowUp')) tryRotate(p, 1);

    // hold
    if (keyWasPressed('KeyC') || keyWasPressed('ShiftLeft') || keyWasPressed('ShiftRight'))
        hold(p);

    // hard drop
    if (keyWasPressed('Space'))
        hardDrop(p);

    // horizontal movement with DAS/ARR
    const leftDown  = keyIsDown('ArrowLeft') || keyIsDown('KeyA');
    const rightDown = keyIsDown('ArrowRight') || keyIsDown('KeyD');
    const newDir = rightDown && !leftDown ? 1 : leftDown && !rightDown ? -1 : 0;

    if (newDir != p.moveDir)
    {
        p.moveDir = newDir;
        p.moveTimer = 0;
        p.arrTimer = 0;
        if (p.moveDir)
        {
            if (tryMove(p, p.moveDir, 0)) sMove && sMove.play(p.boardCenter);
            p.moveTimer = MOVE_DAS;
        }
    }
    else if (p.moveDir)
    {
        p.moveTimer -= dt;
        if (p.moveTimer <= 0)
        {
            p.arrTimer -= dt;
            if (p.arrTimer <= 0)
            {
                if (tryMove(p, p.moveDir, 0)) sMove && sMove.play(p.boardCenter);
                p.arrTimer = MOVE_ARR;
            }
        }
    }

    // gravity + soft drop
    const soft = keyIsDown('ArrowDown') || keyIsDown('KeyS');
    const cps = gravityCellsPerSecond(p) * (soft ? SOFT_DROP_MULT : 1);
    p.fallAcc += cps * dt;

    while (p.fallAcc >= 1)
    {
        p.fallAcc -= 1;
        if (!tryMove(p, 0, -1))
        {
            if (p.lockTimer < 0)
                p.lockTimer = LOCK_DELAY;
            break;
        }
    }

    // lock delay - once started, just counts down and locks
    if (p.lockTimer >= 0)
    {
        p.lockTimer -= dt;
        if (p.lockTimer <= 0)
        {
            // Drop piece to ground first, then lock
            while (tryMove(p, 0, -1)) {}
            lockPiece(p, false);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// LITTLEJS CALLBACKS

async function gameInit()
{
    setCanvasFixedSize(vec2(1440, 1080));

    // Initialize UI system
    new UISystemPlugin();
    uiSystem.defaultCornerRadius = 8;
    uiSystem.defaultLineWidth = 3;

    // sounds
    sMove   = new SoundGenerator({frequency:330, release:.01, volume:.35});
    sRotate = new SoundGenerator({frequency:1520, release:.005, volume:.35});
    sDrop   = new SoundGenerator({frequency:220, release:.06, slide:-.4, volume:.45});
    sLock   = new SoundGenerator({frequency:180, release:.08, noise:.06, volume:.5});
    sClear  = new SoundGenerator({frequency:740, release:.12, slide:.25, volume:.5});
    sHold   = new SoundGenerator({frequency:400, release:.08, pitchJump:200, pitchJumpTime:.02, volume:.35});
    sOver   = new SoundGenerator({frequency:120, release:.35, noise:.2, volume:.55});
    sGarbage = new SoundGenerator({frequency:90,  release:.14, noise:.1, volume:.45, slide:.15});
    sSelect = new SoundGenerator({frequency:440, release:.08, volume:.3});

    // Create menu UI
    createMenuUI();

    gameState = 'menu';
    
    // Warm up menu background
    showMenuUI(true);
}

function createMenuUI()
{
    // Canvas is 1920x1080, UI uses screen coordinates with center at (960, 540)
    const cx = 960;
    const cy = 540;

    // Title is drawn manually in renderMenuTitle() for animation effect

    // Single Player button
    btnSinglePlayer = new UIButton(vec2(cx, cy), vec2(560, 120), 'SINGLE PLAYER');
    btnSinglePlayer.color = hsl(.55, .7, .35);
    btnSinglePlayer.hoverColor = hsl(.55, .8, .5);
    btnSinglePlayer.textColor = WHITE;
    btnSinglePlayer.textLineColor = BLACK;
    btnSinglePlayer.textLineWidth = 6;
    btnSinglePlayer.soundClick = sSelect;
    btnSinglePlayer.navigationIndex = 1;
    btnSinglePlayer.onClick = () => startGame('single');

    // VS AI button
    btnVsAI = new UIButton(vec2(cx, cy + 160), vec2(560, 120), 'VS AI');
    btnVsAI.color = hsl(.02, .7, .4);
    btnVsAI.hoverColor = hsl(.02, .8, .55);
    btnVsAI.textColor = WHITE;
    btnVsAI.textLineColor = BLACK;
    btnVsAI.textLineWidth = 6;
    btnVsAI.soundClick = sSelect;
    btnVsAI.navigationIndex = 2;
    btnVsAI.onClick = () => startGame('vs');

    // Instructions
    menuInstructions = new UIText(vec2(cx, cy + 360), vec2(1000, 80), 'Made by LittleJS AI');
    menuInstructions.textColor = WHITE;
    menuInstructions.textLineWidth = 0;
}

function showMenuUI(visible)
{
    btnSinglePlayer.visible = visible;
    btnVsAI.visible = visible;
    menuInstructions.visible = visible;
    
    // Reset and warm up background pieces when showing menu
    if (visible)
    {
        menuBgPieces = [];
        // Spawn initial pieces scattered across the screen
        for (let i = 0; i < 15; i++)
        {
            const type = randInt(PIECES.length);
            const rot = randInt(4);
            menuBgPieces.push({
                type,
                rot,
                x: frand(-12, 12),
                y: frand(-14, 14),
                fallSpeed: MENU_FALL_SPEED + frand(-0.5, 1),
                alpha: frand(0.15, 0.35),
                scale: frand(0.7, 1.1),
            });
        }
    }
}

function updateMenuBackground(dt)
{
    // Spawn new pieces
    menuSpawnTimer -= dt;
    if (menuSpawnTimer <= 0)
    {
        menuSpawnTimer = MENU_SPAWN_RATE + frand(-0.15, 0.15);
        
        // Spawn a random piece at top
        const type = randInt(PIECES.length);
        const rot = randInt(4);
        menuBgPieces.push({
            type,
            rot,
            x: frand(-12, 12),
            y: 16,
            fallSpeed: MENU_FALL_SPEED + frand(-0.5, 1),
            alpha: frand(0.15, 0.35),
            scale: frand(0.7, 1.1),
        });
    }
    
    // Update pieces
    for (let i = menuBgPieces.length - 1; i >= 0; i--)
    {
        const p = menuBgPieces[i];
        p.y -= p.fallSpeed * dt;
        
        // Remove if off screen
        if (p.y < -16)
            menuBgPieces.splice(i, 1);
    }
}

function renderMenuBackground()
{
    for (const p of menuBgPieces)
    {
        const blocks = getBlocks(p.type, p.rot);
        const baseColor = PIECES[p.type].color;
        const color = baseColor.copy();
        color.a = p.alpha;
        
        for (const b of blocks)
        {
            const wx = p.x + b.x * p.scale;
            const wy = p.y + b.y * p.scale;
            drawRect(vec2(wx, wy), vec2(p.scale * 0.9), color);
        }
    }
}

function renderMenuTitle()
{
    const t = time * 1.5; // animation speed
    const baseY = 5; // world Y position for title
    
    // Animated layers orbiting around the center
    const numLayers = 6;
    for (let i = 0; i < numLayers; i++)
    {
        const angle = t + i * (Math.PI * 2 / numLayers); // evenly spaced, rotating
        const radius = 0.8 + Math.sin(t * 0.5 + i) * 0.3;
        const offsetX = Math.cos(angle) * radius;
        const offsetY = Math.sin(angle) * radius * 0.6;
        const hue = (i / numLayers + t * 0.1) % 1; // cycling colors
        const color = hsl(hue, .9, .55, .6);
        drawText('TETRIS', vec2(offsetX, baseY + offsetY), 4, color, 0, CLEAR_BLACK);
    }
    
    // Draw main white text on top
    drawText('TETRIS', vec2(0, baseY), 4, WHITE, .6, BLACK);
}

function startGame(mode)
{
    gameMode = mode;
    gameState = 'playing';
    particles = [];
    showMenuUI(false);

    if (mode === 'single')
    {
        // Single player - centered board
        players = [
            makePlayer('PLAYER', 0, false),
        ];
        resetPlayer(players[0]);
    }
    else
    {
        // VS AI - two boards
        players = [
            makePlayer('PLAYER', LEFT_CENTER_X, false),
            makePlayer('AI',  RIGHT_CENTER_X, true),
        ];
        resetPlayer(players[0]);
        resetPlayer(players[1]);
    }
}

function gameUpdate()
{
    if (gameState === 'menu')
    {
        // Animate menu background
        updateMenuBackground(timeDelta);
        return;
    }

    // Playing state
    // restart / return to menu
    if (keyWasPressed('KeyR'))
    {
        particles = [];
        resetPlayer(players[0]);
        if (gameMode === 'vs') resetPlayer(players[1]);
    }
    if (keyWasPressed('Escape'))
    {
        gameState = 'menu';
        showMenuUI(true);
        return;
    }

    // DEBUG: press G to send garbage to AI (only in vs mode)
    if (gameMode === 'vs' && keyWasPressed('KeyG'))
    {
        players[1].pendingGarbage += 1;
    }

    // particles
    updateParticles(timeDelta);

    // screen shake
    updateScreenShake(timeDelta);

    // ambient sparkles on active pieces
    stepPieceSparkles(players[0], timeDelta);
    if (gameMode === 'vs') stepPieceSparkles(players[1], timeDelta);

    const human = players[0];
    const ai = gameMode === 'vs' ? players[1] : null;

    // clear anims first (they pause gameplay for that player)
    if (human.clearAnim) stepClearAnim(human, ai, timeDelta);
    if (ai && ai.clearAnim) stepClearAnim(ai, human, timeDelta);

    // If someone is KO'd, pause ALL gameplay input/AI
    if (human.gameOver || (ai && ai.gameOver))
        return;

    if (!human.clearAnim)
        humanUpdate(human, timeDelta);

    if (ai && !ai.clearAnim)
        stepAI(ai, timeDelta);
}

function gameUpdatePost()
{
    // Camera stays at origin - shake is applied via renderShakeOffset during drawing
}

function gameRender()
{
    // background
    drawRect(cameraPos, getCameraSize(), rgb(.06,.06,.07));

    if (gameState === 'menu')
    {
        // Draw falling pieces background
        renderMenuBackground();
        
        // Draw animated title
        renderMenuTitle();
        
        // UI system renders the menu on top
        return;
    }

    // Playing state
    if (gameMode === 'vs')
    {
        // center divider
        drawRect(vec2(0,0), vec2(.15, 28), rgb(.12,.12,.14));
        drawPlayer(players[0], true);  // human with shake
        drawPlayer(players[1], false); // AI no shake
    }
    else
    {
        // single player - just draw one board
        drawPlayer(players[0], true);  // human with shake
    }

    renderParticles();

    // bottom help
    const helpText = gameMode === 'vs' 
        ? 'Arrows/A-D move, Up/X rotate, Z CCW, Space drop, C/Shift hold, R restart, ESC menu'
        : 'Arrows/A-D move, Up/X rotate, Z CCW, Space drop, C/Shift hold, R restart, ESC menu';
    drawText(helpText, vec2(0,-11.5), .6, hsl(0,0,.7), .12, BLACK);

    // win/lose banner
    const hKO = players[0].gameOver;
    const aKO = gameMode === 'vs' ? players[1].gameOver : false;
    if (hKO || aKO)
    {
        drawRect(vec2(0,0), getCameraSize(), rgb(0,0,0,.55));
        let msg, msgColor;
        if (gameMode === 'single')
        {
            msg = 'GAME OVER';
            msgColor = WHITE;
        }
        else
        {
            msg = hKO && aKO ? 'DOUBLE KO' : hKO ? 'YOU LOSE' : 'YOU WIN';
            msgColor = hKO && !aKO ? RED : (aKO && !hKO ? hsl(.33,.9,.6) : WHITE);
        }
        drawText(msg, vec2(0,2.5), 3.2, msgColor, .4, BLACK);
        drawText('Press R to restart, ESC for menu', vec2(0,-1.0), 1.2, WHITE, .25, BLACK);
    }
}

function gameRenderPost(){}

engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body></html>
