<!DOCTYPE html><head>
<title>LittleJS AI Starter Project</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="../dist/littlejs.js?1.18.0"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false; // Hide debug watermark in corner
showEngineVersion = false; // Hide engine version console display
paused = false; // Start unpaused

// engine settings, customize if necessary
gravity = vec2(0, 0); // No gravity
cameraScale = 32;     // Pixels per world unit

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Snake (grid-based)

const gridW = 24;
const gridH = 18;
const cellSize = 1;

let snake, dir, nextDir;
let food, poison;
let grow;
let score, best;
let alive;
let stepTimer, stepInterval;

// sound
const sEat    = new SoundGenerator({volume:.7, frequency:520, release:.06, shapeCurve:1.2, pitchJump:120, pitchJumpTime:.02});
const sPoison = new SoundGenerator({volume:.7, frequency:180, release:.12, noise:.15, slide:-.2});
const sDie    = new SoundGenerator({volume:1,  frequency:90,  release:.35, noise:.25, shapeCurve:.6, slide:-.4, delay:.03});

function clampDir(d)
{
    // prevent 180-degree reversal
    if (!snake || !snake.length) return d;
    return (d.x === -dir.x && d.y === -dir.y) ? dir : d;
}

function cellToWorld(c)
{
    // center grid at world origin
    return vec2((c.x - gridW/2 + .5) * cellSize, (c.y - gridH/2 + .5) * cellSize);
}

function isCellInBounds(c)
{
    return c.x >= 0 && c.y >= 0 && c.x < gridW && c.y < gridH;
}

function cellEquals(a,b){ return a.x === b.x && a.y === b.y; }

function cellOnSnake(c)
{
    for (const s of snake)
        if (cellEquals(s, c)) return true;
    return false;
}

function randEmptyCell()
{
    // try a few times; grid is small so this is fine
    for (let i=0; i<200; ++i)
    {
        const c = vec2(randInt(gridW), randInt(gridH));
        if (cellOnSnake(c)) continue;
        if (food && cellEquals(c, food)) continue;
        if (poison && cellEquals(c, poison)) continue;
        return c;
    }

    // fallback scan
    for (let y=0; y<gridH; ++y)
    for (let x=0; x<gridW; ++x)
    {
        const c = vec2(x,y);
        if (!cellOnSnake(c) && (!food || !cellEquals(c, food)) && (!poison || !cellEquals(c, poison)))
            return c;
    }
    return vec2(0,0);
}

function resetGame()
{
    const start = vec2(gridW/2|0, gridH/2|0);

    snake = [start.copy(), start.add(vec2(-1,0)), start.add(vec2(-2,0)), start.add(vec2(-3,0))];
    dir = vec2(1,0);
    nextDir = dir;

    grow = 0;
    score = 0;
    alive = true;

    stepInterval = .12;
    stepTimer = stepInterval;

    food = randEmptyCell();
    poison = 0;

    cameraPos = vec2(0,0);
}

function die()
{
    if (!alive) return;
    alive = false;
    sDie.play();

    // save best
    best = max(best, score);
    localStorage.setItem('snake_best', ''+best);
}

function eatFood()
{
    score++;
    grow++;
    sEat.play();

    // make it speed up gently
    stepInterval = max(.06, .12 - score * .003);

    food = randEmptyCell();

    // chance to introduce poison after you get going
    if (!poison && score >= 3 && randBool(.35))
        poison = randEmptyCell();
}

function hitPoison()
{
    sPoison.play();

    // shrink by 2 segments (but keep at least 2)
    let shrink = 2;
    while (shrink-- && snake.length > 2)
        snake.pop();

    // small score penalty
    score = max(0, score - 1);

    poison = randEmptyCell();
}

function tick()
{
    dir = clampDir(nextDir);

    const head = snake[0];
    const newHead = head.add(dir);

    // wall collision
    if (!isCellInBounds(newHead))
        return die();

    // self collision (allow moving into tail only if it will move away this tick)
    const willRemoveTail = (grow <= 0);
    for (let i=0; i<snake.length; ++i)
    {
        const s = snake[i];
        if (!cellEquals(s, newHead)) continue;

        // if overlapping tail and tail will move away, allow it
        if (willRemoveTail && i === snake.length-1)
            break;

        return die();
    }

    // move
    snake.unshift(newHead);

    // consume
    if (cellEquals(newHead, food))
        eatFood();
    else if (poison && cellEquals(newHead, poison))
        hitPoison();

    // tail
    if (grow > 0)
        grow--;
    else
        snake.pop();

    // occasionally spawn poison if missing
    if (!poison && score >= 5 && randBool(.04))
        poison = randEmptyCell();
}

function handleInput()
{
    // arrows
    if (keyWasPressed('ArrowUp') || keyWasPressed('KeyW'))    nextDir = vec2(0, 1);
    if (keyWasPressed('ArrowDown') || keyWasPressed('KeyS'))  nextDir = vec2(0,-1);
    if (keyWasPressed('ArrowLeft') || keyWasPressed('KeyA'))  nextDir = vec2(-1,0);
    if (keyWasPressed('ArrowRight') || keyWasPressed('KeyD')) nextDir = vec2(1, 0);

    if (!alive && keyWasPressed('Space'))
        resetGame();
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    // called once after the engine starts up
    canvasClearColor = BLACK;
    best = parseInt(localStorage.getItem('snake_best') || '0');

    // A consistent canvas helps the grid feel stable
    setCanvasFixedSize(vec2(1280, 720));
    cameraScale = 34;

    resetGame();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    // called every frame at 60 frames per second
    handleInput();

    if (!alive)
        return;

    stepTimer -= timeDelta;
    while (stepTimer <= 0)
    {
        stepTimer += stepInterval;
        tick();
        if (!alive) break;
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // keep camera centered
    cameraPos = vec2(0,0);
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // background
    drawRectGradient(cameraPos, getCameraSize(), hsl(0,0,.06), hsl(0,0,.12));

    // playfield
    const fieldSize = vec2(gridW*cellSize, gridH*cellSize);
    drawRect(cameraPos, fieldSize.add(vec2(.4)), hsl(0,0,.2));
    drawRect(cameraPos, fieldSize, hsl(0,0,.08));

    // food
    {
        const p = cellToWorld(food);
        drawCircle(p, .75, hsl(.12, 1, .55)); // diameter
    }

    // poison
    if (poison)
    {
        const p = cellToWorld(poison);
        drawCircle(p, .75, hsl(.78, 1, .6));
    }

    // snake
    for (let i=snake.length; i--;)
    {
        const c = snake[i];
        const p = cellToWorld(c);
        const t = i / max(1, snake.length-1);

        // head brighter
        const col = i === 0
            ? hsl(.33, 1, .65)
            : hsl(.33, .8, lerp(.25, .55, 1-t));

        drawRect(p, vec2(.92), col);
    }

    // subtle grid lines
    {
        const halfW = gridW/2;
        const halfH = gridH/2;
        const col = hsl(0,0,.2,.35);
        for (let x=-halfW; x<=halfW; ++x)
            drawLine(vec2(x,-halfH), vec2(x,halfH), .03, col);
        for (let y=-halfH; y<=halfH; ++y)
            drawLine(vec2(-halfW,y), vec2(halfW,y), .03, col);
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    const center = vec2(mainCanvasSize.x/2, 0);

    const hud = `SNAKE   Score: ${score}   Best: ${best}`;
    drawTextScreen(hud, vec2(center.x, 36), 36, hsl(0,0,1), 4, hsl(0,0,0));

    const help = `Move: Arrow Keys / WASD   Restart: Space   Eat \u25CF to grow, avoid \u25CF (poison) to shrink`;
    drawTextScreen(help, vec2(center.x, mainCanvasSize.y-28), 20, hsl(0,0,1,.85), 3, hsl(0,0,0,.8));

    if (!alive)
    {
        drawTextScreen('Game Over', vec2(center.x, mainCanvasSize.y/2 - 20), 90, hsl(0,0,1), 8, hsl(0,0,0));
        drawTextScreen('Press Space to Restart', vec2(center.x, mainCanvasSize.y/2 + 52), 36, hsl(0,0,1), 5, hsl(0,0,0));
    }
}

///////////////////////////////////////////////////////////////////////////////
// Startup LittleJS Engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>