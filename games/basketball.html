<!DOCTYPE html><head>
<title>LittleJS - Hoop Toss (Box2D)</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="../dist/littlejs.js?1.18.0"></script>
<script src="../dist/box2d.wasm.js?1.18.0"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;

// game settings
cameraScale = 32;
cameraPos = vec2(0, 2);
gravity = vec2(0, -45);

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

//------------------------------------------------------------------------------
// Hoop Toss (Box2D)

const levelHalfSize = vec2(14, 10);
const spawnPos = vec2(-11, -6);
const hoopPos = vec2(9.5, 3.5);

let balls = [];
let score = 0;
let aiming = false;
let throwCooldown = 0;

const grabRadius = 1.0;          // must click near spawn to start aiming
const throwCooldownTime = 0.35;  // small delay between throws

// sounds
const sThrow = new SoundGenerator({frequency: 280, slide: -1.5, release: .12, volume: .6, randomness: .08});
const sScore = new SoundGenerator({frequency: 740, pitchJump: 1200, pitchJumpTime: .03, release: .25, volume: .75, randomness: .02});

function clampVecLength(v, maxLen)
{
    const l = v.length();
    return l > maxLen ? v.scale(maxLen / l) : v;
}

class Ball extends Box2dObject
{
    constructor(pos)
    {
        super(pos, vec2(), 0, 0, hsl(.1, .9, .55));
        this.diameter = .9;
        this.addCircle(this.diameter, vec2(), 0, /*density*/1, /*friction*/.25, /*restitution*/.55);
        this.setBullet(true);
        this.scored = false;
    }

    update()
    {
        // cleanup if it falls out of the world
        if (this.pos.y < -40 || Math.abs(this.pos.x) > 60)
            this.destroy();
    }
}

class HoopSensor extends Box2dStaticObject
{
    constructor(pos)
    {
        super(pos, vec2(), 0, 0, hsl(.13, 1, .55));
        this.isHoopSensor = true;
        // thin sensor just below rim height (counts only when ball is falling)
        this.addBox(vec2(2.0, .35), vec2(), 0, 0, 0, 0, /*isSensor*/true);
        this.lineColor = hsl(.13, 1, .25);
        this.lineWidth = .08;
    }

    beginContact(other)
    {
        if (!(other instanceof Ball))
            return;
        if (other.scored)
            return;

        // only count if moving downward (a decent "through the hoop" heuristic)
        if (other.getLinearVelocity().y < 0)
        {
            other.scored = true;
            score++;
            sScore.play();
        }
    }

    render()
    {
        // invisible (comment this out if you want to see the sensor)
    }
}

async function gameInit()
{
    await box2dInit();

    canvasClearColor = hsl(0, 0, .92);

    // boundaries
    {
        const floor = new Box2dStaticObject(vec2(0, -9.2), vec2(), 0, 0, GRAY);
        floor.addBox(vec2(60, 1.6), vec2(), 0, 0, .6, .05);

        const leftWall = new Box2dStaticObject(vec2(-levelHalfSize.x-1, 0), vec2(), 0, 0, GRAY);
        leftWall.addBox(vec2(2, 60), vec2(), 0, 0, .3, .05);

        const rightWall = new Box2dStaticObject(vec2(levelHalfSize.x+1, 0), vec2(), 0, 0, GRAY);
        rightWall.addBox(vec2(2, 60), vec2(), 0, 0, .3, .05);

        // little "launch pad"
        const pad = new Box2dStaticObject(spawnPos.add(vec2(1.2, -1.2)), vec2(), 0, 0, hsl(0,0,.7));
        pad.addBox(vec2(6, .5), vec2(), .08, 0, .9, .1);
    }

    // hoop + backboard
    {
        // backboard
        const board = new Box2dStaticObject(hoopPos.add(vec2(2.0, 1.5)), vec2(), 0, 0, hsl(.58,.2,.35));
        board.addBox(vec2(.45, 5.0), vec2(), 0, 0, .3, .05);

        // rim pegs (open hoop)
        const rimY = hoopPos.y + .5;
        const leftPeg  = new Box2dStaticObject(vec2(hoopPos.x - 1.1, rimY), vec2(), 0, 0, hsl(.04, .8, .55));
        leftPeg.addBox(vec2(.25, .75), vec2(), 0, 0, .2, .05);

        const rightPeg = new Box2dStaticObject(vec2(hoopPos.x + 1.1, rimY), vec2(), 0, 0, hsl(.04, .8, .55));
        rightPeg.addBox(vec2(.25, .75), vec2(), 0, 0, .2, .05);

        // small arm connecting to backboard
        const arm = new Box2dStaticObject(vec2(hoopPos.x + 1.6, rimY), vec2(), 0, 0, hsl(.04, .8, .55));
        arm.addBox(vec2(1.2, .2), vec2(), 0, 0, .2, .05);

        // score sensor
        new HoopSensor(hoopPos);
    }
}

function gameUpdate()
{
    // cooldown between throws
    throwCooldown = max(0, throwCooldown - timeDelta);

    // start aiming only if you grab the spawn dot
    if (!aiming && throwCooldown <= 0 && mouseWasPressed(0))
    {
        if (mousePos.subtract(spawnPos).length() <= grabRadius)
            aiming = true;
    }

    // release to throw
    if (aiming && mouseWasReleased(0))
    {
        throwCooldown = throwCooldownTime;
        aiming = false;

        // aim in direction of the line, with strength based on line length
        const maxDrag = 8;
        const aimRaw = mousePos.subtract(spawnPos);
        const aimLenRaw = aimRaw.length();
        const aimLen = Math.min(aimLenRaw, maxDrag);
        const dir = aimLenRaw > 0 ? aimRaw.scale(1 / aimLenRaw) : vec2();

        // max launch speed (tune this)
        const maxSpeed = 65;
        const speed = (aimLen / maxDrag) * maxSpeed;
        const throwVel = dir.scale(speed);

        const b = new Ball(spawnPos);
        b.setLinearVelocity(throwVel);
        balls.push(b);
        sThrow.play();
    }

    // reset
    if (keyWasPressed('KeyR'))
    {
        score = 0;
        balls.forEach(b=>b.destroy());
        balls.length = 0;
    }

    // prune destroyed
    balls = balls.filter(b=>!b.destroyed);
}

function gameUpdatePost() {}

function gameRender()
{
    // world frame
    drawRect(cameraPos, vec2(levelHalfSize.x*2+6, levelHalfSize.y*2+6), hsl(0,0,.96));

    // spawn marker
    const hover = mousePos.subtract(spawnPos).length() <= grabRadius;
    drawCircle(spawnPos, .35, hsl(.55, .6, .5), .08, hsl(.55, .6, .2));
    if (!aiming)
        drawCircle(spawnPos, hover ? .9 : .75, hsl(.55, .2, hover ? .75 : .92), .06, hsl(.55, .2, .25));

    // aiming line
    if (aiming)
    {
        const maxDrag = 8;
        const aimRaw = mousePos.subtract(spawnPos);
        const aimLenRaw = aimRaw.length();
        const aimLen = Math.min(aimLenRaw, maxDrag);
        const dir = aimLenRaw > 0 ? aimRaw.scale(1 / aimLenRaw) : vec2();
        const end = spawnPos.add(dir.scale(aimLen));

        drawLine(spawnPos, end, .12, hsl(.58, .7, .35));
        drawCircle(end, .25, hsl(.58, .7, .6), .07, hsl(.58, .7, .2));
    }
}

function gameRenderPost()
{
    const center = mainCanvasSize.scale(.5);

    // centered UI
    drawTextScreen(`Score: ${score}`, vec2(center.x, 40), 56, hsl(0,0,.1), 3, hsl(0,0,1));

    const help = 'Click and drag FROM the spawn dot to aim, release to throw\nR = reset';
    drawTextScreen(help, vec2(center.x, 95), 26, hsl(0,0,.15), 2, hsl(0,0,1));
}

engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body>
