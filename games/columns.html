<!DOCTYPE html><head>
 <title>LittleJS AI Starter Project</title>
 <meta charset=utf-8>
 </head><body>
 <script src="../dist/littlejs.js?1.18.0"></script>
 <script>
 'use strict';
 
 // engine settings
 debugWatermark = false; // Hide debug watermark in corner
 showEngineVersion = false; // Hide engine version console display
 
 // AI can use this class to make sound effects
 class SoundGenerator extends Sound 
 {
     constructor(params = {})
     {
         const {
             volume = 1,        // Volume scale (percent)
             randomness = .05,  // How much to randomize frequency (percent Hz)
             frequency = 220,   // Frequency of sound (Hz)
             attack = 0,        // Attack time, how fast sound starts (seconds)
             release = .1,      // Release time, how fast sound fades out (seconds)
             shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
             slide = 0,         // How much to slide frequency (kHz/s)
             pitchJump = 0,     // Frequency of pitch jump (Hz)
             pitchJumpTime = 0, // Time of pitch jump (seconds)
             repeatTime = 0,    // Resets some parameters periodically (seconds)
             noise = 0,         // How much random noise to add (percent)
             bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
             delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
         } = params;
         
         super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 // Columns (SEGA) - tiny untextured prototype
 // Controls: Left/Right move, Up rotate, Down soft drop, Space hard drop, R restart
 
 const COLS = 6;
 const ROWS = 13;
 const PANEL_W = 4.5;
 const HIDDEN_ROWS = 3; // spawn buffer
 
 const EMPTY = -1;
 let grid;
 
 let piece, nextPiece;
 let fallCounter = 0;
 let score = 0;
 let level = 1;
 let combo = 0;
 let gameOver = false;
 
 // sounds
 let sfxMove, sfxRotate, sfxLock, sfxClear, sfxGameOver;
 
 // palette (bright, arcade-y)
 const JEWEL_COLORS = [
     rgb(0.95, 0.30, 0.25), // red
     rgb(0.25, 0.75, 0.35), // green
     rgb(0.25, 0.55, 0.95), // blue
     rgb(0.95, 0.85, 0.25), // yellow
     rgb(0.75, 0.35, 0.90), // purple
     rgb(0.25, 0.90, 0.90), // cyan
 ];

 // each color gets a fruit emoji overlay (browser font dependent)
 const FRUIT_EMOJIS = [
     'üçí', // red
     'üçè', // green
     'ü••', // blue
     'üçå', // yellow
     'üçá', // purple
     'üçë', // cyan-ish
 ];
 
 function colorLighten(c, a)
 {
     return rgb(Math.min(1, c.r + a), Math.min(1, c.g + a), Math.min(1, c.b + a), c.a);
 }
 function colorDarken(c, a)
 {
     return rgb(Math.max(0, c.r - a), Math.max(0, c.g - a), Math.max(0, c.b - a), c.a);
 }
 
 function makeEmptyGrid()
 {
     grid = new Array(COLS);
     for (let x=0; x<COLS; x++)
     {
         grid[x] = new Array(ROWS);
         for (let y=0; y<ROWS; y++)
             grid[x][y] = EMPTY;
     }
 }
 
 function randJewel() { return randInt(JEWEL_COLORS.length); }
 
 function makePiece()
 {
     return {
         x: (COLS/2|0),
         y: ROWS + HIDDEN_ROWS,
         c: [randJewel(), randJewel(), randJewel()], // bottom, mid, top
     };
 }
 
 function restartGame()
 {
     makeEmptyGrid();
     score = 0;
     level = 1;
     combo = 0;
     fallCounter = 0;
     gameOver = false;
     nextPiece = makePiece();
     spawnPiece();
 }
 
 function spawnPiece()
 {
     piece = nextPiece;
     piece.x = (COLS/2|0);
     piece.y = ROWS + HIDDEN_ROWS;
     nextPiece = makePiece();
 
     // if immediately blocked at spawn, game over
     if (!canMove(0, 0))
         triggerGameOver();
 }
 
 function fallInterval()
 {
     // frames per cell drop
     // levels speed up: 30 -> 6
     return Math.max(6, 30 - (level-1)*2);
 }
 
 function canMove(dx, dy)
 {
     const x0 = piece.x + dx;
     for (let i=0; i<3; i++)
     {
         const x = x0;
         const y = piece.y + dy + i;
         if (x < 0 || x >= COLS)
             return false;
         if (y < 0)
             return false;
         if (y < ROWS && grid[x][y] !== EMPTY)
             return false;
     }
     return true;
 }
 
 function tryMove(dx, dy)
 {
     if (!canMove(dx, dy))
         return false;
     piece.x += dx;
     piece.y += dy;
     return true;
 }
 
 function rotatePiece()
 {
     // cycle jewels in the stack
     piece.c.unshift(piece.c.pop());
 }
 
 function hardDrop()
 {
     let moved = false;
     while (tryMove(0, -1))
         moved = true;
     lockPiece();
     return moved;
 }
 
 function lockPiece()
 {
     // place into grid
     for (let i=0; i<3; i++)
     {
         const x = piece.x;
         const y = piece.y + i;
         if (y >= ROWS)
         {
             triggerGameOver();
             return;
         }
         if (y >= 0)
             grid[x][y] = piece.c[i];
     }
     sfxLock.play();
 
     // resolve clears + gravity (chains)
     combo = 0;
     while (true)
     {
         const cleared = findAndClearMatches();
         if (!cleared)
             break;
         combo++;
         applyGravity();
     }
 
     // update level gently
     level = 1 + Math.floor(score / 600);
 
     if (!gameOver)
         spawnPiece();
 }
 
 function triggerGameOver()
 {
     if (gameOver) return;
     gameOver = true;
     sfxGameOver.play();
 }
 
 function inBounds(x, y)
 {
     return x >= 0 && x < COLS && y >= 0 && y < ROWS;
 }
 
 function findAndClearMatches()
 {
     // mark cells to clear
     const mark = new Array(COLS);
     for (let x=0; x<COLS; x++)
     {
         mark[x] = new Array(ROWS);
         for (let y=0; y<ROWS; y++)
             mark[x][y] = false;
     }
 
     const dirs = [
         [1, 0],  // horizontal
         [0, 1],  // vertical
         [1, 1],  // diag up-right
         [1,-1],  // diag down-right
     ];
 
     let any = false;
     for (let x=0; x<COLS; x++)
     for (let y=0; y<ROWS; y++)
     {
         const v = grid[x][y];
         if (v === EMPTY)
             continue;
 
         for (const [dx, dy] of dirs)
         {
             // only start from the beginning of a run
             const px = x - dx, py = y - dy;
             if (inBounds(px, py) && grid[px][py] === v)
                 continue;
 
             let count = 0;
             let xx = x, yy = y;
             while (inBounds(xx, yy) && grid[xx][yy] === v)
             {
                 count++;
                 xx += dx;
                 yy += dy;
             }
 
             if (count >= 3)
             {
                 any = true;
                 xx = x; yy = y;
                 for (let i=0; i<count; i++)
                 {
                     mark[xx][yy] = true;
                     xx += dx;
                     yy += dy;
                 }
             }
         }
     }
 
     if (!any)
         return 0;
 
     // clear and score
     let clearedCount = 0;
     for (let x=0; x<COLS; x++)
     for (let y=0; y<ROWS; y++)
     {
         if (mark[x][y])
         {
             grid[x][y] = EMPTY;
             clearedCount++;
         }
     }
 
     // simple score: reward chains
     const chainBonus = 1 + combo * 0.5;
     score += Math.floor(clearedCount * 10 * level * chainBonus);
     sfxClear.play();
     return clearedCount;
 }
 
 function applyGravity()
 {
     for (let x=0; x<COLS; x++)
     {
         let write = 0;
         for (let y=0; y<ROWS; y++)
         {
             const v = grid[x][y];
             if (v === EMPTY)
                 continue;
             if (write !== y)
             {
                 grid[x][write] = v;
                 grid[x][y] = EMPTY;
             }
             write++;
         }
         for (let y=write; y<ROWS; y++)
             grid[x][y] = EMPTY;
     }
 }
 
 function landingY()
 {
     let y = piece.y;
     while (true)
     {
         piece.y = y;
         if (!canMove(0, -1))
             break;
         y--;
     }
     piece.y = y;
     return y;
 }
 
 function drawJewel(pos, colorIndex, alpha=1, brightness=1)
 {
     const base = JEWEL_COLORS[colorIndex];
     const c = rgb(base.r*brightness, base.g*brightness, base.b*brightness, alpha);
     const dark = colorDarken(c, .22);
     const light = colorLighten(c, .14);
 
     // body
     drawRect(pos, vec2(.95), c);
     // bevel
     drawRect(pos, vec2(.95), undefined, 0); // keep render order consistent (no-op if undefined)
     drawRect(pos.add(vec2(-.12, .12)), vec2(.65), light);
     drawRect(pos.add(vec2(.12, -.12)), vec2(.65), dark);
     // outline
     drawRect(pos, vec2(.98), rgb(0,0,0,alpha*.35));
     drawRect(pos, vec2(.92), c);

     // fruit emoji overlay
     const emoji = FRUIT_EMOJIS[colorIndex] || 'üç¨';
     drawText(emoji, pos.add(vec2(0,-.02)), 0.75, rgb(1,1,1,alpha), 0.12, rgb(0,0,0,alpha*.6));
 }
 
 function drawBoard()
 {
     // board background
     const boardCenter = vec2(COLS/2, ROWS/2);
     drawRect(boardCenter, vec2(COLS+0.4, ROWS+0.4), rgb(.08,.08,.10));
     drawRect(boardCenter, vec2(COLS, ROWS), rgb(.06,.06,.08));
 
     // grid lines (subtle)
     for (let x=0; x<=COLS; x++)
         drawLine(vec2(x,0), vec2(x,ROWS), .03, rgb(.13,.13,.16));
     for (let y=0; y<=ROWS; y++)
         drawLine(vec2(0,y), vec2(COLS,y), .03, rgb(.13,.13,.16));
 
     // landed jewels
     for (let x=0; x<COLS; x++)
     for (let y=0; y<ROWS; y++)
     {
         const v = grid[x][y];
         if (v === EMPTY)
             continue;
         drawJewel(vec2(x+.5, y+.5), v, 1);
     }
 
     if (!piece || gameOver)
         return;

     // falling piece
     for (let i=0; i<3; i++)
     {
         const y = piece.y + i;
         if (y >= 0 && y < ROWS)
             drawJewel(vec2(piece.x+.5, y+.5), piece.c[i], 1);
     }
 }
 
 function drawPanel()
 {
     const px = COLS + PANEL_W/2 + 0.8;
     const panelCenter = vec2(px, ROWS/2);
     drawRect(panelCenter, vec2(PANEL_W, ROWS), rgb(.05,.05,.07));
     drawRect(panelCenter, vec2(PANEL_W-.2, ROWS-.2), rgb(.09,.09,.12));
 
     drawText('COLUMNS', vec2(px, ROWS - 1.0), 0.7, hsl(0,0,1), 0.15, hsl(0,0,0));
     drawText('Score',   vec2(px, ROWS - 2.2), 0.45, hsl(0,0,1), 0.12, hsl(0,0,0));
     drawText(score,     vec2(px, ROWS - 2.9), 0.6,  hsl(.12,1,.65), 0.12, hsl(0,0,0));
 
     drawText('Level',   vec2(px, ROWS - 4.2), 0.45, hsl(0,0,1), 0.12, hsl(0,0,0));
     drawText(level,     vec2(px, ROWS - 4.9), 0.6,  hsl(.55,1,.7),  0.12, hsl(0,0,0));
 
     drawText('Next',    vec2(px, ROWS - 6.2), 0.45, hsl(0,0,1), 0.12, hsl(0,0,0));
     if (nextPiece)
     {
         for (let i=0; i<3; i++)
         {
             const y = ROWS - 7.2 - i*1.05;
             drawJewel(vec2(px, y), nextPiece.c[i], 1);
         }
     }
 
     const help = '‚Üê/‚Üí move\n‚Üë rotate\n‚Üì soft drop\nSpace hard drop\nR restart';
     drawText(help, vec2(px, 2.8), 0.35, hsl(0,0,1), 0.12, hsl(0,0,0));
 
     if (gameOver)
     {
         drawRect(vec2(COLS/2, ROWS/2), vec2(COLS+PANEL_W+2, 3.2), rgb(0,0,0,.55));
         drawText('GAME OVER', vec2((COLS+PANEL_W+1.6)/2, ROWS/2 + .4), 1.0, hsl(0,1,.6), .25, hsl(0,0,0));
         drawText('Press R to restart', vec2((COLS+PANEL_W+1.6)/2, ROWS/2 - .6), 0.5, hsl(0,0,1), .15, hsl(0,0,0));
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function gameInit()
 {
     // retro fixed canvas
     setCanvasFixedSize(vec2(960, 540));
     setCanvasPixelated(true);
     setShowSplashScreen(false);
     setCameraScale(32);
 
     // SFX
     sfxMove = new SoundGenerator({volume:.20, frequency:520, attack:0, release:.05, shapeCurve:1.5});
     sfxRotate = new SoundGenerator({volume:.22, frequency:640, attack:0, release:.06, shapeCurve:1.8, slide:-1.2});
     sfxLock = new SoundGenerator({volume:.28, frequency:160, attack:0, release:.10, shapeCurve:1.2, noise:.1});
     sfxClear = new SoundGenerator({volume:.35, frequency:380, attack:0, release:.25, shapeCurve:1.1, pitchJump:220, pitchJumpTime:.05, delay:.02});
     sfxGameOver = new SoundGenerator({volume:.45, frequency:180, attack:0, release:.6, shapeCurve:2, slide:-.6, noise:.15});
 
     restartGame();
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function gameUpdate()
 {
     if (keyWasPressed('KeyR'))
     {
         restartGame();
         return;
     }
     if (gameOver)
         return;
 
     // input
     if (keyWasPressed('ArrowLeft'))
     {
         if (tryMove(-1, 0)) sfxMove.play();
     }
     if (keyWasPressed('ArrowRight'))
     {
         if (tryMove(1, 0)) sfxMove.play();
     }
     if (keyWasPressed('ArrowUp'))
     {
         const old = piece.c.slice();
         rotatePiece();
         if (!canMove(0,0))
             piece.c = old; // revert if rotation causes collision
         else
             sfxRotate.play();
     }
     if (keyWasPressed('Space'))
     {
         hardDrop();
         return;
     }
 
     // falling
     const softDrop = keyIsDown('ArrowDown');
     const interval = softDrop ? 2 : fallInterval();
     fallCounter++;
     if (fallCounter >= interval)
     {
         fallCounter = 0;
         if (!tryMove(0, -1))
             lockPiece();
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function gameUpdatePost()
 {
     // center camera to include board + right panel
     const totalW = COLS + PANEL_W + 1.6;
     setCameraPos(vec2(totalW/2, ROWS/2));
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function gameRender()
 {
     // background frame
     const totalW = COLS + PANEL_W + 1.6;
     const center = vec2(totalW/2, ROWS/2);
     drawRect(center, vec2(totalW+2, ROWS+2), rgb(.02,.02,.03));
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function gameRenderPost()
 {
     drawBoard();
     drawPanel();
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 // Startup LittleJS Engine
 engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);
 
 </script>
 </body>
