<!DOCTYPE html><head>
<title>LittleJS AI Starter Project</title>
<meta charset=utf-8>
</head><body>
<script src="../dist/littlejs.js"></script>
<script>
'use strict';

// engine settings
debugWatermark = false; // Hide debug watermark in corner
showEngineVersion = false; // Hide engine version console display

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

////////////////////////////////////////////////////////////////////////////////
// Tiny Kombat (minimal 2D fighter prototype)

// World / arena
const arenaSize = vec2(36, 20);
const arenaCenter = vec2(0, 7.5);
const groundY = 0;
const wallX = arenaSize.x/2 - 1;

// Gameplay constants (per-frame; fixed 60 fps)
const GRAVITY = 0.08;
const MOVE_SPEED = 0.22;
const AIR_SPEED = 0.14;
const JUMP_VEL = 1.22;
const FRICTION = 0.78;
const AIR_FRICTION = 0.995;

const MAX_HEALTH = 100;
const ROUND_TIME_FRAMES = 60*60; // 60 seconds at 60fps

// FX
let hitSparks = [];
let screenShakeFrames = 0;
let screenShakeMag = 0;

// Game state
let p1, p2;
let roundFrames = 0;
let announceText = '';
let announceFrames = 0;
let roundOver = false;
let restartFrames = 0;

// Sounds
const sJump  = new SoundGenerator({volume:.35, frequency:420, attack:0, release:.08, shapeCurve:1.3, slide:.4});
const sPunch = new SoundGenerator({volume:.35, frequency:180, attack:0, release:.08, shapeCurve:.6, noise:.15});
const sKick  = new SoundGenerator({volume:.4,  frequency:140, attack:0, release:.11, shapeCurve:.4, noise:.18, slide:-.2});
const sHit   = new SoundGenerator({volume:.55, frequency:90,  attack:0, release:.10, shapeCurve:.2, noise:.25, delay:.02});
const sBlock = new SoundGenerator({volume:.45, frequency:260, attack:0, release:.06, shapeCurve:1.8, noise:.1, bitCrush:2});
const sFire  = new SoundGenerator({volume:.45, frequency:320, attack:0, release:.10, shapeCurve:1.1, slide:-1.2, noise:.05});
const sKO    = new SoundGenerator({volume:.7,  frequency:60,  attack:0, release:.25, shapeCurve:.2, noise:.1, slide:-.3, delay:.03});

function clamp01(v){ return clamp(v, 0, 1); }
function sign0(v){ return v ? (v>0?1:-1) : 0; }

function aabbOverlap(posA, sizeA, posB, sizeB)
{
    return abs(posA.x-posB.x) < (sizeA.x+sizeB.x)/2 && abs(posA.y-posB.y) < (sizeA.y+sizeB.y)/2;
}

function addHitSpark(pos)
{
    hitSparks.push({pos:pos.copy(), frames:14});
}

function shake(frames, mag)
{
    screenShakeFrames = max(screenShakeFrames, frames);
    screenShakeMag = max(screenShakeMag, mag);
}

const ATTACKS = {
    punch: {name:'PUNCH', startup:6, active:6, recovery:10, dmg:6,  kb:0.55, kbY:0.35, hitSize:vec2(1.7,.9), hitOffset:vec2(1.45,1.15)},
    kick:  {name:'KICK',  startup:8, active:7, recovery:14, dmg:9,  kb:0.80, kbY:0.45, hitSize:vec2(2.1,1.0), hitOffset:vec2(1.75,1.10)},
};

class Fighter extends EngineObject
{
    constructor(pos, colorBody, controls, name)
    {
        super(pos, vec2(1.35, 3.05));
        this.bodyColor = colorBody;
        this.name = name;

        this.controls = controls;
        this.vel = vec2(0,0);
        this.grounded = false;

        this.health = MAX_HEALTH;
        this.wins = 0;

        this.facing = 1;
        this.blocking = false;

        this.hitstun = 0;
        this.blockstun = 0;

        this.attack = null; // {type, t, didHit}
        this.specialCooldown = 0;
        this.ko = false;

        this.renderOrder = 10;
    }

    canAct()
    {
        return !this.ko && this.hitstun<=0 && this.blockstun<=0 && !this.attack;
    }

    isHoldingBlock()
    {
        return keyIsDown(this.controls.block) && this.grounded && !this.ko;
    }

    startAttack(type)
    {
        const a = ATTACKS[type];
        if (!a) return;
        this.attack = {type, t: a.startup + a.active + a.recovery, didHit:false};
        (type==='punch' ? sPunch : sKick).play(this.pos);
    }

    spawnProjectile()
    {
        if (this.specialCooldown>0 || this.ko) return;
        this.specialCooldown = 90;

        const dir = this.facing;
        const start = this.pos.add(vec2(dir*1.7, 1.25));
        new Projectile(start, dir, this);
        sFire.play(this.pos);
    }

    applyHit(dmg, kbX, kbY, attacker)
    {
        if (this.ko) return;

        // can block only if facing attacker
        const dirToAttacker = sign0(attacker.pos.x - this.pos.x);
        const facingAttacker = dirToAttacker === this.facing;
        const blockingNow = this.isHoldingBlock() && facingAttacker;

        if (blockingNow)
        {
            const reduced = max(1, floor(dmg*0.2));
            this.health = max(0, this.health - reduced);
            this.blockstun = 14;
            this.vel.x = kbX * .25 * dirToAttacker;
            this.vel.y = max(this.vel.y, kbY * .25);
            addHitSpark(this.pos.add(vec2(this.facing*1.0, 1.4)));
            shake(6, .12);
            sBlock.play(this.pos);
            return;
        }

        this.health = max(0, this.health - dmg);
        this.hitstun = 18;
        this.vel.x = kbX * dirToAttacker;
        this.vel.y = max(this.vel.y, kbY);
        addHitSpark(this.pos.add(vec2(this.facing*1.0, 1.4)));
        shake(9, .20);
        sHit.play(this.pos);

        if (this.health <= 0)
            this.doKO(attacker);
    }

    doKO(attacker)
    {
        this.ko = true;
        this.hitstun = 0;
        this.blockstun = 0;
        this.attack = null;
        this.vel.y = max(this.vel.y, .9);

        // award win
        attacker.wins++;

        announce('KO!', 120);
        sKO.play(this.pos);
        roundOver = true;
        restartFrames = 140;
    }

    update()
    {
        // face opponent
        const opp = (this === p1) ? p2 : p1;
        if (opp)
            this.facing = this.pos.x < opp.pos.x ? 1 : -1;

        // cooldowns
        if (this.specialCooldown>0) this.specialCooldown--;

        // reduce stuns
        if (this.hitstun>0) this.hitstun--;
        if (this.blockstun>0) this.blockstun--;

        // attack timer
        if (this.attack)
        {
            this.attack.t--;
            if (this.attack.t <= 0)
                this.attack = null;
        }

        // input / movement
        const left  = keyIsDown(this.controls.left);
        const right = keyIsDown(this.controls.right);
        const jumpPressed = keyWasPressed(this.controls.jump);
        const punchPressed = keyWasPressed(this.controls.punch);
        const kickPressed  = keyWasPressed(this.controls.kick);
        const specialPressed = keyWasPressed(this.controls.special);

        this.blocking = this.isHoldingBlock();

        // if round is over, allow only physics
        if (!roundOver)
        {
            // start actions
            if (this.canAct())
            {
                if (specialPressed)
                    this.spawnProjectile();
                else if (punchPressed)
                    this.startAttack('punch');
                else if (kickPressed)
                    this.startAttack('kick');
            }

            // jump
            if (jumpPressed && this.grounded && !this.ko && this.hitstun<=0 && this.blockstun<=0)
            {
                this.vel.y = JUMP_VEL;
                this.grounded = false;
                sJump.play(this.pos);
            }
        }

        // horizontal control (reduced if blocking or attacking)
        let move = (right?1:0) - (left?1:0);
        if (this.ko || this.hitstun>0 || this.blockstun>0)
            move = 0;

        const speed = this.grounded ? MOVE_SPEED : AIR_SPEED;
        const slow = (this.blocking || this.attack) ? .55 : 1;
        this.vel.x += move * speed * slow;

        // cap horizontal speed
        this.vel.x = clamp(this.vel.x, -0.85, 0.85);

        // gravity
        this.vel.y -= GRAVITY;

        // integrate
        this.pos.x += this.vel.x;
        this.pos.y += this.vel.y;

        // world bounds
        this.pos.x = clamp(this.pos.x, -wallX, wallX);

        // ground
        const minY = groundY + this.size.y/2;
        if (this.pos.y < minY)
        {
            this.pos.y = minY;
            this.vel.y = 0;
            this.grounded = true;
        }
        else
            this.grounded = false;

        // friction
        if (this.grounded)
            this.vel.x *= (move ? 0.90 : FRICTION);
        else
            this.vel.x *= AIR_FRICTION;

        // resolve overlap with opponent
        if (opp && !this.destroyed)
        {
            const overlapX = (this.size.x + opp.size.x)/2 - abs(this.pos.x - opp.pos.x);
            const overlapY = (this.size.y + opp.size.y)/2 - abs(this.pos.y - opp.pos.y);
            if (overlapX > 0 && overlapY > 0)
            {
                const push = overlapX/2 + 0.001;
                const dir = sign0(this.pos.x - opp.pos.x) || this.facing;
                this.pos.x += dir * push;
                opp.pos.x -= dir * push;
            }
        }

        // process melee hitbox
        if (this.attack && !this.attack.didHit && !this.ko)
        {
            const a = ATTACKS[this.attack.type];
            const total = a.startup + a.active + a.recovery;
            const tFromStart = total - this.attack.t;
            const isActive = tFromStart >= a.startup && tFromStart < a.startup + a.active;

            if (isActive && opp && !opp.ko)
            {
                const dir = this.facing;
                const hitPos = this.pos.add(vec2(a.hitOffset.x*dir, a.hitOffset.y));
                if (aabbOverlap(hitPos, a.hitSize, opp.pos.add(vec2(0, 1.35)), opp.size.add(vec2(.2,.3))))
                {
                    this.attack.didHit = true;
                    opp.applyHit(a.dmg, a.kb, a.kbY, this);
                }
            }
        }
    }

    render()
    {
        // body
        const base = this.pos;
        const c = this.bodyColor;

        // shadow
        drawEllipse(vec2(base.x, groundY+.08), vec2(1.15, .23), rgb(0,0,0,.35));

        // main body
        drawRect(base.add(vec2(0, 1.35)), vec2(this.size.x, this.size.y), c);

        // head
        drawCircle(base.add(vec2(0, 2.95)), 0.62, c.lerp(WHITE,.25), 0, true);

        // facing stripe (helps readability)
        drawRect(base.add(vec2(this.facing*0.55, 1.55)), vec2(.25, 2.25), c.lerp(BLACK,.5));

        // block pose
        if (this.blocking && !this.ko)
        {
            drawRect(base.add(vec2(this.facing*1.05, 1.55)), vec2(.35, 1.35), c.lerp(WHITE,.35));
        }

        // show active hitbox (tiny hint)
        if (this.attack)
        {
            const a = ATTACKS[this.attack.type];
            const total = a.startup + a.active + a.recovery;
            const tFromStart = total - this.attack.t;
            const isActive = tFromStart >= a.startup && tFromStart < a.startup + a.active;
            if (isActive)
            {
                const hitPos = this.pos.add(vec2(a.hitOffset.x*this.facing, a.hitOffset.y));
                drawRect(hitPos, a.hitSize, rgb(1,1,1,.08), 0, true);
            }
        }

        // KO tilt
        if (this.ko)
        {
            drawLine(base.add(vec2(-.9, 2.7)), base.add(vec2(.9, 2.7)), rgb(0,0,0,.7), .12);
        }
    }
}

class Projectile extends EngineObject
{
    constructor(pos, dir, owner)
    {
        super(pos, vec2(.85,.35));
        this.dir = dir;
        this.owner = owner;
        this.speed = 0.55;
        this.life = 200;
        this.renderOrder = 9;
    }

    update()
    {
        if (roundOver) { this.destroy(); return; }

        this.pos.x += this.speed * this.dir;
        this.life--;

        // bounds
        if (this.pos.x < -wallX-2 || this.pos.x > wallX+2 || this.life<=0)
            return this.destroy();

        // hit opponent
        const target = (this.owner === p1) ? p2 : p1;
        if (target && !target.ko)
        {
            const hurtPos = target.pos.add(vec2(0, 1.35));
            const hurtSize = target.size.add(vec2(.2,.3));
            if (aabbOverlap(this.pos, this.size, hurtPos, hurtSize))
            {
                target.applyHit(12, 1.05, 0.55, this.owner);
                addHitSpark(this.pos.copy());
                shake(10, .22);
                this.destroy();
            }
        }
    }

    render()
    {
        drawRect(this.pos, this.size, rgb(1,.6,.2,.9));
        drawRect(this.pos.add(vec2(-.15*this.dir,0)), this.size.scale(.65), rgb(1,1,.7,.6));
    }
}

function resetRound()
{
    engineObjectsDestroy(true);
    hitSparks = [];
    roundFrames = ROUND_TIME_FRAMES;
    roundOver = false;
    restartFrames = 0;
    announce('FIGHT!', 70);

    // spawn fighters
    p1 = new Fighter(vec2(-8, groundY + 3.05/2), hsl(.55, .8, .55), {
        left:'KeyA', right:'KeyD', jump:'KeyW',
        punch:'KeyJ', kick:'KeyK', block:'KeyL', special:'KeyI'
    }, 'P1');

    p2 = new Fighter(vec2( 8, groundY + 3.05/2), hsl(.02, .85, .55), {
        left:'ArrowLeft', right:'ArrowRight', jump:'ArrowUp',
        punch:'KeyN', kick:'KeyM', block:'Comma', special:'Period'
    }, 'P2');

    // small intro freeze
    p1.vel = vec2(0,0);
    p2.vel = vec2(0,0);
}

function announce(text, frames=90)
{
    announceText = text;
    announceFrames = frames;
}

function resolveTimeOut()
{
    if (roundOver) return;
    roundOver = true;

    if (p1.health === p2.health)
        announce('DRAW!', 140);
    else if (p1.health > p2.health)
    {
        p1.wins++;
        announce('P1 WINS!', 140);
    }
    else
    {
        p2.wins++;
        announce('P2 WINS!', 140);
    }

    restartFrames = 140;
}

///////////////////////////////////////////////////////////////////////////////
function gameInit()
{
    // fixed 720p canvas
    setCanvasFixedSize(vec2(1280, 720));

    // camera
    cameraScale = 34;
    cameraPos = arenaCenter.copy();

    resetRound();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    // restart shortcut
    if (keyWasPressed('KeyR'))
        return resetRound();

    // update announcer
    if (announceFrames>0) announceFrames--;

    // update sparks
    hitSparks = hitSparks.filter(s => (s.frames--, s.frames>0));

    // round timer
    if (!roundOver)
    {
        if (roundFrames>0) roundFrames--;
        if (roundFrames<=0)
            resolveTimeOut();
    }
    else if (restartFrames>0)
    {
        restartFrames--;
        if (restartFrames<=0)
            resetRound();
    }

    // shake decay
    if (screenShakeFrames>0)
    {
        screenShakeFrames--;
        if (!screenShakeFrames)
            screenShakeMag = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // camera follows midpoint, with tiny shake
    let mid = arenaCenter.copy();
    if (p1 && p2)
        mid = p1.pos.lerp(p2.pos, .5).add(vec2(0, 1.8));

    let shakeOffset = vec2(0,0);
    if (screenShakeFrames>0)
        shakeOffset = randVec2(screenShakeMag);

    cameraPos = mid.add(shakeOffset);
    cameraPos.x = clamp(cameraPos.x, -6, 6);
    cameraPos.y = clamp(cameraPos.y, 5.5, 9.5);
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // background
    drawRect(arenaCenter.add(vec2(0, 8)), vec2(arenaSize.x, arenaSize.y), hsl(.62, .25, .18));

    // back wall / pillars
    for (let i=-3;i<=3;i++)
    {
        const x = i*5.2;
        drawRect(vec2(x, 8.2), vec2(1.3, 10.5), hsl(.62, .22, .12));
        drawRect(vec2(x, 3.3), vec2(1.0, 1.0), hsl(.62, .15, .20));
    }

    // floor
    drawRect(vec2(0, groundY-.05), vec2(arenaSize.x, .25), hsl(.1, .2, .22));
    drawRect(vec2(0, groundY-.35), vec2(arenaSize.x, 1.0), hsl(.1, .22, .16));

    // ring ropes
    for (let r=0;r<3;r++)
    {
        const y = 2.6 + r*1.1;
        drawLine(vec2(-arenaSize.x/2, y), vec2(arenaSize.x/2, y), rgb(1,1,1,.09), .08);
    }

    // floor grid
    for (let x=-18;x<=18;x++)
        drawLine(vec2(x, groundY+.12), vec2(x, groundY+.7), rgb(0,0,0,.15), .05);

    // sparks
    for (const s of hitSparks)
    {
        const p = clamp01(s.frames/14);
        const a = 0.5 + 0.5*(1-p);
        const len = 1.2 + (1-p)*1.6;
        for (let i=0;i<6;i++)
        {
            const dir = randVec2(1).normalize(1);
            const a2 = s.pos.add(dir.scale(.2));
            const b2 = s.pos.add(dir.scale(len));
            drawLine(a2, b2, rgb(1,1,.6,a*.8), .06);
        }
        drawCircle(s.pos, .55, rgb(1,1,.7,a*.35), 0, true);
    }
}

///////////////////////////////////////////////////////////////////////////////
function drawBar(posScreen, sizeScreen, pct, fillColor, outlineColor)
{
    const w = sizeScreen.x;
    const h = sizeScreen.y;
    const filled = vec2(w * clamp01(pct), h);

    // outline
    drawRectScreen(posScreen, sizeScreen, outlineColor);
    // fill
    const fillPos = posScreen.add(vec2(-(w-filled.x)/2, 0));
    drawRectScreen(fillPos, filled, fillColor);
}

function gameRenderPost()
{
    // HUD
    const pad = 18;
    const barSize = vec2(460, 22);
    const topY = 22;

    const p1Pct = p1 ? p1.health / MAX_HEALTH : 0;
    const p2Pct = p2 ? p2.health / MAX_HEALTH : 0;

    drawTextScreen('TINY KOMBAT', vec2(mainCanvasSize.x/2, 34), 38, hsl(.12,.25,.85), 4, hsl(0,0,0));

    drawBar(vec2(pad + barSize.x/2, topY), barSize, p1Pct, hsl(.33,.8,.55), rgb(0,0,0,.6));
    drawBar(vec2(mainCanvasSize.x-pad - barSize.x/2, topY), barSize, p2Pct, hsl(.0,.85,.55), rgb(0,0,0,.6));

    // names/wins
    const leftText  = `P1  W:${p1?.wins||0}`;
    const rightText = `P2  W:${p2?.wins||0}`;
    drawTextScreen(leftText,  vec2(pad + 80,  64), 26, hsl(0,0,1), 4, hsl(0,0,0));
    drawTextScreen(rightText, vec2(mainCanvasSize.x-pad-80, 64), 26, hsl(0,0,1), 4, hsl(0,0,0));

    // timer
    const t = ceil(roundFrames/60);
    drawTextScreen(`${t}`, vec2(mainCanvasSize.x/2, 72), 40, hsl(.12,.2,.9), 5, hsl(0,0,0));

    // announcer
    if (announceFrames>0)
    {
        const p = clamp01(announceFrames/70);
        const size = 84 + (1-p)*18;
        drawTextScreen(announceText, vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 110), size,
            hsl(.10,.35,.92), 8, hsl(0,0,0));
    }

    // controls hint
    const hint =
`P1: A/D move, W jump, J punch, K kick, L block, I special\n`+
`P2: ←/→ move, ↑ jump, N punch, M kick, , block, . special   |   R restart`;
    drawTextScreen(hint, vec2(mainCanvasSize.x/2, mainCanvasSize.y-34), 18, hsl(0,0,1,.85), 4, hsl(0,0,0,.7));
}

///////////////////////////////////////////////////////////////////////////////
// Startup LittleJS Engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
