<!DOCTYPE html><head>
<title>LittleJS Pinball</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/littlejs.js"></script>
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/box2d.wasm.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;

gravity = vec2(0, -30);
cameraPos = vec2(0, 0);
cameraScale = 32;

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Pinball Game

// Table dimensions
const TABLE_WIDTH = 12;
const TABLE_HEIGHT = 20;
const WALL_THICKNESS = 0.5;

// Game objects
let ball;
let leftFlipper, rightFlipper;
let leftFlipperJoint, rightFlipperJoint;
let plunger;
let plungerJoint;
let groundBody;
let bumpers = [];

// Game state
let score = 0;
let balls = 3;
let gameOver = false;
let plungerPower = 0;
let isPullingPlunger = false;

// Sounds
let sfxBumper, sfxFlipper, sfxLaunch, sfxLose, sfxWall;

///////////////////////////////////////////////////////////////////////////////
// Custom Bumper class
class Bumper
{
    constructor(pos, radius, points, color)
    {
        this.pos = pos;
        this.radius = radius;
        this.points = points;
        this.color = color;
        this.hitTimer = 0;
        
        // Create static body for the bumper
        this.body = new Box2dStaticObject(pos);
        this.body.addCircle(radius);
    }
    
    hit()
    {
        this.hitTimer = 0.2;
        score += this.points;
        sfxBumper && sfxBumper.play(this.pos);
    }
    
    update()
    {
        if (this.hitTimer > 0)
            this.hitTimer -= timeDelta;
    }
    
    render()
    {
        const flash = this.hitTimer > 0 ? 1.5 : 1;
        const size = this.radius * 2 * (this.hitTimer > 0 ? 1.15 : 1);
        drawCircle(this.pos, size, this.color.scale(flash, 1));
        drawCircle(this.pos, size * 0.6, WHITE);
        
        // Draw points value
        drawText(this.points.toString(), this.pos, this.radius * 0.8, BLACK, 0.1);
    }
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    await box2dInit();
    
    setCanvasFixedSize(vec2(720, 1080));
    canvasClearColor = hsl(0.6, 0.3, 0.15);
    cameraPos = vec2(0, 2);
    cameraScale = 48;
    
    // Sounds
    sfxBumper = new SoundGenerator({ frequency: 600, release: 0.08, pitchJump: 200, pitchJumpTime: 0.02, volume: 0.7 });
    sfxFlipper = new SoundGenerator({ frequency: 300, release: 0.05, slide: 0.5, volume: 0.5 });
    sfxLaunch = new SoundGenerator({ frequency: 150, release: 0.15, slide: 2, volume: 0.6 });
    sfxLose = new SoundGenerator({ frequency: 100, release: 0.4, slide: -0.5, noise: 0.1, volume: 0.7 });
    sfxWall = new SoundGenerator({ frequency: 400, release: 0.03, volume: 0.3 });
    
    // Create ground body for joints
    groundBody = new Box2dStaticObject(vec2(0, -20));
    
    createTable();
    createFlippers();
    createPlunger();
    createBumpers();
    spawnBall();
}

function createTable()
{
    const hw = TABLE_WIDTH / 2;
    const hh = TABLE_HEIGHT / 2;
    
    // Left wall
    const leftWall = new Box2dStaticObject(vec2(-hw - WALL_THICKNESS/2, 0));
    leftWall.addBox(vec2(WALL_THICKNESS, TABLE_HEIGHT + 2));
    leftWall.color = hsl(0.55, 0.6, 0.4);
    
    // Right wall (with gap for plunger lane)
    const rightWallTop = new Box2dStaticObject(vec2(hw + WALL_THICKNESS/2 + 1, 5));
    rightWallTop.addBox(vec2(WALL_THICKNESS, TABLE_HEIGHT - 10));
    rightWallTop.color = hsl(0.55, 0.6, 0.4);
    
    // Plunger lane right wall
    const plungerWall = new Box2dStaticObject(vec2(hw + 1.5 + WALL_THICKNESS/2, -2));
    plungerWall.addBox(vec2(WALL_THICKNESS, 14));
    plungerWall.color = hsl(0.55, 0.6, 0.4);
    
    // Top wall (curved would be nice but we'll use angled segments)
    const topWall = new Box2dStaticObject(vec2(0, hh + WALL_THICKNESS/2));
    topWall.addBox(vec2(TABLE_WIDTH + 3.5, WALL_THICKNESS));
    topWall.color = hsl(0.55, 0.6, 0.4);
    
    // Top corner guides
    const topLeftGuide = new Box2dStaticObject(vec2(-hw + 0.5, hh - 1.5));
    topLeftGuide.addPoly([vec2(0, 0), vec2(-1.5, -2), vec2(-1.5, 0)]);
    topLeftGuide.color = hsl(0.55, 0.6, 0.4);
    
    const topRightGuide = new Box2dStaticObject(vec2(hw + 1, hh - 1.5));
    topRightGuide.addPoly([vec2(0, 0), vec2(1.5, -2), vec2(1.5, 0)]);
    topRightGuide.color = hsl(0.55, 0.6, 0.4);
    
    // Lane separator at top right (between main area and plunger lane)
    const laneSep = new Box2dStaticObject(vec2(hw, 4));
    laneSep.addBox(vec2(WALL_THICKNESS, 12));
    laneSep.color = hsl(0.55, 0.6, 0.4);
    
    // Lane entrance curve at top
    const laneEntry = new Box2dStaticObject(vec2(hw + 0.5, hh - 3));
    laneEntry.addPoly([vec2(0, 0), vec2(0.8, 2), vec2(0.8, 0)]);
    laneEntry.color = hsl(0.55, 0.6, 0.4);
    
    // Bottom slants leading to flippers
    const leftSlant = new Box2dStaticObject(vec2(-hw + 1.2, -hh + 3.5));
    leftSlant.addPoly([vec2(-2, 3), vec2(-2, -1), vec2(0, -1)]);
    leftSlant.color = hsl(0.08, 0.7, 0.45);
    
    const rightSlant = new Box2dStaticObject(vec2(hw - 1.2, -hh + 3.5));
    rightSlant.addPoly([vec2(2, 3), vec2(2, -1), vec2(0, -1)]);
    rightSlant.color = hsl(0.08, 0.7, 0.45);
    
    // Outlane walls
    const leftOutlane = new Box2dStaticObject(vec2(-hw + 2.8, -hh + 2));
    leftOutlane.addBox(vec2(0.3, 3));
    leftOutlane.color = hsl(0.55, 0.6, 0.4);
    
    const rightOutlane = new Box2dStaticObject(vec2(hw - 2.8, -hh + 2));
    rightOutlane.addBox(vec2(0.3, 3));
    rightOutlane.color = hsl(0.55, 0.6, 0.4);
}

function createFlippers()
{
    const flipperLength = 2.2;
    const flipperHeight = 0.4;
    const flipperY = -TABLE_HEIGHT/2 + 1.5;
    const flipperSpacing = 1.4;
    
    // Left flipper
    leftFlipper = new Box2dObject(vec2(-flipperSpacing, flipperY));
    leftFlipper.addBox(vec2(flipperLength, flipperHeight));
    leftFlipper.color = hsl(0.0, 0.8, 0.5);
    
    // Create revolute joint for left flipper
    leftFlipperJoint = new Box2dRevoluteJoint(leftFlipper, groundBody, 
        vec2(-flipperSpacing - flipperLength/2 + 0.3, flipperY));
    //leftFlipperJoint.enableLimit(true);
    leftFlipperJoint.setLimits(-0.1, 0.55);
    leftFlipperJoint.enableMotor(true);
    leftFlipperJoint.setMotorSpeed(-15);
    leftFlipperJoint.setMaxMotorTorque(100);
    
    // Right flipper
    rightFlipper = new Box2dObject(vec2(flipperSpacing, flipperY));
    rightFlipper.addBox(vec2(flipperLength, flipperHeight));
    rightFlipper.color = hsl(0.0, 0.8, 0.5);
    
    // Create revolute joint for right flipper
    rightFlipperJoint = new Box2dRevoluteJoint(rightFlipper, groundBody,
        vec2(flipperSpacing + flipperLength/2 - 0.3, flipperY));
    //rightFlipperJoint.enableLimit(true);
    rightFlipperJoint.setLimits(-0.55, 0.1);
    rightFlipperJoint.enableMotor(true);
    rightFlipperJoint.setMotorSpeed(15);
    rightFlipperJoint.setMaxMotorTorque(100);
}

function createPlunger()
{
    const plungerX = TABLE_WIDTH/2 + 0.75;
    const plungerY = -TABLE_HEIGHT/2 - 0.5;
    
    // Plunger (dynamic body)
    plunger = new Box2dObject(vec2(plungerX, plungerY));
    plunger.addBox(vec2(1, 0.5));
    plunger.color = hsl(0.1, 0.8, 0.5);
    
    // Prismatic joint to constrain plunger movement
    plungerJoint = new Box2dPrismaticJoint(plunger, groundBody,
        vec2(plungerX, plungerY), vec2(0, 1));
    //plungerJoint.enableLimit(true);
    plungerJoint.setLimits(0, 2);
    plungerJoint.enableMotor(true);
    plungerJoint.setMotorSpeed(5);
    plungerJoint.setMaxMotorForce(20);
    
    // Plunger lane bottom
    const plungerBottom = new Box2dStaticObject(vec2(plungerX, plungerY - 1.5));
    plungerBottom.addBox(vec2(1.5, 0.5));
    plungerBottom.color = hsl(0.55, 0.6, 0.3);
}

function createBumpers()
{
    bumpers = [];
    
    // Top bumpers (triangle formation)
    bumpers.push(new Bumper(vec2(0, 5), 0.8, 100, hsl(0.0, 0.9, 0.55)));
    bumpers.push(new Bumper(vec2(-2, 3), 0.7, 50, hsl(0.15, 0.9, 0.55)));
    bumpers.push(new Bumper(vec2(2, 3), 0.7, 50, hsl(0.15, 0.9, 0.55)));
    
    // Middle bumpers
    bumpers.push(new Bumper(vec2(-1, 0), 0.6, 25, hsl(0.6, 0.9, 0.55)));
    bumpers.push(new Bumper(vec2(1.5, 1), 0.6, 25, hsl(0.6, 0.9, 0.55)));
    
    // Upper side bumpers
    bumpers.push(new Bumper(vec2(-4, 6), 0.5, 75, hsl(0.85, 0.9, 0.55)));
    bumpers.push(new Bumper(vec2(4, 6), 0.5, 75, hsl(0.85, 0.9, 0.55)));
}

function spawnBall()
{
    if (ball)
        ball.destroy();
    
    const plungerX = TABLE_WIDTH/2 + 0.75;
    ball = new Box2dObject(vec2(plungerX, -TABLE_HEIGHT/2 + 2));
    ball.addCircle(0.4);
    ball.color = hsl(0, 0, 0.85);
    
    isPullingPlunger = false;
    plungerPower = 0;
}

function resetGame()
{
    score = 0;
    balls = 3;
    gameOver = false;
    spawnBall();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    if (gameOver)
    {
        if (keyWasPressed('Space') || mouseWasPressed(0))
            resetGame();
        return;
    }
    
    // Flipper controls
    const leftActive = keyIsDown('ArrowLeft') || keyIsDown('KeyA') || keyIsDown('KeyZ');
    const rightActive = keyIsDown('ArrowRight') || keyIsDown('KeyD') || keyIsDown('Slash');
    
    // Control flippers via motor speed
    if (leftActive)
    {
        leftFlipperJoint.setMotorSpeed(25);
        if (keyWasPressed('ArrowLeft') || keyWasPressed('KeyA') || keyWasPressed('KeyZ'))
            sfxFlipper && sfxFlipper.play();
    }
    else
    {
        leftFlipperJoint.setMotorSpeed(-15);
    }
    
    if (rightActive)
    {
        rightFlipperJoint.setMotorSpeed(-25);
        if (keyWasPressed('ArrowRight') || keyWasPressed('KeyD') || keyWasPressed('Slash'))
            sfxFlipper && sfxFlipper.play();
    }
    else
    {
        rightFlipperJoint.setMotorSpeed(15);
    }
    
    // Plunger controls
    const plungerActive = keyIsDown('Space') || keyIsDown('ArrowDown');
    
    if (plungerActive)
    {
        isPullingPlunger = true;
        plungerPower = min(plungerPower + timeDelta * 2, 1);
        plungerJoint.setMotorSpeed(-8);
    }
    else if (isPullingPlunger)
    {
        // Release plunger!
        const launchForce = 40 + plungerPower * 60;
        plungerJoint.setMotorSpeed(launchForce);
        sfxLaunch && sfxLaunch.play();
        isPullingPlunger = false;
        plungerPower = 0;
    }
    else
    {
        plungerJoint.setMotorSpeed(5);
    }
    
    // Check ball collisions with bumpers
    if (ball)
    {
        const ballPos = ball.pos;
        const ballVel = ball.getVelocity();
        const ballSpeed = ballVel.length();
        
        for (const bumper of bumpers)
        {
            bumper.update();
            
            const dist = ballPos.distance(bumper.pos);
            if (dist < bumper.radius + 0.5 && ballSpeed > 2)
            {
                // Check if we just hit this bumper
                const dir = ballPos.subtract(bumper.pos).normalize();
                const velDir = ballVel.normalize();
                
                // Only trigger if moving toward bumper
                if (dir.dot(velDir) < 0.3)
                {
                    bumper.hit();
                }
            }
        }
        
        // Check if ball fell out
        if (ballPos.y < -TABLE_HEIGHT/2 - 2)
        {
            balls--;
            sfxLose && sfxLose.play();
            
            if (balls <= 0)
            {
                gameOver = true;
            }
            else
            {
                spawnBall();
            }
        }
        
        // Add some spin when ball hits walls
        if (abs(ballPos.x) > TABLE_WIDTH/2 - 1)
        {
            if (ballSpeed > 5)
                sfxWall && sfxWall.play(ballPos);
        }
    }
    
    // Restart
    if (keyWasPressed('KeyR'))
        resetGame();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // Keep camera centered on table
    cameraPos = vec2(0, 2);
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // Draw table background
    drawRect(vec2(0, 0), vec2(TABLE_WIDTH + 1, TABLE_HEIGHT + 2), hsl(0.55, 0.4, 0.2));
    
    // Draw playfield
    drawRect(vec2(0, 0), vec2(TABLE_WIDTH - 0.5, TABLE_HEIGHT - 0.5), hsl(0.35, 0.5, 0.25));
    
    // Draw plunger lane
    drawRect(vec2(TABLE_WIDTH/2 + 0.75, -2), vec2(1.3, 14), hsl(0.35, 0.4, 0.2));
    
    // Draw decorative lines
    drawLine(vec2(-4, -3), vec2(-2, 6), 0.08, hsl(0.15, 0.6, 0.5));
    drawLine(vec2(4, -3), vec2(2, 6), 0.08, hsl(0.15, 0.6, 0.5));
    
    // Draw target zones
    drawCircle(vec2(0, 7), 1.5, hsl(0.6, 0.3, 0.3));
    drawCircle(vec2(-3.5, 2), 1, hsl(0.1, 0.3, 0.3));
    drawCircle(vec2(3.5, 2), 1, hsl(0.1, 0.3, 0.3));
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    // Render bumpers (on top of balls)
    for (const bumper of bumpers)
        bumper.render();
    
    // Draw ball shine
    if (ball)
    {
        const shineOffset = vec2(-0.12, 0.12);
        drawCircle(ball.pos.add(shineOffset), 0.15, hsl(0, 0, 1, 0.6));
    }
    
    // Draw plunger power indicator
    if (isPullingPlunger)
    {
        const plungerX = TABLE_WIDTH/2 + 2.5;
        const barHeight = 6;
        const barY = -TABLE_HEIGHT/2 + 3;
        
        // Background
        drawRect(vec2(plungerX, barY), vec2(0.5, barHeight), hsl(0, 0, 0.2));
        
        // Power fill
        const fillHeight = barHeight * plungerPower;
        drawRect(vec2(plungerX, barY - barHeight/2 + fillHeight/2), 
            vec2(0.4, fillHeight), hsl(lerp(0.3, 0, plungerPower), 0.9, 0.5));
    }
    
    // HUD
    const hudY = 40;
    drawTextScreen('PINBALL', vec2(mainCanvasSize.x/2, hudY), 50, 
        hsl(0.1, 0.9, 0.6), 4, hsl(0, 0, 0));
    
    drawTextScreen('SCORE: ' + score, vec2(mainCanvasSize.x/2, hudY + 50), 32,
        WHITE, 3, BLACK);
    
    // Draw balls remaining
    const ballsText = 'BALLS: ';
    drawTextScreen(ballsText, vec2(mainCanvasSize.x/2 - 50, hudY + 85), 24, WHITE, 2, BLACK);
    for (let i = 0; i < balls; i++)
    {
        drawTextScreen('â—', vec2(mainCanvasSize.x/2 + 10 + i * 25, hudY + 85), 24, 
            hsl(0, 0, 0.85), 2, BLACK);
    }
    
    // Controls
    drawTextScreen('LEFT/RIGHT or A/D: Flippers   SPACE/DOWN: Launch   R: Restart',
        vec2(mainCanvasSize.x/2, mainCanvasSize.y - 30), 18, hsl(0, 0, 0.7), 2, BLACK);
    
    // Game over screen
    if (gameOver)
    {
        drawRect(cameraPos, vec2(100, 100), hsl(0, 0, 0, 0.7));
        drawTextScreen('GAME OVER', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 40), 60,
            hsl(0, 0.9, 0.6), 5, BLACK);
        drawTextScreen('Final Score: ' + score, vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 20), 36,
            WHITE, 3, BLACK);
        drawTextScreen('Press SPACE to play again', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 70), 24,
            hsl(0.15, 0.8, 0.6), 2, BLACK);
    }
}

///////////////////////////////////////////////////////////////////////////////
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body></html>
