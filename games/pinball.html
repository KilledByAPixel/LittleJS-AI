<!DOCTYPE html><head>
<title>LittleJS Pinball</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="../dist/littlejs.js?1.18.0"></script>
<script src="../dist/box2d.wasm.js?1.18.0"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;
showEngineVersion = false;
paused = false;

gravity = vec2(0, -30);
cameraPos = vec2(0, 0);
cameraScale = 32;

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,
            randomness = .05,
            frequency = 220,
            attack = 0,
            release = .1,
            shapeCurve = 1,
            slide = 0,
            pitchJump = 0,
            pitchJumpTime = 0,
            repeatTime = 0,
            noise = 0,
            bitCrush = 0,
            delay = 0,
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Pinball Game

// Table dimensions
const TABLE_WIDTH = 12;
const TABLE_HEIGHT = 20;
const WALL_THICKNESS = 0.5;

// Game objects
let ball;
let leftFlipper, rightFlipper;
let leftFlipperJoint, rightFlipperJoint;
let plunger;
let plungerJoint;
let groundBody;
let bumpers = [];

// Game state
let score = 0;
let balls = 3;
let gameOver = false;
let plungerPower = 0;
let isPullingPlunger = false;

// Sounds
let sfxBumper, sfxFlipper, sfxLaunch, sfxLose, sfxWall;

///////////////////////////////////////////////////////////////////////////////
// Custom Bumper class
class Bumper
{
    constructor(pos, radius, points, color)
    {
        this.pos = pos;
        this.radius = radius;
        this.points = points;
        this.color = color;
        this.hitTimer = 0;
        
        // Create static body for the bumper
        this.body = new Box2dStaticObject(pos);
        this.body.addCircle(radius);
    }
    
    hit()
    {
        this.hitTimer = 0.2;
        score += this.points;
        sfxBumper && sfxBumper.play(this.pos);
    }
    
    update()
    {
        if (this.hitTimer > 0)
            this.hitTimer -= timeDelta;
    }
    
    render()
    {
        const flash = this.hitTimer > 0 ? 1.5 : 1;
        const diameter = this.radius * 2 * (this.hitTimer > 0 ? 1.15 : 1);
        drawCircle(this.pos, diameter, this.color.scale(flash, 1));
        drawCircle(this.pos, diameter * 0.6, WHITE);
        
        // Draw points value - size based on diameter for proper fit
        drawText(this.points.toString(), this.pos, diameter * 0.4, BLACK, 0.05);
    }
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    await box2dInit();
    
    setCanvasFixedSize(vec2(720, 1080));
    canvasClearColor = hsl(0.6, 0.3, 0.15);
    cameraPos = vec2(0, 2);
    cameraScale = 48;
    
    // Sounds
    sfxBumper = new SoundGenerator({ frequency: 600, release: 0.08, pitchJump: 200, pitchJumpTime: 0.02, volume: 0.7 });
    sfxFlipper = new SoundGenerator({ frequency: 300, release: 0.05, slide: 0.5, volume: 0.5 });
    sfxLaunch = new SoundGenerator({ frequency: 150, release: 0.15, slide: 2, volume: 0.6 });
    sfxLose = new SoundGenerator({ frequency: 100, release: 0.4, slide: -0.5, noise: 0.1, volume: 0.7 });
    sfxWall = new SoundGenerator({ frequency: 400, release: 0.03, volume: 0.3 });
    
    // Create ground body for joints
    groundBody = new Box2dStaticObject(vec2(0, -20));
    
    createTable();
    createFlippers();
    createPlunger();
    createBumpers();
    spawnBall();
}

function createTable()
{
    const hw = TABLE_WIDTH / 2; // 6
    const hh = TABLE_HEIGHT / 2; // 10
    
    // Left wall - full height
    const leftWall = new Box2dStaticObject(vec2(-hw - WALL_THICKNESS/2, 0));
    leftWall.addBox(vec2(WALL_THICKNESS, TABLE_HEIGHT + 2));
    leftWall.color = hsl(0.55, 0.6, 0.4);
    
    // Right wall - only above the plunger lane entrance (stops at y=hh-3)
    const rightWallTop = new Box2dStaticObject(vec2(hw + WALL_THICKNESS/2, hh - 1.5));
    rightWallTop.addBox(vec2(WALL_THICKNESS, 3));
    rightWallTop.color = hsl(0.55, 0.6, 0.4);
    
    // Lane separator (between main play area and plunger lane) - doesn't go all the way up
    const laneSep = new Box2dStaticObject(vec2(hw, -2));
    laneSep.addBox(vec2(WALL_THICKNESS, 14));
    laneSep.color = hsl(0.55, 0.6, 0.4);
    
    // Plunger lane right wall
    const plungerWall = new Box2dStaticObject(vec2(hw + 1.5 + WALL_THICKNESS/2, -2));
    plungerWall.addBox(vec2(WALL_THICKNESS, 16));
    plungerWall.color = hsl(0.55, 0.6, 0.4);
    
    // Top wall
    const topWall = new Box2dStaticObject(vec2(0, hh + WALL_THICKNESS/2));
    topWall.addBox(vec2(TABLE_WIDTH + 3.5, WALL_THICKNESS));
    topWall.color = hsl(0.55, 0.6, 0.4);
    
    // Top left corner guide (angled)
    const topLeftGuide = new Box2dStaticObject(vec2(-hw + 0.5, hh - 1.5));
    topLeftGuide.addPoly([vec2(0, 0), vec2(-1.5, -2), vec2(-1.5, 0)]);
    topLeftGuide.color = hsl(0.55, 0.6, 0.4);
    
    // Curved top-right guide - series of polygon segments to loop ball from plunger lane
    // This creates a quarter-circle arc from the plunger lane into play area
    const curveSegments = 8;
    const curveRadiusInner = 1.5;
    const curveRadiusOuter = 2.0;
    const curveCenter = vec2(hw, hh - 2);
    
    // Build the curve as connected polygon segments
    for (let i = 0; i < curveSegments; i++)
    {
        const a1 = (i / curveSegments) * PI * 0.5; // 0 to 90 degrees
        const a2 = ((i + 1) / curveSegments) * PI * 0.5;
        
        // Inner and outer points for this segment
        const inner1 = vec2(Math.cos(a1) * curveRadiusInner, Math.sin(a1) * curveRadiusInner);
        const inner2 = vec2(Math.cos(a2) * curveRadiusInner, Math.sin(a2) * curveRadiusInner);
        const outer1 = vec2(Math.cos(a1) * curveRadiusOuter, Math.sin(a1) * curveRadiusOuter);
        const outer2 = vec2(Math.cos(a2) * curveRadiusOuter, Math.sin(a2) * curveRadiusOuter);
        
        const seg = new Box2dStaticObject(curveCenter);
        seg.addPoly([inner1, outer1, outer2, inner2]);
        seg.color = hsl(0.55, 0.6, 0.4);
    }
    
    // Bottom slants leading to flippers - positioned to not interfere with plunger lane
    const leftSlant = new Box2dStaticObject(vec2(-hw + 1.2, -hh + 3.5));
    leftSlant.addPoly([vec2(-2, 3), vec2(-2, -1), vec2(0, -1)]);
    leftSlant.color = hsl(0.08, 0.7, 0.45);
    
    // Right slant - moved left to avoid plunger lane
    const rightSlant = new Box2dStaticObject(vec2(hw - 2.2, -hh + 3.5));
    rightSlant.addPoly([vec2(2, 3), vec2(2, -1), vec2(0, -1)]);
    rightSlant.color = hsl(0.08, 0.7, 0.45);
    
    // Outlane walls (slingshot dividers)
    const leftOutlane = new Box2dStaticObject(vec2(-hw + 2.8, -hh + 2));
    leftOutlane.addBox(vec2(0.3, 3));
    leftOutlane.color = hsl(0.55, 0.6, 0.4);
    
    const rightOutlane = new Box2dStaticObject(vec2(hw - 3.8, -hh + 2));
    rightOutlane.addBox(vec2(0.3, 3));
    rightOutlane.color = hsl(0.55, 0.6, 0.4);
}

function createFlippers()
{
    const flipperLength = 2.2;
    const flipperHeight = 0.4;
    const flipperY = -TABLE_HEIGHT/2 + 1.5;
    const flipperSpacing = 1.4;
    const pivotOffset = flipperLength/2 - 0.3; // distance from center to pivot
    
    // Left flipper - pivot on left end, extends to the right
    const leftPivotX = -flipperSpacing;
    leftFlipper = new Box2dObject(vec2(leftPivotX + pivotOffset, flipperY));
    leftFlipper.addBox(vec2(flipperLength, flipperHeight));
    leftFlipper.color = hsl(0.0, 0.8, 0.5);
    
    // Create revolute joint for left flipper - pivot at left end
    leftFlipperJoint = new Box2dRevoluteJoint(leftFlipper, groundBody, 
        vec2(leftPivotX, flipperY));
    leftFlipperJoint.setLimits(-0.55, 0.1); // rest down, flip up
    leftFlipperJoint.enableMotor(true);
    leftFlipperJoint.setMotorSpeed(15); // positive to go down (rest position)
    leftFlipperJoint.setMaxMotorTorque(100);
    
    // Right flipper - pivot on right end, extends to the left
    const rightPivotX = flipperSpacing;
    rightFlipper = new Box2dObject(vec2(rightPivotX - pivotOffset, flipperY));
    rightFlipper.addBox(vec2(flipperLength, flipperHeight));
    rightFlipper.color = hsl(0.0, 0.8, 0.5);
    
    // Create revolute joint for right flipper - pivot at right end
    rightFlipperJoint = new Box2dRevoluteJoint(rightFlipper, groundBody,
        vec2(rightPivotX, flipperY));
    rightFlipperJoint.setLimits(-0.1, 0.55); // rest down, flip up
    rightFlipperJoint.enableMotor(true);
    rightFlipperJoint.setMotorSpeed(-15); // negative to go down (rest position)
    rightFlipperJoint.setMaxMotorTorque(100);
}

function createPlunger()
{
    const plungerX = TABLE_WIDTH/2 + 0.75;
    const plungerY = -TABLE_HEIGHT/2 + 1;
    
    // Plunger (dynamic body) - positioned in the lane to push ball
    plunger = new Box2dObject(vec2(plungerX, plungerY));
    plunger.addBox(vec2(0.8, 0.5));
    plunger.color = hsl(0.1, 0.8, 0.5);
    
    // Prismatic joint to constrain plunger movement vertically
    plungerJoint = new Box2dPrismaticJoint(plunger, groundBody,
        vec2(plungerX, plungerY), vec2(0, 1));
    plungerJoint.setLimits(-2, 0); // can move 2 units down from rest
    plungerJoint.enableMotor(true);
    plungerJoint.setMotorSpeed(0);
    plungerJoint.setMaxMotorForce(200);
    
    // Plunger lane bottom stopper
    const plungerBottom = new Box2dStaticObject(vec2(plungerX, -TABLE_HEIGHT/2 - 1));
    plungerBottom.addBox(vec2(1.5, 0.5));
    plungerBottom.color = hsl(0.55, 0.6, 0.3);
}

function createBumpers()
{
    bumpers = [];
    
    // Top bumpers (triangle formation)
    bumpers.push(new Bumper(vec2(0, 5), 0.8, 100, hsl(0.0, 0.9, 0.55)));
    bumpers.push(new Bumper(vec2(-2, 3), 0.7, 50, hsl(0.15, 0.9, 0.55)));
    bumpers.push(new Bumper(vec2(2, 3), 0.7, 50, hsl(0.15, 0.9, 0.55)));
    
    // Middle bumpers
    bumpers.push(new Bumper(vec2(-1, 0), 0.6, 25, hsl(0.6, 0.9, 0.55)));
    bumpers.push(new Bumper(vec2(1.5, 1), 0.6, 25, hsl(0.6, 0.9, 0.55)));
    
    // Upper side bumpers
    bumpers.push(new Bumper(vec2(-4, 6), 0.5, 75, hsl(0.85, 0.9, 0.55)));
    bumpers.push(new Bumper(vec2(4, 6), 0.5, 75, hsl(0.85, 0.9, 0.55)));
}

function spawnBall()
{
    if (ball)
        ball.destroy();
    
    const plungerX = TABLE_WIDTH/2 + 0.75;
    // Spawn ball just above the plunger, in the plunger lane
    ball = new Box2dObject(vec2(plungerX, -TABLE_HEIGHT/2 + 2));
    ball.addCircle(0.35); // radius for collision
    ball.color = hsl(0, 0, 0.85);
    ball.setLinearDamping(0.1);
    
    isPullingPlunger = false;
    plungerPower = 0;
}

function resetGame()
{
    score = 0;
    balls = 3;
    gameOver = false;
    spawnBall();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    if (gameOver)
    {
        if (keyWasPressed('Space') || mouseWasPressed(0))
            resetGame();
        return;
    }
    
    // Flipper controls
    const leftActive = keyIsDown('ArrowLeft') || keyIsDown('KeyA') || keyIsDown('KeyZ');
    const rightActive = keyIsDown('ArrowRight') || keyIsDown('KeyD') || keyIsDown('Slash');
    
    // Control flippers via motor speed
    if (leftActive)
    {
        leftFlipperJoint.setMotorSpeed(-25); // negative to flip up
        if (keyWasPressed('ArrowLeft') || keyWasPressed('KeyA') || keyWasPressed('KeyZ'))
            sfxFlipper && sfxFlipper.play();
    }
    else
    {
        leftFlipperJoint.setMotorSpeed(15); // positive to rest down
    }
    
    if (rightActive)
    {
        rightFlipperJoint.setMotorSpeed(25); // positive to flip up
        if (keyWasPressed('ArrowRight') || keyWasPressed('KeyD') || keyWasPressed('Slash'))
            sfxFlipper && sfxFlipper.play();
    }
    else
    {
        rightFlipperJoint.setMotorSpeed(-15); // negative to rest down
    }
    
    // Plunger controls
    const plungerActive = keyIsDown('Space') || keyIsDown('ArrowDown');
    
    if (plungerActive)
    {
        isPullingPlunger = true;
        plungerPower = min(plungerPower + timeDelta * 2, 1);
        plungerJoint.setMotorSpeed(-15); // pull down
    }
    else if (isPullingPlunger)
    {
        // Release plunger! Launch with force proportional to power
        const launchSpeed = 60 + plungerPower * 100;
        plungerJoint.setMotorSpeed(launchSpeed);
        sfxLaunch && sfxLaunch.play();
        isPullingPlunger = false;
        plungerPower = 0;
    }
    else
    {
        plungerJoint.setMotorSpeed(5);
    }
    
    // Check ball collisions with bumpers
    if (ball)
    {
        const ballPos = ball.pos;
        const ballVel = ball.getLinearVelocity();
        const ballSpeed = ballVel.length();
        
        for (const bumper of bumpers)
        {
            bumper.update();
            
            const dist = ballPos.distance(bumper.pos);
            if (dist < bumper.radius + 0.5 && ballSpeed > 2)
            {
                // Check if we just hit this bumper
                const dir = ballPos.subtract(bumper.pos).normalize();
                const velDir = ballVel.normalize();
                
                // Only trigger if moving toward bumper
                if (dir.dot(velDir) < 0.3)
                {
                    bumper.hit();
                }
            }
        }
        
        // Check if ball fell out
        if (ballPos.y < -TABLE_HEIGHT/2 - 2)
        {
            balls--;
            sfxLose && sfxLose.play();
            
            if (balls <= 0)
            {
                gameOver = true;
            }
            else
            {
                spawnBall();
            }
        }
        
        // Add some spin when ball hits walls
        if (abs(ballPos.x) > TABLE_WIDTH/2 - 1)
        {
            if (ballSpeed > 5)
                sfxWall && sfxWall.play(ballPos);
        }
    }
    
    // Restart
    if (keyWasPressed('KeyR'))
        resetGame();
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // Keep camera centered on table
    cameraPos = vec2(0, 2);
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // Draw table background
    drawRect(vec2(0.5, 0), vec2(TABLE_WIDTH + 3, TABLE_HEIGHT + 2), hsl(0.55, 0.4, 0.2));
    
    // Draw main playfield
    drawRect(vec2(0, 0), vec2(TABLE_WIDTH - 0.5, TABLE_HEIGHT - 0.5), hsl(0.35, 0.5, 0.25));
    
    // Draw plunger lane background
    drawRect(vec2(TABLE_WIDTH/2 + 0.75, 0), vec2(1.3, TABLE_HEIGHT), hsl(0.35, 0.4, 0.2));
    
    // Draw decorative lines (guide rails visual)
    drawLine(vec2(-4, -3), vec2(-2, 6), 0.08, hsl(0.15, 0.6, 0.5));
    drawLine(vec2(3, -3), vec2(1.5, 6), 0.08, hsl(0.15, 0.6, 0.5));
    
    // Draw target zones
    drawCircle(vec2(0, 7), 1.5, hsl(0.6, 0.3, 0.3));
    drawCircle(vec2(-3.5, 2), 1, hsl(0.1, 0.3, 0.3));
    drawCircle(vec2(2.5, 2), 1, hsl(0.1, 0.3, 0.3));
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    // Render bumpers (on top of balls)
    for (const bumper of bumpers)
        bumper.render();
    
    // Draw ball shine - size is diameter
    if (ball)
    {
        const shineOffset = vec2(-0.1, 0.1);
        drawCircle(ball.pos.add(shineOffset), 0.12, hsl(0, 0, 1, 0.6));
    }
    
    // Draw plunger power indicator
    if (isPullingPlunger)
    {
        const plungerX = TABLE_WIDTH/2 + 2.5;
        const barHeight = 6;
        const barY = -TABLE_HEIGHT/2 + 3;
        
        // Background
        drawRect(vec2(plungerX, barY), vec2(0.5, barHeight), hsl(0, 0, 0.2));
        
        // Power fill
        const fillHeight = barHeight * plungerPower;
        drawRect(vec2(plungerX, barY - barHeight/2 + fillHeight/2), 
            vec2(0.4, fillHeight), hsl(lerp(0.3, 0, plungerPower), 0.9, 0.5));
    }
    
    // HUD
    const hudY = 40;
    drawTextScreen('PINBALL', vec2(mainCanvasSize.x/2, hudY), 50, 
        hsl(0.1, 0.9, 0.6), 4, hsl(0, 0, 0));
    
    drawTextScreen('SCORE: ' + score, vec2(mainCanvasSize.x/2, hudY + 50), 32,
        WHITE, 3, BLACK);
    
    // Draw balls remaining
    const ballsText = 'BALLS: ';
    drawTextScreen(ballsText, vec2(mainCanvasSize.x/2 - 50, hudY + 85), 24, WHITE, 2, BLACK);
    for (let i = 0; i < balls; i++)
    {
        drawTextScreen('â—', vec2(mainCanvasSize.x/2 + 10 + i * 25, hudY + 85), 24, 
            hsl(0, 0, 0.85), 2, BLACK);
    }
    
    // Controls
    drawTextScreen('LEFT/RIGHT or A/D: Flippers   SPACE/DOWN: Launch   R: Restart',
        vec2(mainCanvasSize.x/2, mainCanvasSize.y - 30), 18, hsl(0, 0, 0.7), 2, BLACK);
    
    // Game over screen
    if (gameOver)
    {
        drawRect(cameraPos, vec2(100, 100), hsl(0, 0, 0, 0.7));
        drawTextScreen('GAME OVER', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 40), 60,
            hsl(0, 0.9, 0.6), 5, BLACK);
        drawTextScreen('Final Score: ' + score, vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 20), 36,
            WHITE, 3, BLACK);
        drawTextScreen('Press SPACE to play again', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 70), 24,
            hsl(0.15, 0.8, 0.6), 2, BLACK);
    }
}

///////////////////////////////////////////////////////////////////////////////
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body></html>
