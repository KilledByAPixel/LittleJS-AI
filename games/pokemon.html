<!DOCTYPE html><head>
<title>LittleJS AI Starter Project</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="../dist/littlejs.js?1.18.0"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false;      // Hide debug watermark in corner
showEngineVersion = false;   // Hide engine version console display
paused = false;              // Start unpaused

// engine settings, customize if necessary
gravity = vec2(0, 0);        // No gravity
cameraPos = vec2(0, 0);      // Camera centered at origin
cameraScale = 32;            // Camera zoom, larger is more zoomed in

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squareness of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb/flanger (seconds)
        } = params;
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Mini creature-catching RPG (inspired by monster battlers)
// - No external assets, only primitives (circles/rects/lines/text)
// - Walk in tall grass to trigger encounters
// - Turn-based battles: Strike / Guard / Heal / Capsule (capture)

// world
const worldSize = vec2(44, 26);
const playerSize = vec2(.85, .85);
const interactRadius = 1.2;

// areas/props
const obstacles = [];
const grassPatches = [];
let healerPos;

// player
let playerPos, playerDir, playerSpeed;
let encounterDistance, nextEncounterAt;

// party
let party = [];
let activeIndex = 0; // first critter
let money = 50;

// battle
let inBattle = false;
let battleEnemy = null;
let battleState = 'text'; // text | menu | end
let battleQueue = [];
let menuIndex = 0;

// transient battle flags
let playerGuard = false;
let enemyGuard = false;

// simple cooldowns (in turns)
let playerHealCD = 0;
let enemyHealCD = 0;

// sounds
const sfxStep      = new SoundGenerator({volume:.25, frequency:220, release:.05, noise:.02});
const sfxEncounter = new SoundGenerator({volume:.45, frequency:330, release:.18, slide:-1.2});
const sfxHit       = new SoundGenerator({volume:.35, frequency:180, release:.09, noise:.05, shapeCurve:.2});
const sfxHeal      = new SoundGenerator({volume:.35, frequency:520, release:.18, slide:1.2});
const sfxCapture   = new SoundGenerator({volume:.35, frequency:420, release:.22, repeatTime:.08, noise:.03});
const sfxWin       = new SoundGenerator({volume:.4,  frequency:660, release:.25, pitchJump:220, pitchJumpTime:.08});
const sfxLose      = new SoundGenerator({volume:.35, frequency:140, release:.35, slide:-.8});

// helpers
const clampVecInWorld = (p)=>
    vec2(clamp(p.x, -worldSize.x/2 + playerSize.x/2, worldSize.x/2 - playerSize.x/2),
         clamp(p.y, -worldSize.y/2 + playerSize.y/2, worldSize.y/2 - playerSize.y/2));

const overlapRect = (posA, sizeA, posB, sizeB)=> isOverlapping(posA, sizeA, posB, sizeB);

function tryMoveWithCollisions(pos, delta)
{
    let p = pos.copy();
    // x axis
    p.x += delta.x;
    p = clampVecInWorld(p);
    for (const o of obstacles)
        if (overlapRect(p, playerSize, o.pos, o.size))
            p.x -= delta.x, p.x = clamp(p.x, -worldSize.x/2 + playerSize.x/2, worldSize.x/2 - playerSize.x/2);
    // y axis
    p.y += delta.y;
    p = clampVecInWorld(p);
    for (const o of obstacles)
        if (overlapRect(p, playerSize, o.pos, o.size))
            p.y -= delta.y, p.y = clamp(p.y, -worldSize.y/2 + playerSize.y/2, worldSize.y/2 - playerSize.y/2);
    return p;
}

function inGrass(pos)
{
    for (const g of grassPatches)
        if (overlapRect(pos, playerSize, g.pos, g.size))
            return true;
    return false;
}

function nearHealer(pos)
{
    return pos.distance(healerPos) <= interactRadius;
}

// simple name generator
const nameA = ['Lo','Mi','Ka','Sa','Tu','Za','Po','Ri','Va','Ne','Chu','Fa','No','Ki','Ha','Be'];
const nameB = ['p','m','k','s','t','z','r','v','n','ch','f','h','b','d','g','l'];
const nameC = ['o','a','i','u','e'];
const nameD = ['n','m','k','s','t','z','r','v','l','x'];

function makeName()
{
    const a = nameA[randInt(nameA.length)];
    const b = nameB[randInt(nameB.length)];
    const c = nameC[randInt(nameC.length)];
    const d = randBool(.6) ? nameD[randInt(nameD.length)] : '';
    return (a + b + c + d).replace(/^\w/, m=>m.toUpperCase());
}

function makeCritter(level=1)
{
    const bodyType = randInt(3); // 0 round, 1 tall, 2 wide
    const hue = rand();
    const primary = hsl(hue, .6, .55);
    const accent  = hsl(mod(hue + .12), .65, .35);

    const maxHP = 20 + level*5 + randInt(0,6);
    return {
        id: randInt(1e9),
        name: makeName(),
        level,
        maxHP,
        hp: maxHP,
        atk: 5 + level*2 + randInt(0,4),
        def: 4 + level*2 + randInt(0,4),
        spd: 4 + level*2 + randInt(0,4),
        bodyType,
        primary,
        accent,
        exp: 0,
    };
}

function healPartyFull()
{
    for (const c of party) c.hp = c.maxHP;
}

function activeCritter(){ return party[activeIndex]; }

function critterAlive(c){ return c && c.hp > 0; }

function ensureActiveAlive()
{
    if (!critterAlive(activeCritter()))
    {
        // pick first alive
        const i = party.findIndex(critterAlive);
        activeIndex = i >= 0 ? i : 0;
    }
}

function hpBarColor(p)
{
    // simple red->yellow->green
    return p > .6 ? hsl(.33, .7, .45) : p > .3 ? hsl(.14, .8, .5) : hsl(0, .8, .5);
}

function calcDamage(attacker, defender, power, defenderGuarded)
{
    // tuned for less swingy combat
    const base = power + attacker.atk*.7 - defender.def*.5;
    const mult = rand(.90, 1.10);
    let dmg = max(1, (base * mult) | 0);
    if (defenderGuarded)
        dmg = max(1, (dmg * .6) | 0);
    return dmg;
}

function pushBattleText(t){ battleQueue.push(t); }

function startBattle()
{
    inBattle = true;
    battleState = 'text';
    menuIndex = 0;
    playerGuard = enemyGuard = false;
    playerHealCD = enemyHealCD = 0;

    const p = activeCritter();
    // Keep wild encounters fair: never more than 1 level higher than your active critter
    const level = clamp(p.level + randInt(-1, 1), 1, p.level + 1);
    battleEnemy = makeCritter(level);
    // slightly different tint for variety
    battleEnemy.primary = battleEnemy.primary.mutate?.(.06) || battleEnemy.primary;
    pushBattleText(`A wild ${battleEnemy.name} appeared!`);
    pushBattleText(`Go, ${p.name}!`);
    sfxEncounter.play();
}

function endBattle(victory)
{
    battleState = 'end';
    if (victory) sfxWin.play(); else sfxLose.play();
}

function awardExpAndMaybeLevelUp(c, amount)
{
    c.exp += amount;

    // quick & dirty leveling curve
    // (use a loop so big EXP can level multiple times, but cap to prevent runaway)
    let safety = 0;
    while (safety++ < 10)
    {
        const needed = 20 + c.level*10;
        if (c.exp < needed)
            break;

        c.exp -= needed;
        c.level++;
        c.maxHP += 4 + randInt(0,3);
        c.atk   += 1 + randInt(0,2);
        c.def   += 1 + randInt(0,2);
        c.spd   += 1 + randInt(0,2);
        c.hp = c.maxHP;
        pushBattleText(`${c.name} grew to Lv ${c.level}!`);
    }
}

function attemptCapture()
{
    const e = battleEnemy;
    const p = activeCritter();
    const hpPct = e.hp / e.maxHP;
    let chance = 0.18 + (1 - hpPct) * 0.62; // ~18% to ~80%
    chance = clamp(chance, .12, .85);
    sfxCapture.play();

    if (rand() < chance)
    {
        party.push(e);
        pushBattleText(`Captured ${e.name}!`);
        pushBattleText(`(Party size: ${party.length})`);
        // small reward
        money += 10;
        pushBattleText(`Found 10 coins.`);
        endBattle(true);
        return true;
    }
    pushBattleText(`${e.name} broke free!`);
    return false;
}

function enemyChooseMove()
{
    const e = battleEnemy;
    const hpPct = e.hp / e.maxHP;

    // Heal only if not on cooldown and actually hurt
    if (enemyHealCD === 0 && hpPct < .45 && randBool(.45))
        return 2; // Heal

    // Occasional guard if expecting damage
    if (hpPct < .7 && randBool(.18))
        return 1; // Guard

    return 0; // Strike
}

function doAction(actorIsPlayer, moveIndex)
{
    const actor = actorIsPlayer ? activeCritter() : battleEnemy;
    const target = actorIsPlayer ? battleEnemy : activeCritter();

    const actorName = actorIsPlayer ? actor.name : `Wild ${actor.name}`;
    const targetName = actorIsPlayer ? `Wild ${target.name}` : target.name;

    if (moveIndex === 0) // Strike
    {
        const power = 6;
        const guarded = actorIsPlayer ? enemyGuard : playerGuard;
        const dmg = calcDamage(actor, target, power, guarded);
        target.hp = max(0, target.hp - dmg);
        pushBattleText(`${actorName} used Strike!`);
        pushBattleText(`${targetName} took ${dmg} damage.`);
        sfxHit.play();

        // Guard is consumed when it reduces damage once
        if (actorIsPlayer) enemyGuard = false; else playerGuard = false;
    }
    else if (moveIndex === 1) // Guard
    {
        pushBattleText(`${actorName} used Guard!`);
        pushBattleText(`Damage will be reduced.`);
        if (actorIsPlayer) playerGuard = true; else enemyGuard = true;
    }
    else if (moveIndex === 2) // Heal
    {
        const heal = max(1, (actor.maxHP * .22) | 0);
        actor.hp = min(actor.maxHP, actor.hp + heal);
        pushBattleText(`${actorName} used Heal!`);
        pushBattleText(`Recovered ${heal} HP.`);
        sfxHeal.play();

        // put Heal on cooldown (2 turns)
        if (actorIsPlayer) playerHealCD = 2;
        else enemyHealCD = 2;

        // healing breaks the *other side's* guard posture (small balance nudge)
        if (actorIsPlayer) enemyGuard = false; else playerGuard = false;
    }
    else if (moveIndex === 3 && actorIsPlayer) // Capsule (player only)
    {
        pushBattleText(`${actorName} tossed a Capsule!`);
        attemptCapture();
    }
}

function resolveTurn(playerMove)
{
    // If capture succeeded, battleState already end, but we still allow queue to play out
    const p = activeCritter();
    const e = battleEnemy;

    const enemyMove = enemyChooseMove();

    // determine order by speed (tiny randomness)
    const pFirst = (p.spd + rand(-1,1)) >= (e.spd + rand(-1,1));

    doAction(pFirst, pFirst ? playerMove : enemyMove);
    if (!critterAlive(p) || !critterAlive(e) || battleState === 'end') return;

    doAction(!pFirst, pFirst ? enemyMove : playerMove);
    if (!critterAlive(p) || !critterAlive(e) || battleState === 'end') return;

    // end of turn cooldown ticks
    if (playerHealCD) playerHealCD--;
    if (enemyHealCD)  enemyHealCD--;

    // end of turn messages
    if (playerGuard) pushBattleText(`${p.name} is guarding.`);
    if (enemyGuard)  pushBattleText(`${e.name} is guarding.`);
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    // fixed canvas for consistent feel
    setCanvasFixedSize(vec2(1280, 720));
    canvasClearColor = hsl(0,0,.08);

    // build a tiny town + routes using simple rectangles
    obstacles.length = 0;
    grassPatches.length = 0;

    // boundary walls (thick)
    const bx = worldSize.x/2 + 1.5, by = worldSize.y/2 + 1.5;
    obstacles.push({pos: vec2(0,  by), size: vec2(worldSize.x+6, 3)});
    obstacles.push({pos: vec2(0, -by), size: vec2(worldSize.x+6, 3)});
    obstacles.push({pos: vec2( bx, 0), size: vec2(3, worldSize.y+6)});
    obstacles.push({pos: vec2(-bx, 0), size: vec2(3, worldSize.y+6)});

    // some houses/rocks
    obstacles.push({pos: vec2(-12, 6), size: vec2(7,5)});
    obstacles.push({pos: vec2(-2,  7), size: vec2(6,4)});
    obstacles.push({pos: vec2(10,  7), size: vec2(8,5)});
    obstacles.push({pos: vec2(16, -2), size: vec2(6,6)});
    obstacles.push({pos: vec2(-16,-6), size: vec2(6,6)});

    // tall grass patches
    grassPatches.push({pos: vec2(14,  -9), size: vec2(16,6)});
    grassPatches.push({pos: vec2(0,  -10), size: vec2(10,5)});
    grassPatches.push({pos: vec2(-14, -9), size: vec2(10,6)});

    healerPos = vec2(-12, 1);

    // spawn player
    playerPos = vec2(0, -1);
    playerDir = vec2(0,1);
    playerSpeed = 7.5;
    encounterDistance = 0;
    nextEncounterAt = rand(6, 11);

    // starter critter (start at level 1)
    party = [makeCritter(1)];
    activeIndex = 0;
    money = 50;
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    if (inBattle)
        return updateBattle();

    // overworld movement
    const run = keyIsDown('ShiftLeft') || keyIsDown('ShiftRight');
    const speed = playerSpeed * (run ? 1.5 : 1);

    const x = (keyIsDown('ArrowRight')||keyIsDown('KeyD')) - (keyIsDown('ArrowLeft')||keyIsDown('KeyA'));
    const y = (keyIsDown('ArrowUp')||keyIsDown('KeyW'))    - (keyIsDown('ArrowDown')||keyIsDown('KeyS'));
    let move = vec2(x, y);
    if (move.lengthSquared() > 1)
        move = move.normalize();

    const delta = move.scale(speed * timeDelta);
    const oldPos = playerPos.copy();
    playerPos = tryMoveWithCollisions(playerPos, delta);

    const movedDist = playerPos.distance(oldPos);
    if (movedDist > 0)
    {
        playerDir = move.lengthSquared() ? move.copy() : playerDir;
        if (randBool(.08)) sfxStep.play(); // occasional step tick
    }

    // healer interaction
    if (nearHealer(playerPos) && (keyWasPressed('KeyE') || keyWasPressed('Space')))
    {
        healPartyFull();
        money = max(0, money - 5);
        // tiny feedback via text pop in world
        debugText('Healed!', healerPos.add(vec2(0,1.2)), 1.2, '#0f0', .7);
        sfxHeal.play();
    }

    // encounters only if walking in grass
    if (movedDist > 0 && inGrass(playerPos))
    {
        encounterDistance += movedDist;
        if (encounterDistance >= nextEncounterAt)
        {
            encounterDistance = 0;
            nextEncounterAt = rand(6, 11);
            startBattle();
        }
    }
    else if (movedDist > 0)
    {
        // slowly "cool down" encounter meter outside grass
        encounterDistance = max(0, encounterDistance - movedDist*0.5);
    }
}

function updateBattle()
{
    ensureActiveAlive();

    const p = activeCritter();
    const e = battleEnemy;

    // if something fainted, enqueue results
    if (battleState !== 'end')
    {
        if (!critterAlive(e))
        {
            pushBattleText(`Wild ${e.name} fainted!`);
            const exp = 12 + e.level*4;
            pushBattleText(`${p.name} gained ${exp} EXP.`);
            awardExpAndMaybeLevelUp(p, exp);
            money += 8;
            pushBattleText(`Found 8 coins.`);
            endBattle(true);
        }
        else if (!critterAlive(p))
        {
            pushBattleText(`${p.name} fainted!`);
            endBattle(false);
        }
    }

    // advance text
    if (battleQueue.length)
    {
        if (keyWasPressed('Space') || keyWasPressed('Enter') || mouseWasPressed(0))
            battleQueue.shift();

        // IMPORTANT: don't overwrite 'end' state while showing queued end-of-battle text,
        // otherwise rewards can trigger repeatedly.
        return;
    }

    // no text queued, choose next state
    if (battleState === 'end')
    {
        // exit battle on confirm
        if (keyWasPressed('Space') || keyWasPressed('Enter') || mouseWasPressed(0))
        {
            inBattle = false;
            battleEnemy = null;
        }
        return;
    }

    battleState = 'menu';

    // menu navigation
    const left  = keyWasPressed('ArrowLeft')  || keyWasPressed('KeyA');
    const right = keyWasPressed('ArrowRight') || keyWasPressed('KeyD');
    const up    = keyWasPressed('ArrowUp')    || keyWasPressed('KeyW');
    const down  = keyWasPressed('ArrowDown')  || keyWasPressed('KeyS');

    // 2x2 menu layout
    if (left)  menuIndex = (menuIndex%2===1) ? menuIndex-1 : menuIndex;
    if (right) menuIndex = (menuIndex%2===0) ? menuIndex+1 : menuIndex;
    if (up)    menuIndex = (menuIndex>=2) ? menuIndex-2 : menuIndex;
    if (down)  menuIndex = (menuIndex<=1) ? menuIndex+2 : menuIndex;

    const confirm = keyWasPressed('Space') || keyWasPressed('Enter') || mouseWasPressed(0);
    if (confirm)
    {
        const chosen = menuIndex;

        // prevent choosing Heal while it's on cooldown (doesn't consume a turn)
        if (chosen === 2 && playerHealCD > 0)
        {
            pushBattleText('Heal is recharging!');
            return;
        }

        // player action + enemy response
        resolveTurn(chosen);

        // if player used capsule and capture succeeded, battleState becomes end
        // if queue is empty, still add a small separator
        if (!battleQueue.length && battleState !== 'end')
            pushBattleText('...');
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // keep camera centered on player in overworld, fixed in battle
    if (!inBattle)
    {
        cameraPos = playerPos.copy();
        cameraScale = 32;
    }
    else
    {
        cameraPos = vec2(0, 0);
        cameraScale = 24; // zoom out a bit so the battle UI fits on screen
    }
}

///////////////////////////////////////////////////////////////////////////////
function drawWorld()
{
    // base ground
    drawRect(cameraPos, vec2(200), hsl(.22, .25, .12));

    // "town path"
    drawRect(vec2(0, -2), vec2(worldSize.x-6, 6), hsl(.09, .25, .22));

    // grass
    for (const g of grassPatches)
    {
        drawRect(g.pos, g.size, hsl(.33, .55, .22));
        // little stripe detail
        for (let i=0; i<7; ++i)
        {
            const t = i/6;
            const x = lerp(g.pos.x - g.size.x/2 + 1, g.pos.x + g.size.x/2 - 1, t);
            drawLine(vec2(x, g.pos.y - g.size.y/2 + .6), vec2(x+.2, g.pos.y + g.size.y/2 - .6), .08, hsl(.33, .55, .28));
        }
    }

    // obstacles
    for (const o of obstacles)
        drawRect(o.pos, o.size, hsl(0,0,.18));

    // healer "shrine"
    drawCircle(healerPos, 1.5, hsl(.55,.65,.45));
    drawCircle(healerPos.add(vec2(0,.2)), .5, hsl(.55,.55,.60));
    drawText('HEAL', healerPos.add(vec2(0,1.1)), .7, hsl(0,0,1), 0.25, hsl(0,0,0));

    // player
    const body = playerPos;
    drawCircle(body, 1.0, hsl(.62,.15,.85));
    drawCircle(body.add(playerDir.scale(.35)), .35, hsl(.62,.25,.65));
    drawCircle(body.add(vec2(0,-.1)), .25, hsl(.62,.15,.95));
}

function drawCritterSprite(c, pos, facing=1, scale=1)
{
    // body
    const s = 2.3 * scale;
    const bodySize = c.bodyType === 0 ? vec2(s) : c.bodyType === 1 ? vec2(s*.9, s*1.25) : vec2(s*1.25, s*.9);
    drawRect(pos, bodySize, c.primary, 0, true);

    // head
    const headOffset = vec2(facing * (bodySize.x*.35), bodySize.y*.15);
    drawCircle(pos.add(headOffset), 1.1*scale, c.primary);

    // eye
    const eyeOffset = vec2(facing * .55*scale, .25*scale);
    drawCircle(pos.add(headOffset).add(eyeOffset), .28*scale, WHITE);
    drawCircle(pos.add(headOffset).add(eyeOffset).add(vec2(facing*.08, 0)), .14*scale, BLACK);

    // accent spots
    drawCircle(pos.add(vec2(-facing*.6*scale, -bodySize.y*.2)), .5*scale, c.accent);
    drawCircle(pos.add(vec2( facing*.2*scale, -bodySize.y*.35)), .35*scale, c.accent);

    // tail
    drawLine(pos.add(vec2(-facing*bodySize.x*.55, 0)), pos.add(vec2(-facing*(bodySize.x*.55 + 1.1*scale), .3*scale)), .18*scale, c.accent);
}

function drawHpBar(pos, size, hp, maxHp)
{
    const p = maxHp ? hp/maxHp : 0;
    drawRect(pos, size, hsl(0,0,.15), 0, true);
    const fill = vec2(size.x * clamp(p,0,1), size.y);
    drawRect(pos.add(vec2(-(size.x-fill.x)/2, 0)), fill, hpBarColor(p), 0, true);
    drawRect(pos, size, hsl(0,0,0,.6), 0, false);
}

function drawBattleUI()
{
    // arena background
    drawRect(cameraPos, vec2(200), hsl(.58, .25, .12));
    drawRect(vec2(0, 5), vec2(80, 32), hsl(.58, .15, .18));
    drawRect(vec2(0,-9), vec2(80, 32), hsl(.58, .12, .14));

    const p = activeCritter();
    const e = battleEnemy;

    // critters
    drawCritterSprite(e, vec2(10, 6.5), -1, 1.05);
    drawCritterSprite(p, vec2(-10,-5.0), 1, 1.15);

    // nameplates
    drawRect(vec2(-12, 8.8), vec2(18, 4.2), hsl(0,0,.10, .8), 0, true);
    drawText(`Wild ${e.name}  Lv ${e.level}`, vec2(-12, 9.5), .9, WHITE, .2, BLACK);
    drawHpBar(vec2(-12, 8.3), vec2(16, .9), e.hp, e.maxHP);

    drawRect(vec2(12, -2.7), vec2(18, 4.2), hsl(0,0,.10, .8), 0, true);
    drawText(`${p.name}  Lv ${p.level}`, vec2(12, -2.0), .9, WHITE, .2, BLACK);
    drawHpBar(vec2(12, -3.2), vec2(16, .9), p.hp, p.maxHP);

    // bottom panel
    const panelPos = vec2(0, -10.5);
    const panelSize = vec2(42, 9);
    drawRect(panelPos, panelSize, hsl(0,0,.06, .92), 0, true);
    drawRect(panelPos, panelSize, hsl(0,0,0,.55), 0, false);

    // text box
    const t = battleQueue.length ? battleQueue[0] : (battleState === 'end' ? 'Battle ended.' : 'Choose a move.');
    drawText(t, panelPos.add(vec2(-18, 1.8)), .95, WHITE, .25, BLACK, undefined, 'left');

    // menu
    if (!battleQueue.length && battleState === 'menu')
    {
        const options = [
            'Strike',
            'Guard',
            playerHealCD ? `Heal (CD ${playerHealCD})` : 'Heal',
            'Capsule'
        ];

        // Center the 2x2 grid inside the panel
        const cell = vec2(17, 2.7);
        const gridCenter = panelPos.add(vec2(0, 1.25));

        for (let i=0; i<4; ++i)
        {
            const cx = i%2, cy = (i/2)|0;
            const offset = vec2((cx - .5) * cell.x, (.5 - cy) * cell.y);
            const pos = gridCenter.add(offset);
            const selected = (i === menuIndex);
            drawRect(pos, vec2(cell.x-1.2, cell.y-0.4), selected ? hsl(.12,.8,.55,.9) : hsl(0,0,.12,.6), 0, true);
            drawRect(pos, vec2(cell.x-1.2, cell.y-0.4), hsl(0,0,0,.55), 0, false);
            drawText(options[i], pos.add(vec2(0,.1)), .9, WHITE, .25, BLACK);
        }

        drawText('Arrows/WASD + Enter/Space', panelPos.add(vec2(0,-3.7)), .65, hsl(0,0,1,.8), .2, BLACK);
    }
    else
    {
        drawText('Press Enter/Space', panelPos.add(vec2(0,-3.7)), .7, hsl(0,0,1,.8), .2, BLACK);
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    if (!inBattle)
        drawWorld();
    else
        drawBattleUI();
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    // HUD overlay
    if (!inBattle)
    {
        const p = activeCritter();
        const center = vec2(mainCanvasSize.x/2, 44);
        const line2  = vec2(mainCanvasSize.x/2, 78);
        const line3  = vec2(mainCanvasSize.x/2, 112);

        drawTextScreen(`Creature Catcher (inspired by classic monster RPGs)`, center, 28, hsl(0,0,1), 4, hsl(0,0,0));
        drawTextScreen(`Walk in tall grass for encounters.  E/Space at HEAL to restore party.`, line2, 22, hsl(0,0,1,.9), 4, hsl(0,0,0));
        drawTextScreen(`Party: ${party.length}   Active: ${p.name} Lv ${p.level}   Coins: ${money}`, line3, 22, hsl(0,0,1,.9), 4, hsl(0,0,0));

        if (inGrass(playerPos))
            drawTextScreen(`(Tall grass)`, vec2(mainCanvasSize.x/2, 146), 20, hsl(.33,.6,.55), 4, hsl(0,0,0));
        if (nearHealer(playerPos))
            drawTextScreen(`Press E/Space to heal (cost 5 coins)`, vec2(mainCanvasSize.x/2, mainCanvasSize.y-56), 24, hsl(.55,.65,.6), 4, hsl(0,0,0));
    }
}

///////////////////////////////////////////////////////////////////////////////
// Startup LittleJS Engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
