<!DOCTYPE html><head>
  <meta charset="utf-8"/>
  <title>LittleJS Space Invaders</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
  </style>
</head><body>
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.11/dist/littlejs.js"></script>
<script>
'use strict';

// engine settings
debugWatermark = false;
showEngineVersion = false;

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squareness of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
        } = params;
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

// ------------------------------------------------------------
// Game constants

const levelSize = vec2(60, 34);
const playMin = vec2(0, 0);
const playMax = levelSize;

const playerY = 3;
const barrierY = 8;

// ------------------------------------------------------------
// Global game state

let player;
let aliens = [];
let bullets = [];
let bombs = [];
let barriers = [];
let ufo = null;

let score = 0;
let hiScore = 0;
let lives = 3;
let nextBonusLife = 1000;
let currentLevel = 1;

let gameOver = false;
let gameWin = false;

let invaderDir = 1;
let invaderSpeed = .08;        // world units per frame (20% slower)
let invaderDrop = 1.0;         // world units
let invaderAnimTick = 0;

let alienShootTimer = 0;
let alienShootMin = 6;          // frames (2x faster firing)
let alienShootMax = 20;         // frames

let ufoSpawnTimer = 0;
let marchTimer = 0;
let marchBeat = 0;

let stars = [];
let credit = 0;

// Sounds
const sfxShoot    = new SoundGenerator({volume:.25, frequency:440, release:.03, shapeCurve:.3});
const sfxExplode  = new SoundGenerator({volume:.35, frequency:120, release:.22, noise:.2, shapeCurve:1.6, slide:-.4});
const sfxHit      = new SoundGenerator({volume:.28, frequency:280, release:.08, shapeCurve:1.2});
const sfxLoseLife = new SoundGenerator({volume:.40, frequency:180, release:.25, shapeCurve:1.8, slide:-.2});
const sfxUFO      = new SoundGenerator({volume:.25, frequency:350, release:.2, shapeCurve:.6, slide:.15});
const sfxBonusLife = new SoundGenerator({volume:.45, frequency:440, release:.35, shapeCurve:.5, pitchJump:220, pitchJumpTime:.1});
// Marching sounds - 4 alternating notes (higher frequency so they're audible)
const sfxMarch1   = new SoundGenerator({volume:.25, frequency:180, release:.08, shapeCurve:1.2});
const sfxMarch2   = new SoundGenerator({volume:.25, frequency:160, release:.08, shapeCurve:1.2});
const sfxMarch3   = new SoundGenerator({volume:.25, frequency:140, release:.08, shapeCurve:1.2});
const sfxMarch4   = new SoundGenerator({volume:.25, frequency:120, release:.08, shapeCurve:1.2});

// ------------------------------------------------------------
// Helpers

function clampToPlayfield(pos, halfSize)
{
    pos.x = clamp(pos.x, playMin.x + halfSize.x, playMax.x - halfSize.x);
    pos.y = clamp(pos.y, playMin.y + halfSize.y, playMax.y - halfSize.y);
    return pos;
}

function aabbOverlap(a, b)
{
    return isOverlapping(a.pos, a.size, b.pos, b.size);
}

function randIntInclusive(a, b)
{
    return (rand(a, b+1) | 0);
}

function setRandomAlienShootTimer()
{
    alienShootTimer = randIntInclusive(alienShootMin, alienShootMax);
}

function createExplosion(pos, color, count = 10)
{
    // Simple particle explosion using LittleJS ParticleEmitter
    new ParticleEmitter(
        pos, 0,                     // pos, angle
        vec2(0.3),                  // emitSize
        .1, count * 10,             // emitTime, emitRate
        PI*2,                       // emitConeAngle
        undefined,                  // tileInfo
        color, color,               // colorStartA, colorStartB
        color.scale(1,0), color.scale(1,0), // colorEndA, colorEndB
        .4, .35, .08,               // particleTime, sizeStart, sizeEnd
        .25, 0,                     // speed (reduced), angleSpeed
        .92, 1,                     // damping, angleDamping
        0,                          // gravityScale
        PI, .1, 1                   // cone, fadeRate, randomness
    );
}

function resetGame()
{
    // clear objects
    engineObjectsDestroy(true);

    aliens.length = 0;
    bullets.length = 0;
    bombs.length = 0;
    barriers.length = 0;
    ufo = null;

    score = 0;
    lives = 3;
    nextBonusLife = 1000;
    currentLevel = 1;
    gameOver = false;
    gameWin = false;

    startLevel();
}

function startLevel()
{
    // Clear remaining projectiles
    for (const b of bullets) b.destroy();
    for (const bomb of bombs) bomb.destroy();
    bullets.length = 0;
    bombs.length = 0;
    
    // Destroy old aliens if any
    for (const a of aliens) a.destroy();
    aliens.length = 0;
    
    // Destroy old barriers
    for (const br of barriers) br.destroy();
    barriers.length = 0;

    invaderDir = 1;
    // Base speed increases with level
    const baseSpeed = .08 + (currentLevel - 1) * .015;
    invaderSpeed = baseSpeed;
    invaderDrop = 1.0;
    invaderAnimTick = 0;

    // Shooting gets faster each level
    const levelShootBonus = (currentLevel - 1) * 2;
    alienShootMin = max(3, 6 - levelShootBonus);
    alienShootMax = max(10, 20 - levelShootBonus * 2);
    setRandomAlienShootTimer();
    
    ufoSpawnTimer = randIntInclusive(300, 600);
    marchTimer = 40;
    marchBeat = 0;

    if (!player || player.destroyed)
        player = new Player(vec2(levelSize.x/2, playerY));
    else
        player.pos = vec2(levelSize.x/2, playerY);
        
    createBarriers();
    createAliens();
}

// ------------------------------------------------------------
// Objects

class RectObject extends EngineObject
{
    constructor(pos, size, color)
    {
        super(pos, size);
        this.color = color || WHITE;
        this.renderOrder = 0;
    }
    render()
    {
        drawRect(this.pos, this.size, this.color);
    }
}

class Player extends RectObject
{
    constructor(pos)
    {
        super(pos, vec2(3.2, 1.4), rgb(.2,.9,.95));
        this.cooldown = 0;
        this.renderOrder = 10;
    }
    update()
    {
        if (gameOver || gameWin)
            return;

        // left/right move (no dt; fixed 60fps)
        let move = 0;
        if (keyIsDown('ArrowLeft') || keyIsDown('KeyA')) move -= 1;
        if (keyIsDown('ArrowRight') || keyIsDown('KeyD')) move += 1;
        this.pos.x += move * .55;
        
        // Mouse control - follow mouse X position instantly
        if (mousePos.x >= playMin.x && mousePos.x <= playMax.x)
        {
            this.pos.x = mousePos.x;
        }
        
        clampToPlayfield(this.pos, this.size.scale(.5));

        // shoot with keyboard or mouse (hold to shoot)
        if (this.cooldown > 0) this.cooldown--;
        if (this.cooldown === 0 && (keyIsDown('Space') || keyIsDown('KeyK') || mouseIsDown(0)))
        {
            this.cooldown = 20;
            bullets.push(new Bullet(this.pos.add(vec2(0, this.size.y/2 + .6)), vec2(0, 1.2), true));
            sfxShoot.play(this.pos);
        }
    }
    
    render()
    {
        // Classic player ship sprite
        const p = this.pos;
        const s = .22;
        
        drawRect(p.add(vec2(0,.3)), vec2(s,s*2), this.color); // cannon
        drawRect(p, vec2(s*7,s*3), this.color); // main body
        drawRect(p.add(vec2(-1.1,-.3)), vec2(s*2,s), this.color); // left wing
        drawRect(p.add(vec2(1.1,-.3)), vec2(s*2,s), this.color); // right wing
    }
}

class Alien extends RectObject
{
    constructor(pos, row)
    {
        const colors = [
            rgb(.95,.2,.2),   // row 0 - red (top)
            rgb(.2,.95,.2),   // row 1 - green
            rgb(.25,.85,.95), // row 2 - cyan
            rgb(.95,.4,.95),  // row 3 - magenta
            rgb(.95,.95,.2)   // row 4 - yellow (bottom)
        ];
        const base = colors[row % 5];
        super(pos, vec2(2.3, 1.6), base);
        this.row = row;
        this.renderOrder = 5;
        this.flash = 0;
        this.animOffset = randIntInclusive(0, 15); // stagger animation per alien
    }
    render()
    {
        const frame = ((invaderAnimTick + this.animOffset) >> 3) & 1;
        
        // Draw pixelated alien sprites based on row type
        if (this.row === 0) {
            // Top row - squid
            this.renderSquid(frame);
        } else if (this.row === 1 || this.row === 2) {
            // Middle rows - crab
            this.renderCrab(frame);
        } else {
            // Bottom rows - octopus
            this.renderOctopus(frame);
        }

        if (this.flash)
        {
            drawRect(this.pos, this.size.add(vec2(.2,.2)), rgb(1,1,1,.55));
            this.flash--;
        }
    }
    
    renderSquid(frame)
    {
        const p = this.pos;
        const s = .22; // pixel size
        
        if (frame === 0) {
            // Frame 1
            drawRect(p.add(vec2(0,.6)), vec2(s*3,s), this.color); // top
            drawRect(p.add(vec2(-.6,.3)), vec2(s,s*3), this.color); // left antenna
            drawRect(p.add(vec2(.6,.3)), vec2(s,s*3), this.color); // right antenna
            drawRect(p.add(vec2(0,0)), vec2(s*6,s*4), this.color); // body
            drawRect(p.add(vec2(-0.8,-.5)), vec2(s,s*2), this.color); // legs
            drawRect(p.add(vec2(-0.3,-.5)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(0.3,-.5)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(0.8,-.5)), vec2(s,s*2), this.color);
        } else {
            // Frame 2
            drawRect(p.add(vec2(0,.6)), vec2(s*3,s), this.color);
            drawRect(p.add(vec2(-.6,.3)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.6,.3)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(0,0)), vec2(s*6,s*4), this.color);
            drawRect(p.add(vec2(-0.8,-.4)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.8,-.4)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(-0.3,-.6)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.3,-.6)), vec2(s*2,s), this.color);
        }
    }
    
    renderCrab(frame)
    {
        const p = this.pos;
        const s = .22;
        
        if (frame === 0) {
            drawRect(p.add(vec2(-.8,.5)), vec2(s,s*2), this.color); // claws up
            drawRect(p.add(vec2(.8,.5)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(0,.3)), vec2(s*7,s*2), this.color); // top
            drawRect(p.add(vec2(0,0)), vec2(s*5,s*3), this.color); // body
            drawRect(p.add(vec2(-0.9,-.3)), vec2(s*2,s), this.color); // legs
            drawRect(p.add(vec2(-0.4,-.5)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.4,-.5)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.9,-.3)), vec2(s*2,s), this.color);
        } else {
            drawRect(p.add(vec2(-.8,.3)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(.8,.3)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(0,.3)), vec2(s*7,s*2), this.color);
            drawRect(p.add(vec2(0,0)), vec2(s*5,s*3), this.color);
            drawRect(p.add(vec2(-0.6,-.4)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(-0.9,-.5)), vec2(s,s), this.color);
            drawRect(p.add(vec2(0.6,-.4)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.9,-.5)), vec2(s,s), this.color);
        }
    }
    
    renderOctopus(frame)
    {
        const p = this.pos;
        const s = .22;
        
        if (frame === 0) {
            drawRect(p.add(vec2(0,.4)), vec2(s*5,s*3), this.color); // head
            drawRect(p.add(vec2(-.8,0)), vec2(s,s*3), this.color); // arms
            drawRect(p.add(vec2(-.3,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.3,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.8,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(-0.6,-.4)), vec2(s,s), this.color); // legs bent out
            drawRect(p.add(vec2(0.6,-.4)), vec2(s,s), this.color);
        } else {
            drawRect(p.add(vec2(0,.4)), vec2(s*5,s*3), this.color);
            drawRect(p.add(vec2(-.8,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(-.3,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.3,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.8,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(-0.4,-.4)), vec2(s,s), this.color); // legs bent in
            drawRect(p.add(vec2(0.4,-.4)), vec2(s,s), this.color);
        }
    }
}

class Bullet extends RectObject
{
    constructor(pos, vel, fromPlayer)
    {
        super(pos, vec2(.25, 1.2), fromPlayer ? rgb(.95,.95,.95) : rgb(.95,.3,.3));
        this.vel = vel; // per frame
        this.fromPlayer = fromPlayer;
        this.renderOrder = 20;
    }
    update()
    {
        this.pos = this.pos.add(this.vel);
        if (this.pos.y > playMax.y + 2 || this.pos.y < playMin.y - 2)
            this.destroy();
    }
    render()
    {
        // Thinner, taller bullets
        drawRect(this.pos, this.size, this.color);
    }
}

class Bomb extends RectObject
{
    constructor(pos)
    {
        super(pos, vec2(.3, 1.0), rgb(.95,.95,.95));
        this.vel = vec2(0, -0.32);
        this.renderOrder = 20;
        this.animTick = 0;
    }
    update()
    {
        if (gameOver || gameWin)
            return;

        this.pos = this.pos.add(this.vel);
        this.animTick++;
        if (this.pos.y < playMin.y - 2)
            this.destroy();
    }
    
    render()
    {
        // Animated bomb - squiggly effect
        const frame = (this.animTick >> 2) % 4;
        const offset = [-.15, -.05, .05, .15][frame];
        drawRect(this.pos.add(vec2(offset, .3)), vec2(.25, .3), this.color);
        drawRect(this.pos.add(vec2(-offset, 0)), vec2(.25, .3), this.color);
        drawRect(this.pos.add(vec2(offset, -.3)), vec2(.25, .3), this.color);
    }
}

class BarrierBlock extends RectObject
{
    constructor(pos)
    {
        super(pos, vec2(.95,.95), rgb(.95,.25,.25));
        this.renderOrder = 8;
    }
}

class UFO extends RectObject
{
    constructor()
    {
        const dir = rand() < .5 ? 1 : -1;
        const startX = dir > 0 ? -3 : levelSize.x + 3;
        super(vec2(startX, levelSize.y - 2), vec2(3, 1.4), rgb(.95,.25,.25));
        this.velocity = vec2(dir * .08, 0);
        this.renderOrder = 15;
        this.pointValue = [50, 100, 150, 300][randIntInclusive(0, 3)];
        this.showPoints = 0;
        this.soundTimer = 0;
    }
    
    update()
    {
        if (this.showPoints > 0)
        {
            this.showPoints--;
            if (this.showPoints === 0)
                this.destroy();
            return;
        }
        
        this.pos = this.pos.add(this.velocity);
        
        // Play UFO sound every ~60 frames (1 second)
        this.soundTimer++;
        if (this.soundTimer >= 60)
        {
            this.soundTimer = 0;
            sfxUFO.play(this.pos);
        }
        
        if (this.pos.x < -5 || this.pos.x > levelSize.x + 5)
            this.destroy();
    }
    
    render()
    {
        const p = this.pos;
        const s = .22;
        
        // Classic UFO sprite
        drawRect(p.add(vec2(0,.3)), vec2(s*6, s), this.color);
        drawRect(p, vec2(s*10, s*2), this.color);
        drawRect(p.add(vec2(0,-.3)), vec2(s*6, s), this.color);
        // Windows
        drawRect(p.add(vec2(-.6,.1)), vec2(s,s), rgb(0,0,0));
        drawRect(p.add(vec2(0,.1)), vec2(s,s), rgb(0,0,0));
        drawRect(p.add(vec2(.6,.1)), vec2(s,s), rgb(0,0,0));
    }
}

// ------------------------------------------------------------
// Level creation

function createAliens()
{
    const cols = 11;
    const rows = 5;
    const startX = levelSize.x/2 - (cols-1)*2.8/2;
    const startY = levelSize.y - 6;
    const spacing = vec2(2.8, 2.3);

    for (let r=0; r<rows; r++)
    for (let c=0; c<cols; c++)
    {
        const p = vec2(startX + c*spacing.x, startY - r*spacing.y);
        aliens.push(new Alien(p, r));
    }
}

function createBarriers()
{
    const barrierCount = 4;
    const gap = levelSize.x/(barrierCount+1);

    for (let i=1; i<=barrierCount; i++)
    {
        const cx = gap*i;
        const cy = barrierY;

        // blocky classic shield shape - arch at top
        const w = 8;
        const h = 5;
        for (let y=0; y<h; y++)
        for (let x=0; x<w; x++)
        {
            // carve arch at the TOP (flipped vertically)
            const notch = (y===h-1 && (x===0||x===w-1)) ||
                          (y===h-2 && (x===0||x===w-1)) ||
                          (y<=1 && (x===3 || x===4) && y===0);
            if (notch) continue;

            const px = cx + (x - (w-1)/2)*1.0;
            const py = cy + (y - (h-1)/2)*1.0;
            const b = new BarrierBlock(vec2(px, py));
            barriers.push(b);
        }
    }
}

// ------------------------------------------------------------
// Game loop

function gameInit()
{
    setCanvasFixedSize(vec2(960, 540));
    setCameraPos(levelSize.scale(.5));
    cameraScale = 16; // pixels per world unit

    // No starfield for classic look
    stars = [];

    resetGame();
}

function gameUpdate()
{
    // restart
    if ((gameOver || gameWin) && keyWasPressed('Enter'))
        resetGame();

    invaderAnimTick++;

    if (gameOver || gameWin)
        return;

    updateInvaders();
    updateUFO();
    updateCollisions();
    cleanupArrays();
    updateMarchingSound();

    // win condition - start next level
    if (!aliens.length)
    {
        currentLevel++;
        startLevel();
    }
}

function gameUpdatePost()
{
    setCameraPos(levelSize.scale(.5));
}

function gameRender()
{
    // Pure black background
    drawRect(cameraPos, levelSize.add(vec2(20,20)), rgb(0,0,0));

    // playfield
    drawRect(cameraPos, levelSize, rgb(0,0,0));

    // Green floor line right below the player
    drawRect(vec2(levelSize.x/2, playerY - 0.8), vec2(levelSize.x, .15), rgb(.2,.95,.25));
}

function gameRenderPost()
{
    // Classic arcade HUD
    const hudY = 30;
    const color = rgb(.2,.95,.25);
    
    // SCORE at top left
    drawTextScreen('SCORE', vec2(80, hudY), 26, color);
    drawTextScreen(String(score).padStart(4, '0'), vec2(80, hudY + 32), 26, rgb(.95,.95,.95));
    
    // HI-SCORE on top right only
    drawTextScreen('HI-SCORE', vec2(mainCanvasSize.x - 100, hudY), 26, color);
    drawTextScreen(String(hiScore).padStart(4, '0'), vec2(mainCanvasSize.x - 100, hudY + 32), 26, rgb(.95,.95,.95));
    
    // Lives indicator with ship icons at bottom - below the green line
    const livesY = mainCanvasSize.y - 22;
    for (let i = 0; i < lives - 1 && i < 5; i++)
    {
        const px = 50 + i * 45;
        const py = livesY;
        // Draw mini player ships using filled rectangles via canvas
        const shipColor = rgb(.2,.9,.95);
        mainContext.fillStyle = shipColor.toString();
        mainContext.fillRect(px - 2, py - 8, 4, 6); // cannon
        mainContext.fillRect(px - 12, py - 2, 24, 8); // body
        mainContext.fillRect(px - 16, py + 2, 6, 4); // left wing
        mainContext.fillRect(px + 10, py + 2, 6, 4); // right wing
    }

    if (gameOver)
    {
        drawTextScreen('GAME OVER', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 20), 80, rgb(.95,.25,.25), 8, rgb(0,0,0));
        drawTextScreen('Press Enter', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 45), 34, rgb(.95,.95,.95), 6, rgb(0,0,0));
    }
    else if (gameWin)
    {
        drawTextScreen('YOU WIN!', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 20), 80, rgb(.25,.95,.35), 8, rgb(0,0,0));
        drawTextScreen('Press Enter', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 45), 34, rgb(.95,.95,.95), 6, rgb(0,0,0));
    }
}

// ------------------------------------------------------------
// Invaders movement + shooting

function updateInvaders()
{
    if (!aliens.length)
        return;

    // compute formation bounds
    let minX = 1e9, maxX = -1e9, minY = 1e9;
    for (const a of aliens)
    {
        const half = a.size.x/2;
        minX = min(minX, a.pos.x - half);
        maxX = max(maxX, a.pos.x + half);
        minY = min(minY, a.pos.y - a.size.y/2);
    }

    const nextMinX = minX + invaderDir * invaderSpeed;
    const nextMaxX = maxX + invaderDir * invaderSpeed;

    let hitEdge = false;
    if (nextMinX < playMin.x + 1.2) hitEdge = true;
    if (nextMaxX > playMax.x - 1.2) hitEdge = true;

    if (hitEdge)
    {
        invaderDir *= -1;
        for (const a of aliens)
            a.pos.y -= invaderDrop;

        // speed up as they descend
        invaderSpeed = min(invaderSpeed + .02, .5);
        alienShootMin = max(alienShootMin - 1, 3);
        alienShootMax = max(alienShootMax - 2, 8);
    }
    else
    {
        // Speed boost based on how few aliens remain (twice as fast effect)
        const aliveCount = aliens.length;
        const speedMultiplier = 1 + (55 - aliveCount) * 0.04; // up to 2.2x faster
        for (const a of aliens)
            a.pos.x += invaderDir * invaderSpeed * speedMultiplier;
    }

    // lose if invaders reach the player line
    if (minY < playerY + 2.5)
        doGameOver();

    // Check if aliens are touching barriers - destroy any barrier blocks they touch
    for (const a of aliens)
    {
        if (a.destroyed) continue;
        for (const br of barriers)
        {
            if (br.destroyed) continue;
            if (aabbOverlap(a, br))
            {
                br.destroy();
            }
        }
    }

    // invader shooting
    if (alienShootTimer > 0) alienShootTimer--;
    if (alienShootTimer === 0)
    {
        alienFire();
        setRandomAlienShootTimer();
    }
}

function updateUFO()
{
    // Spawn UFO randomly
    if (!ufo || ufo.destroyed)
    {
        ufoSpawnTimer--;
        if (ufoSpawnTimer <= 0)
        {
            ufo = new UFO();
            ufoSpawnTimer = randIntInclusive(600, 1200); // 10-20 seconds
            sfxUFO.play(ufo.pos);
        }
    }
}

function updateMarchingSound()
{
    if (!aliens.length) return;
    
    // Speed up marching based on number of aliens left
    const aliveCount = aliens.length;
    const maxDelay = 40;
    const minDelay = 8;
    const delay = max(minDelay, maxDelay - (55 - aliveCount));
    
    marchTimer--;
    if (marchTimer <= 0)
    {
        marchTimer = delay;
        const sounds = [sfxMarch1, sfxMarch2, sfxMarch3, sfxMarch4];
        sounds[marchBeat % 4].play();
        marchBeat++;
    }
}

function alienFire()
{
    if (!aliens.length)
        return;

    // pick a random column from the alive aliens, then choose the lowest one in that column
    const colSize = 2.8;
    const cols = {};
    for (const a of aliens)
    {
        const col = (a.pos.x / colSize) | 0;
        const best = cols[col];
        if (!best || a.pos.y < best.pos.y)
            cols[col] = a;
    }

    const keys = Object.keys(cols);
    if (!keys.length)
        return;

    const pick = cols[keys[(rand(0, keys.length) | 0)]];
    bombs.push(new Bomb(pick.pos.add(vec2(0, -1.2))));
}

// ------------------------------------------------------------
// Collisions

function updateCollisions()
{
    // bullets vs aliens/barriers/UFO
    for (const b of bullets)
    {
        if (b.destroyed) continue;

        // vs UFO
        if (ufo && !ufo.destroyed && aabbOverlap(b, ufo))
        {
            b.destroy();
            score += ufo.pointValue;
            hiScore = max(hiScore, score);
            checkBonusLife();
            createExplosion(ufo.pos, rgb(.95,.25,.25), 20); // more particles for UFO
            ufo.destroy();
            sfxExplode.play(ufo.pos);
            continue;
        }

        // vs aliens
        for (const a of aliens)
        {
            if (a.destroyed) continue;
            if (!aabbOverlap(b, a)) continue;

            b.destroy();
            a.flash = 6;
            createExplosion(a.pos, a.color);
            a.destroy();
            score += 10;
            hiScore = max(hiScore, score);
            checkBonusLife();
            sfxExplode.play(a.pos);
            break;
        }

        if (b.destroyed) continue;

        // vs bombs (optional: shoot bombs)
        for (const bomb of bombs)
        {
            if (bomb.destroyed) continue;
            if (!aabbOverlap(b, bomb)) continue;
            b.destroy();
            bomb.destroy();
            score += 2;
            sfxHit.play(b.pos);
            break;
        }

        if (b.destroyed) continue;

        // vs barriers
        for (const br of barriers)
        {
            if (br.destroyed) continue;
            if (!aabbOverlap(b, br)) continue;
            b.destroy();
            br.destroy();
            sfxHit.play(br.pos);
            break;
        }
    }

    // bombs vs player/barriers
    for (const bomb of bombs)
    {
        if (bomb.destroyed) continue;

        // vs player
        if (player && !player.destroyed && aabbOverlap(bomb, player))
        {
            bomb.destroy();
            loseLife();
            continue;
        }

        // vs barriers
        for (const br of barriers)
        {
            if (br.destroyed) continue;
            if (!aabbOverlap(bomb, br)) continue;
            bomb.destroy();
            br.destroy();
            sfxHit.play(br.pos);
            break;
        }
    }
}

function loseLife()
{
    lives--;
    createExplosion(player.pos, rgb(.2,.9,.95), 20);
    sfxLoseLife.play(player.pos);

    // brief "respawn" by moving player to center and clearing bullets near bottom
    player.pos = vec2(levelSize.x/2, playerY);

    for (const b of bullets)
        b.pos.y < barrierY + 2 && b.destroy();
    for (const bomb of bombs)
        bomb.pos.y < barrierY + 4 && bomb.destroy();

    if (lives <= 0)
        doGameOver();
}

function doGameOver()
{
    if (gameOver) return;
    gameOver = true;
    createExplosion(player.pos, rgb(.2,.9,.95), 25);
    sfxExplode.play(player.pos);
}

function checkBonusLife()
{
    if (score >= nextBonusLife)
    {
        lives++;
        nextBonusLife += 1000; // Next bonus at +1000 points
        sfxBonusLife.play(player.pos);
    }
}

function cleanupArrays()
{
    // remove destroyed references
    aliens = aliens.filter(o=>!o.destroyed);
    bullets = bullets.filter(o=>!o.destroyed);
    bombs = bombs.filter(o=>!o.destroyed);
    barriers = barriers.filter(o=>!o.destroyed);
}

// ------------------------------------------------------------
// Start engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body>
