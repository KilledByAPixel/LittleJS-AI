<!DOCTYPE html><head>
  <meta charset="utf-8"/>
  <title>LittleJS Space Invaders</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
  </style>
</head><body>
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.11/dist/littlejs.js"></script>
<script>
'use strict';

// engine settings
debugWatermark = false;
showEngineVersion = false;

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squareness of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
        } = params;
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

// ------------------------------------------------------------
// Game constants

const levelSize = vec2(60, 34);
const playMin = vec2(0, 0);
const playMax = levelSize;

const playerY = 3;
const barrierY = 8;

// ------------------------------------------------------------
// Global game state

let player;
let aliens = [];
let bullets = [];
let bombs = [];
let barriers = [];

let score = 0;
let hiScore = 0;
let lives = 3;

let gameOver = false;
let gameWin = false;

let invaderDir = 1;
let invaderSpeed = .10;        // world units per frame
let invaderDrop = 1.0;         // world units
let invaderAnimTick = 0;

let alienShootTimer = 0;
let alienShootMin = 18;         // frames
let alienShootMax = 55;         // frames

let stars = [];
let credit = 0;

// Sounds
const sfxShoot    = new SoundGenerator({volume:.35, frequency:700, release:.07, shapeCurve:.2});
const sfxExplode  = new SoundGenerator({volume:.35, frequency:120, release:.22, noise:.2, shapeCurve:1.6, slide:-.4});
const sfxHit      = new SoundGenerator({volume:.28, frequency:280, release:.08, shapeCurve:1.2});
const sfxLoseLife = new SoundGenerator({volume:.40, frequency:180, release:.25, shapeCurve:1.8, slide:-.2});

// ------------------------------------------------------------
// Helpers

function clampToPlayfield(pos, halfSize)
{
    pos.x = clamp(pos.x, playMin.x + halfSize.x, playMax.x - halfSize.x);
    pos.y = clamp(pos.y, playMin.y + halfSize.y, playMax.y - halfSize.y);
    return pos;
}

function aabbOverlap(a, b)
{
    return isOverlapping(a.pos, a.size, b.pos, b.size);
}

function randIntInclusive(a, b)
{
    return (rand(a, b+1) | 0);
}

function setRandomAlienShootTimer()
{
    alienShootTimer = randIntInclusive(alienShootMin, alienShootMax);
}

function resetGame()
{
    // clear objects
    engineObjectsDestroy(true);

    aliens.length = 0;
    bullets.length = 0;
    bombs.length = 0;
    barriers.length = 0;

    score = 0;
    lives = 3;
    gameOver = false;
    gameWin = false;

    invaderDir = 1;
    invaderSpeed = .10;
    invaderDrop = 1.0;
    invaderAnimTick = 0;

    alienShootMin = 18;
    alienShootMax = 55;
    setRandomAlienShootTimer();

    player = new Player(vec2(levelSize.x/2, playerY));
    createBarriers();
    createAliens();
}

// ------------------------------------------------------------
// Objects

class RectObject extends EngineObject
{
    constructor(pos, size, color)
    {
        super(pos, size);
        this.color = color || WHITE;
        this.renderOrder = 0;
    }
    render()
    {
        drawRect(this.pos, this.size, this.color);
    }
}

class Player extends RectObject
{
    constructor(pos)
    {
        super(pos, vec2(3.2, 1.4), rgb(.2,.9,.95));
        this.cooldown = 0;
        this.renderOrder = 10;
    }
    update()
    {
        if (gameOver || gameWin)
            return;

        // left/right move (no dt; fixed 60fps)
        let move = 0;
        if (keyIsDown('ArrowLeft') || keyIsDown('KeyA')) move -= 1;
        if (keyIsDown('ArrowRight') || keyIsDown('KeyD')) move += 1;
        this.pos.x += move * .55;
        clampToPlayfield(this.pos, this.size.scale(.5));

        // shoot
        if (this.cooldown > 0) this.cooldown--;
        if (this.cooldown === 0 && (keyWasPressed('Space') || keyWasPressed('KeyK')))
        {
            this.cooldown = 10;
            bullets.push(new Bullet(this.pos.add(vec2(0, this.size.y/2 + .6)), vec2(0, 1.2), true));
            sfxShoot.play(this.pos);
        }
    }
    
    render()
    {
        // Classic player ship sprite
        const p = this.pos;
        const s = .22;
        
        drawRect(p.add(vec2(0,.3)), vec2(s,s*2), this.color); // cannon
        drawRect(p, vec2(s*7,s*3), this.color); // main body
        drawRect(p.add(vec2(-1.1,-.3)), vec2(s*2,s), this.color); // left wing
        drawRect(p.add(vec2(1.1,-.3)), vec2(s*2,s), this.color); // right wing
    }
}

class Alien extends RectObject
{
    constructor(pos, row)
    {
        const colors = [
            rgb(.2,.95,.2),   // row 0 - green (top)
            rgb(.25,.85,.95), // row 1 - cyan
            rgb(.25,.85,.95), // row 2 - cyan
            rgb(.95,.4,.95),  // row 3 - magenta
            rgb(.95,.4,.95)   // row 4 - magenta (bottom)
        ];
        const base = colors[row % 5];
        super(pos, vec2(2.3, 1.6), base);
        this.row = row;
        this.renderOrder = 5;
        this.flash = 0;
    }
    render()
    {
        const frame = (invaderAnimTick>>3) & 1;
        
        // Draw pixelated alien sprites based on row type
        if (this.row === 0) {
            // Top row - squid
            this.renderSquid(frame);
        } else if (this.row === 1 || this.row === 2) {
            // Middle rows - crab
            this.renderCrab(frame);
        } else {
            // Bottom rows - octopus
            this.renderOctopus(frame);
        }

        if (this.flash)
        {
            drawRect(this.pos, this.size.add(vec2(.2,.2)), rgb(1,1,1,.55));
            this.flash--;
        }
    }
    
    renderSquid(frame)
    {
        const p = this.pos;
        const s = .22; // pixel size
        
        if (frame === 0) {
            // Frame 1
            drawRect(p.add(vec2(0,.6)), vec2(s*3,s), this.color); // top
            drawRect(p.add(vec2(-.6,.3)), vec2(s,s*3), this.color); // left antenna
            drawRect(p.add(vec2(.6,.3)), vec2(s,s*3), this.color); // right antenna
            drawRect(p.add(vec2(0,0)), vec2(s*6,s*4), this.color); // body
            drawRect(p.add(vec2(-0.8,-.5)), vec2(s,s*2), this.color); // legs
            drawRect(p.add(vec2(-0.3,-.5)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(0.3,-.5)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(0.8,-.5)), vec2(s,s*2), this.color);
        } else {
            // Frame 2
            drawRect(p.add(vec2(0,.6)), vec2(s*3,s), this.color);
            drawRect(p.add(vec2(-.6,.3)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.6,.3)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(0,0)), vec2(s*6,s*4), this.color);
            drawRect(p.add(vec2(-0.8,-.4)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.8,-.4)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(-0.3,-.6)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.3,-.6)), vec2(s*2,s), this.color);
        }
    }
    
    renderCrab(frame)
    {
        const p = this.pos;
        const s = .22;
        
        if (frame === 0) {
            drawRect(p.add(vec2(-.8,.5)), vec2(s,s*2), this.color); // claws up
            drawRect(p.add(vec2(.8,.5)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(0,.3)), vec2(s*7,s*2), this.color); // top
            drawRect(p.add(vec2(0,0)), vec2(s*5,s*3), this.color); // body
            drawRect(p.add(vec2(-0.9,-.3)), vec2(s*2,s), this.color); // legs
            drawRect(p.add(vec2(-0.4,-.5)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.4,-.5)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.9,-.3)), vec2(s*2,s), this.color);
        } else {
            drawRect(p.add(vec2(-.8,.3)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(.8,.3)), vec2(s,s*2), this.color);
            drawRect(p.add(vec2(0,.3)), vec2(s*7,s*2), this.color);
            drawRect(p.add(vec2(0,0)), vec2(s*5,s*3), this.color);
            drawRect(p.add(vec2(-0.6,-.4)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(-0.9,-.5)), vec2(s,s), this.color);
            drawRect(p.add(vec2(0.6,-.4)), vec2(s*2,s), this.color);
            drawRect(p.add(vec2(0.9,-.5)), vec2(s,s), this.color);
        }
    }
    
    renderOctopus(frame)
    {
        const p = this.pos;
        const s = .22;
        
        if (frame === 0) {
            drawRect(p.add(vec2(0,.4)), vec2(s*5,s*3), this.color); // head
            drawRect(p.add(vec2(-.8,0)), vec2(s,s*3), this.color); // arms
            drawRect(p.add(vec2(-.3,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.3,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.8,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(-0.6,-.4)), vec2(s,s), this.color); // legs bent out
            drawRect(p.add(vec2(0.6,-.4)), vec2(s,s), this.color);
        } else {
            drawRect(p.add(vec2(0,.4)), vec2(s*5,s*3), this.color);
            drawRect(p.add(vec2(-.8,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(-.3,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.3,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(.8,0)), vec2(s,s*3), this.color);
            drawRect(p.add(vec2(-0.4,-.4)), vec2(s,s), this.color); // legs bent in
            drawRect(p.add(vec2(0.4,-.4)), vec2(s,s), this.color);
        }
    }
}

class Bullet extends RectObject
{
    constructor(pos, vel, fromPlayer)
    {
        super(pos, vec2(.25, 1.2), fromPlayer ? rgb(.95,.95,.95) : rgb(.95,.3,.3));
        this.vel = vel; // per frame
        this.fromPlayer = fromPlayer;
        this.renderOrder = 20;
    }
    update()
    {
        this.pos = this.pos.add(this.vel);
        if (this.pos.y > playMax.y + 2 || this.pos.y < playMin.y - 2)
            this.destroy();
    }
    render()
    {
        // Thinner, taller bullets
        drawRect(this.pos, this.size, this.color);
    }
}

class Bomb extends RectObject
{
    constructor(pos)
    {
        super(pos, vec2(.3, 1.0), rgb(.95,.95,.95));
        this.vel = vec2(0, -0.65);
        this.renderOrder = 20;
        this.animTick = 0;
    }
    update()
    {
        if (gameOver || gameWin)
            return;

        this.pos = this.pos.add(this.vel);
        this.animTick++;
        if (this.pos.y < playMin.y - 2)
            this.destroy();
    }
    
    render()
    {
        // Animated bomb - squiggly effect
        const frame = (this.animTick >> 2) % 4;
        const offset = [-.15, -.05, .05, .15][frame];
        drawRect(this.pos.add(vec2(offset, .3)), vec2(.25, .3), this.color);
        drawRect(this.pos.add(vec2(-offset, 0)), vec2(.25, .3), this.color);
        drawRect(this.pos.add(vec2(offset, -.3)), vec2(.25, .3), this.color);
    }
}

class BarrierBlock extends RectObject
{
    constructor(pos)
    {
        super(pos, vec2(.95,.95), rgb(.25,.95,.35));
        this.renderOrder = 8;
    }
}

// ------------------------------------------------------------
// Level creation

function createAliens()
{
    const cols = 11;
    const rows = 5;
    const startX = levelSize.x/2 - (cols-1)*2.8/2;
    const startY = levelSize.y - 6;
    const spacing = vec2(2.8, 2.3);

    for (let r=0; r<rows; r++)
    for (let c=0; c<cols; c++)
    {
        const p = vec2(startX + c*spacing.x, startY - r*spacing.y);
        aliens.push(new Alien(p, r));
    }
}

function createBarriers()
{
    const barrierCount = 4;
    const gap = levelSize.x/(barrierCount+1);

    for (let i=1; i<=barrierCount; i++)
    {
        const cx = gap*i;
        const cy = barrierY;

        // blocky classic shield shape (no sprites)
        const w = 8;
        const h = 5;
        for (let y=0; y<h; y++)
        for (let x=0; x<w; x++)
        {
            // carve a little arch
            const notch = (y===0 && (x===0||x===w-1)) ||
                          (y===1 && (x===0||x===w-1)) ||
                          (y>=3 && (x===3 || x===4) && y===h-1);
            if (notch) continue;

            const px = cx + (x - (w-1)/2)*1.0;
            const py = cy + (y - (h-1)/2)*1.0;
            const b = new BarrierBlock(vec2(px, py));
            barriers.push(b);
        }
    }
}

// ------------------------------------------------------------
// Game loop

function gameInit()
{
    setCanvasFixedSize(vec2(960, 540));
    setCameraPos(levelSize.scale(.5));
    cameraScale = 16; // pixels per world unit

    // No starfield for classic look
    stars = [];

    resetGame();
}

function gameUpdate()
{
    // restart
    if ((gameOver || gameWin) && keyWasPressed('Enter'))
        resetGame();

    invaderAnimTick++;

    if (gameOver || gameWin)
        return;

    updateInvaders();
    updateCollisions();
    cleanupArrays();

    // win condition
    if (!aliens.length)
    {
        gameWin = true;
        sfxExplode.play(player.pos);
    }
}

function gameUpdatePost()
{
    setCameraPos(levelSize.scale(.5));
}

function gameRender()
{
    // Pure black background
    drawRect(cameraPos, levelSize.add(vec2(20,20)), rgb(0,0,0));

    // playfield
    drawRect(cameraPos, levelSize, rgb(0,0,0));

    // Classic green floor line at bottom
    drawRect(vec2(levelSize.x/2, 0.6), vec2(levelSize.x, .25), rgb(.2,.95,.25));
}

function gameRenderPost()
{
    // Classic arcade HUD
    const hudY = 30;
    const color = rgb(.2,.95,.25);
    
    // SCORE<1> at top left
    drawTextScreen('SCORE<1>', vec2(80, hudY), 26, color);
    drawTextScreen(String(score).padStart(4, '0'), vec2(80, hudY + 32), 26, rgb(.95,.95,.95));
    
    // HI-SCORE in center
    drawTextScreen('HI-SCORE', vec2(mainCanvasSize.x/2, hudY), 26, color);
    drawTextScreen(String(hiScore).padStart(4, '0'), vec2(mainCanvasSize.x/2, hudY + 32), 26, rgb(.95,.95,.95));
    
    // SCORE<2> at top right  
    drawTextScreen('SCORE<2>', vec2(mainCanvasSize.x - 100, hudY), 26, color);
    
    // Lives indicator with ship icons at bottom left
    drawTextScreen(String(lives), vec2(70, mainCanvasSize.y - 40), 30, color);
    for (let i = 0; i < lives - 1 && i < 5; i++)
    {
        const px = 130 + i * 50;
        const py = mainCanvasSize.y - 40;
        // Draw mini player ships
        drawTextScreen('▲', vec2(px, py), 28, rgb(.2,.9,.95));
    }
    
    // CREDIT at bottom right
    drawTextScreen(`CREDIT ${String(credit).padStart(2, '0')}`, vec2(mainCanvasSize.x - 130, mainCanvasSize.y - 40), 26, color);

    // instructions
    drawTextScreen('←/→ or A/D to move   Space/K to shoot   Enter to restart',
        vec2(mainCanvasSize.x/2, mainCanvasSize.y-20), 20, rgb(.95,.95,.95,.6));

    if (gameOver)
    {
        drawTextScreen('GAME OVER', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 20), 80, rgb(.95,.25,.25), 8, rgb(0,0,0));
        drawTextScreen('Press Enter', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 45), 34, rgb(.95,.95,.95), 6, rgb(0,0,0));
    }
    else if (gameWin)
    {
        drawTextScreen('YOU WIN!', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 20), 80, rgb(.25,.95,.35), 8, rgb(0,0,0));
        drawTextScreen('Press Enter', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 45), 34, rgb(.95,.95,.95), 6, rgb(0,0,0));
    }
}

// ------------------------------------------------------------
// Invaders movement + shooting

function updateInvaders()
{
    if (!aliens.length)
        return;

    // compute formation bounds
    let minX = 1e9, maxX = -1e9, minY = 1e9;
    for (const a of aliens)
    {
        const half = a.size.x/2;
        minX = min(minX, a.pos.x - half);
        maxX = max(maxX, a.pos.x + half);
        minY = min(minY, a.pos.y - a.size.y/2);
    }

    const nextMinX = minX + invaderDir * invaderSpeed;
    const nextMaxX = maxX + invaderDir * invaderSpeed;

    let hitEdge = false;
    if (nextMinX < playMin.x + 1.2) hitEdge = true;
    if (nextMaxX > playMax.x - 1.2) hitEdge = true;

    if (hitEdge)
    {
        invaderDir *= -1;
        for (const a of aliens)
            a.pos.y -= invaderDrop;

        // slightly speed up as they descend
        invaderSpeed = min(invaderSpeed + .01, .32);
        alienShootMin = max(alienShootMin - 1, 6);
        alienShootMax = max(alienShootMax - 1, 16);
    }
    else
    {
        for (const a of aliens)
            a.pos.x += invaderDir * invaderSpeed;
    }

    // lose if invaders reach the player line
    if (minY < playerY + 2.5)
        doGameOver();

    // invader shooting
    if (alienShootTimer > 0) alienShootTimer--;
    if (alienShootTimer === 0)
    {
        alienFire();
        setRandomAlienShootTimer();
    }
}

function alienFire()
{
    if (!aliens.length)
        return;

    // pick a random column from the alive aliens, then choose the lowest one in that column
    const colSize = 2.8;
    const cols = {};
    for (const a of aliens)
    {
        const col = (a.pos.x / colSize) | 0;
        const best = cols[col];
        if (!best || a.pos.y < best.pos.y)
            cols[col] = a;
    }

    const keys = Object.keys(cols);
    if (!keys.length)
        return;

    const pick = cols[keys[(rand(0, keys.length) | 0)]];
    bombs.push(new Bomb(pick.pos.add(vec2(0, -1.2))));
}

// ------------------------------------------------------------
// Collisions

function updateCollisions()
{
    // bullets vs aliens/barriers
    for (const b of bullets)
    {
        if (b.destroyed) continue;

        // vs aliens
        for (const a of aliens)
        {
            if (a.destroyed) continue;
            if (!aabbOverlap(b, a)) continue;

            b.destroy();
            a.flash = 6;
            a.destroy();
            score += 10;
            hiScore = max(hiScore, score);
            sfxExplode.play(a.pos);
            break;
        }

        if (b.destroyed) continue;

        // vs bombs (optional: shoot bombs)
        for (const bomb of bombs)
        {
            if (bomb.destroyed) continue;
            if (!aabbOverlap(b, bomb)) continue;
            b.destroy();
            bomb.destroy();
            score += 2;
            sfxHit.play(b.pos);
            break;
        }

        if (b.destroyed) continue;

        // vs barriers
        for (const br of barriers)
        {
            if (br.destroyed) continue;
            if (!aabbOverlap(b, br)) continue;
            b.destroy();
            br.destroy();
            sfxHit.play(br.pos);
            break;
        }
    }

    // bombs vs player/barriers
    for (const bomb of bombs)
    {
        if (bomb.destroyed) continue;

        // vs player
        if (player && !player.destroyed && aabbOverlap(bomb, player))
        {
            bomb.destroy();
            loseLife();
            continue;
        }

        // vs barriers
        for (const br of barriers)
        {
            if (br.destroyed) continue;
            if (!aabbOverlap(bomb, br)) continue;
            bomb.destroy();
            br.destroy();
            sfxHit.play(br.pos);
            break;
        }
    }
}

function loseLife()
{
    lives--;
    sfxLoseLife.play(player.pos);

    // brief "respawn" by moving player to center and clearing bullets near bottom
    player.pos = vec2(levelSize.x/2, playerY);

    for (const b of bullets)
        b.pos.y < barrierY + 2 && b.destroy();
    for (const bomb of bombs)
        bomb.pos.y < barrierY + 4 && bomb.destroy();

    if (lives <= 0)
        doGameOver();
}

function doGameOver()
{
    if (gameOver) return;
    gameOver = true;
    sfxExplode.play(player.pos);
}

function cleanupArrays()
{
    // remove destroyed references
    aliens = aliens.filter(o=>!o.destroyed);
    bullets = bullets.filter(o=>!o.destroyed);
    bombs = bombs.filter(o=>!o.destroyed);
    barriers = barriers.filter(o=>!o.destroyed);
}

// ------------------------------------------------------------
// Start engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
</body>
