<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LittleJS Frogger</title>
  <style>
    html, body { margin:0; padding:0; background:#000; overflow:hidden; }
    canvas { image-rendering: pixelated; }
  </style>
</head>
<body>
  <script src="../dist/littlejs.js?1.18.0"></script>
  <script>
  'use strict';

  // ------------------------------------------------------------
  // Sound helper (from the LittleJS starter template)
  class SoundGenerator extends Sound {
    constructor(params = {}) {
      const {
        volume = 1,
        randomness = .05,
        frequency = 220,
        attack = 0,
        release = .1,
        shapeCurve = 1,
        slide = 0,
        pitchJump = 0,
        pitchJumpTime = 0,
        repeatTime = 0,
        noise = 0,
        bitCrush = 0,
        delay = 0,
      } = params;
      super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
  }

  // ------------------------------------------------------------
  // Simple Frogger (no textures, only primitives)

  const LEVEL_W = 30;
  const LEVEL_H = 20;
  const DT = 1/60;

  // lanes (grid y):
  // 0  = bottom margin
  // 1-3 grass (start)
  // 4-8 road
  // 9-10 grass (median)
  // 11-15 river (logs)
  // 16 home row (pads)
  // 17-19 water backdrop (not playable)

  const ROAD_MIN_Y  = 4;
  const ROAD_MAX_Y  = 8;
  const RIVER_MIN_Y = 11;
  const RIVER_MAX_Y = 15;
  const HOME_Y      = 16;

  const frogSize = vec2(.75, .75);

  const homeSlots = 5;
  const homeXs = Array.from({length: homeSlots}, (_,i)=>
    // spread across the width with margins
    (3 + i * (LEVEL_W-6)/(homeSlots-1))
  );

  // Game state
  let frog, cars = [], logs = [];
  let reached = new Array(homeSlots).fill(false);
  let lives = 3, score = 0, level = 1;
  let respawnTimer, flashTimer;

  // Sounds
  let sHop, sDie, sHome, sLevel;

  function gridToWorld(gx, gy) { return vec2(gx + .5, gy + .5); }
  function worldToGridPos(p) { return vec2(Math.floor(p.x), Math.floor(p.y)); }

  function clampFrogGrid(g) {
    g.x = clamp(g.x, 0, LEVEL_W-1);
    g.y = clamp(g.y, 0, LEVEL_H-1);
    return g;
  }

  function overlapAABB(posA, sizeA, posB, sizeB) {
    return Math.abs(posA.x - posB.x) < (sizeA.x + sizeB.x)/2 &&
           Math.abs(posA.y - posB.y) < (sizeA.y + sizeB.y)/2;
  }

  function resetRun(full=false) {
    frog.grid = vec2(Math.floor(LEVEL_W/2), 1);
    frog.pos = gridToWorld(frog.grid.x, frog.grid.y);
    frog.carryVx = 0;
    if (full) {
      reached.fill(false);
      score = 0;
      lives = 3;
      level = 1;
      buildLanes();
    }
  }

  function buildLanes() {
    cars.length = 0;
    logs.length = 0;

    // Helper to build a repeating stream of obstacles across the width
    const makeStream = (arr, y, dir, speed, count, sizeX, colorFn) => {
      for (let i=0; i<count; i++) {
        const x = (i * (LEVEL_W / count)) + rand(0, 2);
        arr.push({
          pos: vec2(x, y + .5),
          size: vec2(sizeX, .8),
          vx: dir * speed,
          color: colorFn(i),
        });
      }
    };

    const speedScale = (1 + (level-1) * .12) * .5; // half-speed cars + logs

    // Road lanes (cars)
    // Alternate directions/sizes for variety
    const roadDefs = [
      {y:4, dir: 1, speed: 5.5, count: 3, w: 1.8},
      {y:5, dir:-1, speed: 7.0, count: 3, w: 2.2},
      {y:6, dir: 1, speed: 8.5, count: 3, w: 1.5},
      {y:7, dir:-1, speed: 6.0, count: 3, w: 2.6},
      {y:8, dir: 1, speed: 7.8, count: 2, w: 3.0},
    ];

    for (const d of roadDefs) {
      makeStream(
        cars,
        d.y,
        d.dir,
        d.speed * speedScale,
        d.count,
        d.w,
        (i)=> hsl(((d.y*37 + i*61) % 360)/360, .8, .55)
      );
    }

    // River lanes (logs)
    const riverDefs = [
      {y:11, dir:-1, speed: 3.5, count: 4, w: 4.5},
      {y:12, dir: 1, speed: 4.2, count: 5, w: 3.6},
      {y:13, dir:-1, speed: 4.8, count: 4, w: 5.0},
      {y:14, dir: 1, speed: 3.9, count: 5, w: 3.2},
      {y:15, dir:-1, speed: 4.4, count: 4, w: 4.0},
    ];

    for (const d of riverDefs) {
      makeStream(
        logs,
        d.y,
        d.dir,
        d.speed * speedScale,
        d.count,
        d.w,
        (i)=> hsl(30/360, .55, .35 + .05*rand())
      );
    }
  }

  function killFrog() {
    if (respawnTimer.active()) return;
    sDie.play(frog.pos);
    lives--;
    respawnTimer.set(1);
    flashTimer.set(.6);
    if (lives < 0) {
      // reset after a short pause
      lives = 3;
      level = 1;
      score = 0;
      reached.fill(false);
      buildLanes();
    }
  }

  function reachHome(slotIndex) {
    if (reached[slotIndex]) return;
    reached[slotIndex] = true;
    score += 100;
    sHome.play(frog.pos);
    resetRun(false);

    // Level complete
    if (reached.every(Boolean)) {
      level++;
      score += 500;
      sLevel.play(vec2(LEVEL_W/2, HOME_Y+.5));
      reached.fill(false);
      buildLanes();
    }
  }

  function tryMove(dx, dy) {
    if (respawnTimer.active()) return;

    const g = frog.grid.copy();
    g.x += dx;
    g.y += dy;

    // Offscreen is death (classic Frogger)
    if (g.x < 0 || g.x >= LEVEL_W || g.y < 0 || g.y >= LEVEL_H) {
      killFrog();
      return;
    }

    // Don't allow moving above the home row (keeps layout clean)
    if (g.y > HOME_Y)
      return;

    frog.grid = g;
    frog.pos = gridToWorld(frog.grid.x, frog.grid.y);
    frog.carryVx = 0;
    sHop.play(frog.pos);

    // small score for forward progress
    if (dy > 0) score += 5;
  }

  function handleInput() {
    const up    = keyWasPressed('ArrowUp')   || keyWasPressed('KeyW');
    const down  = keyWasPressed('ArrowDown') || keyWasPressed('KeyS');
    const left  = keyWasPressed('ArrowLeft') || keyWasPressed('KeyA');
    const right = keyWasPressed('ArrowRight')|| keyWasPressed('KeyD');

    if (up)    return tryMove(0, 1);
    if (down)  return tryMove(0,-1);
    if (left)  return tryMove(-1,0);
    if (right) return tryMove(1, 0);
  }

  function updateObstacles(arr) {
    for (const o of arr) {
      o.pos.x += o.vx * DT;

      // wrap around with padding
      const pad = o.size.x/2 + 1;
      if (o.pos.x < -pad) o.pos.x = LEVEL_W + pad;
      if (o.pos.x > LEVEL_W + pad) o.pos.x = -pad;
    }
  }

  function frogWorldChecks() {
    if (respawnTimer.active()) return;

    // Car collision
    for (const c of cars) {
      if (overlapAABB(frog.pos, frogSize, c.pos, c.size)) {
        killFrog();
        return;
      }
    }

    // River logic
    const gy = frog.grid.y;
    const inRiver = gy >= RIVER_MIN_Y && gy <= RIVER_MAX_Y;
    if (inRiver) {
      let onLog = null;
      for (const l of logs) {
        if (overlapAABB(frog.pos, frogSize, l.pos, l.size)) { onLog = l; break; }
      }
      if (!onLog) {
        killFrog();
        return;
      }

      // carry frog
      frog.carryVx = onLog.vx;
      frog.pos.x += frog.carryVx * DT;

      // falling off edges is death
      if (frog.pos.x < .25 || frog.pos.x > LEVEL_W - .25) {
        killFrog();
        return;
      }

      // Update grid x from carried motion (for consistent row checks)
      frog.grid = clampFrogGrid(worldToGridPos(frog.pos));
    }

    // Home row
    if (frog.grid.y === HOME_Y) {
      // find nearest slot within a small window
      let best = -1;
      let bestDx = 999;
      for (let i=0;i<homeSlots;i++) {
        const dx = Math.abs(frog.pos.x - (homeXs[i] + .5));
        if (dx < bestDx) { bestDx = dx; best = i; }
      }

      // Require being close enough to a slot center
      if (bestDx < 1.3) {
        reachHome(best);
      } else {
        // hit the bushes!
        killFrog();
      }
    }
  }

  // ------------------------------------------------------------
  // Engine callbacks

  function gameInit() {
    setCanvasFixedSize(vec2(960, 540));
    cameraScale = 28; // pixels per world unit
    setCameraPos(vec2(LEVEL_W/2, LEVEL_H/2));

    // create frog
    frog = {
      grid: vec2(Math.floor(LEVEL_W/2), 1),
      pos: vec2(),
      carryVx: 0,
    };

    respawnTimer = new Timer(); respawnTimer.unset();
    flashTimer = new Timer(); flashTimer.unset();

    // Sounds
    sHop  = new SoundGenerator({ volume:.6, frequency:640, randomness:.08, attack:0, release:.06, shapeCurve:1.6 });
    sDie  = new SoundGenerator({ volume:.9, frequency:180, randomness:.2,  attack:0, release:.28, shapeCurve:.6, slide:-1.6, noise:.15 });
    sHome = new SoundGenerator({ volume:.8, frequency:720, randomness:.06, attack:0, release:.14, shapeCurve:1.2, pitchJump:360, pitchJumpTime:.04 });
    sLevel= new SoundGenerator({ volume:.9, frequency:420, randomness:.03, attack:0, release:.35, shapeCurve:1.1, repeatTime:.08, pitchJump:140, pitchJumpTime:.02 });

    buildLanes();
    resetRun(true);
  }

  function gameUpdate() {
    // handle respawn
    if (respawnTimer.elapsed()) {
      respawnTimer.unset();
      resetRun(false);
    }

    // input
    handleInput();

    // update obstacles
    updateObstacles(cars);
    updateObstacles(logs);

    // world interactions
    frogWorldChecks();
  }

  function gameUpdatePost() {
    // keep camera stable
    setCameraPos(vec2(LEVEL_W/2, LEVEL_H/2));
  }

  function drawLaneBackground() {
    // World background (slightly larger than level)
    drawRect(vec2(LEVEL_W/2, LEVEL_H/2), vec2(LEVEL_W+2, LEVEL_H+2), hsl(110/360,.35,.18));

    // Road
    const roadH = (ROAD_MAX_Y - ROAD_MIN_Y + 1);
    drawRect(vec2(LEVEL_W/2, ROAD_MIN_Y + roadH/2), vec2(LEVEL_W, roadH), hsl(0,0,.18));

    // Road lane separators
    for (let y=ROAD_MIN_Y; y<=ROAD_MAX_Y; y++) {
      drawRect(vec2(LEVEL_W/2, y+1), vec2(LEVEL_W, .05), hsl(50/360,.2,.5,.35));
    }

    // River + water behind the homes (extend water to the top)
    const riverH = (LEVEL_H - RIVER_MIN_Y);
    drawRect(vec2(LEVEL_W/2, RIVER_MIN_Y + riverH/2), vec2(LEVEL_W, riverH), hsl(205/360,.55,.28));

    // Median grass
    drawRect(vec2(LEVEL_W/2, 9.5), vec2(LEVEL_W, 2), hsl(120/360,.35,.2));

    // Home row highlight (still water behind)
    drawRect(vec2(LEVEL_W/2, HOME_Y+.5), vec2(LEVEL_W, 1), hsl(205/360,.55,.24));
    for (let i=0;i<homeSlots;i++) {
      const p = vec2(homeXs[i]+.5, HOME_Y+.5);
      const filled = reached[i];
      drawRect(p, vec2(1.6, .9), filled ? hsl(100/360,.5,.35) : hsl(95/360,.35,.22));
      if (!filled) drawCircle(p, .15, hsl(60/360,.35,.65,.7));
      else drawCircle(p, .18, hsl(0,0,1,.6));
    }

    // Level border
    drawRect(vec2(LEVEL_W/2, LEVEL_H/2), vec2(LEVEL_W, LEVEL_H), hsl(0,0,0,0), .12);
  }

  function gameRender() {
    drawLaneBackground();

    // logs
    for (const l of logs) {
      drawRect(l.pos, l.size, l.color);
      // little end caps
      const cap = vec2(.25, .65);
      drawRect(l.pos.add(vec2(-l.size.x/2 + .3, 0)), cap, hsl(35/360,.35,.22));
      drawRect(l.pos.add(vec2( l.size.x/2 - .3, 0)), cap, hsl(35/360,.35,.22));
    }

    // cars
    for (const c of cars) {
      drawRect(c.pos, c.size, c.color);
      // windows/stripe
      drawRect(c.pos.add(vec2(0, .18)), vec2(c.size.x*.55, .18), hsl(0,0,1,.35));
      drawRect(c.pos.add(vec2(0,-.18)), vec2(c.size.x*.75, .12), hsl(0,0,0,.2));
    }

    // frog (flash when dead)
    const frogVisible = !flashTimer.active() || (Math.floor(time*16) % 2 === 0);
    if (frogVisible) {
      drawRect(frog.pos, frogSize, hsl(105/360,.75,.45));
      drawRect(frog.pos.add(vec2(0,.18)), vec2(.55,.18), hsl(105/360,.65,.35));
      drawCircle(frog.pos.add(vec2(-.22,.22)), .06, hsl(0,0,1));
      drawCircle(frog.pos.add(vec2( .22,.22)), .06, hsl(0,0,1));
    }
  }

  function gameRenderPost() {
    const uiX = 18;
    const top = mainCanvasSize.y - 34;

    // HUD
    drawTextScreen(`FROGGER  •  Lives: ${Math.max(0,lives)}  •  Score: ${score}  •  Level: ${level}`,
      vec2(mainCanvasSize.x/2, 22), 32, hsl(0,0,1), 4, hsl(0,0,0));

    drawTextScreen(`Move: WASD / Arrows   •   Reach all 5 homes   •   Road = dodge cars   •   River = ride logs`,
      vec2(mainCanvasSize.x/2, 50), 18, hsl(0,0,.9), 3, hsl(0,0,0));

    if (respawnTimer.active()) {
      const t = respawnTimer.getPercent();
      drawTextScreen(lives < 0 ? 'GAME OVER' : 'SPLASH!',
        vec2(mainCanvasSize.x/2, mainCanvasSize.y/2), 90,
        hsl(0, .8, .55), 8, hsl(0,0,0));
      drawTextScreen('You will respawn in a moment...',
        vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 70), 24,
        hsl(0,0,1), 4, hsl(0,0,0));
    }

    // Reset
    if (keyWasPressed('KeyR')) {
      sDie.play(vec2(LEVEL_W/2, LEVEL_H/2));
      resetRun(true);
    }

    drawTextScreen('Press R to reset', vec2(uiX, top), 18, hsl(0,0,1), 3, hsl(0,0,0));
  }

  // Startup
  engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);
  </script>
</body>
</html>
